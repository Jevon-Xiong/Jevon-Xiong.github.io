---
layout: post
title: Linux
author: jevon xiong
tags:
- blog
- 嵌入式
- Liunx
date: 2024-03-12 10:41 +0800
toc: true
---

# Linux下的C编程

> int ret_val = scanf("%d", &num);
> getchar();//获取一个字符（从标准输入文件中获取）

标准输出 stdout 对应的是终端《带缓冲区》（屏幕）
标准出错 stderr 对应的是终端《无缓冲区》（屏幕）

```c
printf("%s--%s--%d\n", __FILE__, __FUNCTION__, __LINE__);
__FILE__ 文件名
__FUNCTION__ 函数名
__LINE__ 行号
```

++a;先自加
a++;先运算

进程的虚拟空间：

> 内核（kernel）
> 栈（stack）--由上往下增长--环境变量、命令行参数、局部变量
> 
> 堆（heap）--由下往上增长--由malloc(),calloc(),realloc(),free()分配和释放的内存
> 数据段--.bss（未初始化的静态数据）,.data（已初始化的静态数据）,.rodata（常量）
> 代码段--.text（用户代码），.init（系统初始化代码）
> 不可访问

静态变量：

> 1. 全局变量：定义在函数体之外的变量
> 2. 静态的局部变量：定义在函数体内部，且被static修饰--*初始化语句只会被执行一次*

const指针：

> 常指针 `char * const p`修饰指针本身，其内容无法改变（所指向的地址无法修改）
> 常目标指针 `const char * p`修饰所指向的目标，表示无法通过该指针改变目标的数据--用于只读

内联函数：

> inline int max(int x, int y);

## Linux基础

## 文件IO

Linux下的文件类型

1. 普通文件（regular）：存放普通数据
2. 目录文件（directory）：存放目录项
3. 管道文件（pipe）：用于进程间通信的特殊文件
4. 套接字文件（socket）：用于网络间通信的特殊文件
5. 链接文件（link）：用于间接访问另一个目标文件
6. 字符设备文件（character）：字符设备在应用层的访问接口
7. 块设备文件（block）：块设备在应用层的访问接口

man手册：

> man -f open // 通过man -f 来查询open 出现在哪些手册中
> man man
> 1 Executable programs or shell commands // 命令手册
> 2 System calls (functions provided by the kernel) // 系统函数手册
> 3 Library calls (functions within program libraries) // 库函数手册
> ...
> 
> man 2 open //在第二本手册中查询open函数

### 系统IO：

int open(const char * pathname, int flags);
int open(const char * pathname, int flags, mode_t mode);
pathname --> 需要打开的文件的 路径+名字 （如果没有写路径则默认为当前路径）
flags --> 旗标（标志实质是就是一个数字）
mode --> 文件的初始化权限（只有在创建新文件的时候生效）

ssize_t write (int fd, const void * buf, size_t count);
ssize_t read( int fd, void * buf, size_t count);
fd --> 需要写入的文件的描述符
buf --> 需要写入的数据所在的内存地址
count --> 需要写入的字节数

off_t lseek(int fildes, off_t offset, int whence);
fildes --> 需要移动读写位置的文件的描述符
offset --> 偏移量设置
whence --> 偏移的模式

int close(int fd);
fd --> 需要关闭的文件的描述符

### 标准IO

FILE * fopen(const char * path, const char * mode);
path --> 需要打开的文件的路径+名字
mode --> 打开的形式

size_t fwrite(const void * ptr, size_t size, size_t nmemb, FILE * stream);
ptr --> 需要写入的内容的地址
size --> 需要写入的字节数（10） 《数据块的大小》
nmemb --> 需要写入多少块数据（多少次） （2） 《需要写入多少块数据》
stream --> 需要写入的文件的文件指针

int fclose(FILE * stream);
stream --> 需要关闭的文件的文件指针

移动文件流的读写位置 ：
int fseek(FILE * stream, long offset, int whence);
stream --> 需要操作的文件的文件指针
offset --> 偏移量
whence --> 偏移的模式

取得文件流的读取位置
long ftell(FILE * stream);
stream --> 需要取地读写位置的文件指针

文件内容的读取/写入：

按字节读取/写入文本的内容
int getchar() // 从标准输入文件中读取一个字节
int fgetc(FILE * stream) ; // 函数
int getc(FILE * stream) ; // 宏定义

int putchar (int c); // 把一个字符写入到标准输出文件中
int putc(int c, FILE * stream); // 宏定义
int fputc(int c, FILE * stream); // 把 整型c转为字符并写入到 stream 所对应文件中

char * fgets(char * s, int size, FILE * stream);//按行进行读取/写入到文件中
char * gets(char *s); // 从标准输入中读取一个字符串

int fputs(const char * s, FILE * stream); // 把s所指向则内存写入到stream 所指向的文件中
int puts(const char *s); // 把一个字符串输出到标准输出文件中

int feof(FILE * stream); // 检查文件流是否读到了文件尾，如果到达文件末尾则返回非零值
int ferror(FILE *stream); // 检查文件流是否有错误发生，如有错误发生则返回非 0 值

按指定格式读取/写入文件
int scanf(const char *format, ...); // 从标准输入文件中按指定格式来读取信息
int fscanf(FILE *stream, const char *format, ...);// 从指定文件中按指定格式来读取信息
int sscanf(const char *str, const char *format, ...); //从指定的内存中按指定格式来读取信息
int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int dprintf(int fd, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);

按数据块读取
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite( void *ptr, size_t size, size_t nmemb, FILE *stream);

### 标准IO缓冲区

使用标准 IO 函数处理文件的最大特点是，数据将会先存储在一个标准 IO缓冲区中，而后在一定条件下才被一并 flush（冲洗，或称刷新）至内核缓冲区，而不是像系统 IO 那样，数据直接被 flush 至内核。
缓冲区有份三种： （只有写入操作时需要用到缓冲区）

1. 不缓冲类型
   一旦有数据到达，则立刻刷线到外围设备（硬盘/LCD/终端..）
2. 全缓冲
   一旦数据填满了缓冲区，立刻刷新到外围设备
   程序正常退出，立刻刷新到外围设备
   遇到 fflush()函数强制刷新，立刻刷新到外围设备
   关闭文件，立刻刷新到外围设备
   读取文件内容的时候，立刻刷新到外围设备
   改变缓冲区类型的时候，立刻刷新到外围设备
3. 行缓冲
   一旦数据填满了缓冲区，立刻刷新到外围设备
   程序正常退出，立刻刷新到外围设备
   遇到 fflush()函数强制刷新，立刻刷新到外围设备
   关闭文件，立刻刷新到外围设备
   读取文件内容的时候，立刻刷新到外围设备
   改变缓冲区类型的时候，立刻刷新到外围设备
   当遇到 \n 换行符的时候，立刻刷新到外围设备

缓冲区都是针对写入操作而言， 缓冲区的存在是为了提高效率（外围设备与CPU的速度差）

对于输出设备：
标准输出而言，默认是行缓冲
标准出错默认为不缓冲
普通文件默认是全缓冲
如果有数据滞留在缓冲区中， 并程序异常退出，则有可能导致数据丢失
以上三种缓冲的类型可以通过 setbuf/setvbuf来设置/修改

### 文件属性

在操作文件的时候，经常需要获取文件的属性，比如类型、权限、大小、所有者等等，这些信息对于比如文件的传输、管理等是必不可少的，而这些信息，可以使用下面的函数之一来获取

int stat(const char *path, struct stat *buf)
int fstat(int fd, struct stat *buf);
int lstat(const char *path, struct stat *buf);
stat 需要的是一个文件的路径+名字，如果该文件为连接文件则会获取到连接文件所指向的文件
lstat 需要的是一个文件的路径+名字，如果该文件为连接文件则会获得该连接文件的属性
fstat 需要的是一个文件描述符

属性结构体 stat 中有两个成员涉及文件的设备号，他们分别是 st_dev 和 st_rdev，前者只对普通文件有效，它包含了普通文件所在的设备的设备号，因此这个成员对于特殊文件而言是无意义的。而 st_rdev 恰好相反，他储存的是特殊设备文件本身的设备号，因此st_rdev 对于普通文件而言是无效的。

int major(dev_t dev);//返回主设备号
int minor(dev_t dev);//返回次设备号

### 目录检索

linux中的目录是一个文件索引表

DIR *opendir(const char *name);//打开目录已获得目录指针

struct dirent *readdir(DIR *dirp);//读取目录项

## linux系统编程

### 进程基础

程序：指的是一个被存放于硬盘当中的一个静态的文件。文件内容包含一些待执行的代码和部分待处理的数据。
进程：指的是一个程序文件被加载到内存中，并由CPU来执行其内部的指令以及处理数据的过程，进程是一个活的状态，也就具备了开始于结束的过程。
内核中实际上产生了一个叫 task_struct{}的结构体来表示这个进程。进程是一个“活动的实体”，这个活动的实体从一开始诞生就需要各种各样的资源以便于生存下去，比如内存资源、CPU 资源、文件、信号、各种锁资源等

创建一个新的进程
pid_t fork(void);
该函数的返回：

- 子进程返回 0
- 父进程返回的是子进程的ID

pid_t getpid(void);//获取自己的ID
pid_t getppid(void);//获取父进程的ID

父子进程的以下属性在创建之初完全一样，子进程相当于搞了一份复制品：
A) 实际 UID 和 GID，以及有效 UID 和 GID。
B) 所有环境变量。
C) 进程组 ID 和会话 ID。
D) 当前工作路径。除非用 chdir()加以修改
E) 打开的文件。
F) 信号响应函数。
G) 整个内存空间，包括栈、堆、数据段、代码段、标准 IO 的缓冲区等等。

以下属性，父子进程是不一样的：
A) 进程号 PID。PID 是身份证号码，哪怕亲如父子，也要区分开。
B) 记录锁。父进程对某文件加了把锁，子进程不会继承这把锁。
C) 挂起的信号。这些信号是所谓的“悬而未决”的信号，等待着进程的响应，子进程
也不会继承这些信号。

在进程中加载新的程序文件或者脚本，覆盖原有代码，重新运行。（父子进程的意义）
int execl(const char *path, const char *arg, ...);
...

退出本进程
void _exit(int status);
void exit(int status);

- exit()函数退出的时候会自动冲刷缓冲区
- 使用exit函数退出时如果由注册退出处理函数则会被执行
- _exit() 函数则没有以上两个动作，而是直接退出
- status 是在进程退出后被存放在该进程的尸体中，需要等待父进程进行接受并解析
- 当我们进程退出后将会产生一个尸体（称为僵尸态-占用内存），需要等待父进程进行处理并设置为死亡（不占用内存）

等待子进程
pit_t wait(int *stat_loc);
pid_t waitpid(pid_t pid, int *stat_loc, int options);

### 进程状态

就绪态（TASK_RUNNING）

- 当程序被用户执行/其父进程调用fork成功常见一个进程则进入就绪状态
- 就绪状态并不代表正在运行，必须被CPU执行才称为运行态
- 就绪态实质是实在一个队列中按照优先级排队等待

运行态(TACK_RUNNING--cpu)

- 进程从就绪状态被 sched( )被称（调度器）选中进入CPU 并逐条处理他的指令
- 在运行态下如果时间片被耗光则该进程会回到就绪态的队列末尾中重新排队等待
- 如果被更高优先级的进程抢占时间，则进程回到就绪态的队列头部进行等待
- 在运行态中如果由于某个资源暂时不可获得将会进入挂起/睡眠状态

睡眠/挂起(TASK_INTERRUPTIBLE/TASK_UNINTERRUPTIBLE)

- 由于某个资源暂时不可获得
- 用户使用seelp函数
- TASK_INTERRUPIBLE 或者 TASK_UNINTERRUPIBLE
  - TASK_INTERRUPIBLE 浅睡眠， 进程在该状态下可以别信号唤醒（比如等待某个文件的资源， 当资源可获得的时候将会产生一个信号把你唤醒）
  - TASK_UNINTERRUPIBLE 与某些硬件相关， 深度睡眠， 在睡眠过程中不会响应信号

暂停态(TASK_STOPPED/TASK_TRACED)

- 当进程收到 SIGSTOP 或者 SIGTSTP 之一则会从运行态变为暂停态
- 在该状态下不参与系统的任何调度
- 一直要等到 SIGCONT 才会重新参与系统进程调度

僵尸态(TASK_ZOMBLE)

- 当进程退出（主函数遇到renturn / 调用exit .. 等） 情况下进程退出，进入到僵尸状态
- 僵尸状态下的尸体中存放退出的各种状态以及信息，比如是否真否正常退出，退出值 / 异常退出， 退出原因 / 信号杀死 ， 信号的值是多少等信息
- 等待父进程来查看子进程的尸体，获取其中的数据
- 当父进程成功获取到子进程的退出信息后，则会把该僵尸设置为退出状态（真正走向死亡）

死亡态(EXIT_DEAD)

- 应该由父进程调用wait( ) / waitpid( )来查看孩子的“死亡信息” ， 从而把该进程的状态设置为死亡状态
- 如果父进程事前挂掉了，那么该进程由祖父进程（INIT）来接受并处理他的尸体

### 进程间通信

进程间的通信（IPC）方式，总归起来主要有如下这些：
1，无名管道（PIPE）和有名管道（FIFO）。
2，信号（signal）。
3，system V-IPC 之共享内存。
4，system V-IPC 之消息队列。
5，system V-IPC 之信号量。
6，套接字。

**管道**
PIPE 的特征：
1，没有名字，因此无法使用 open( )。
2，只能用于亲缘进程间（比如父子进程、兄弟进程、祖孙进程……）通信。
3，半双工工作方式：读写端分开。
4，写入操作不具有原子性，因此只能用于一对一的简单通信情形。
5，不能使用 lseek( )来定位。

有名管道 FIFO 的特征：
1，有名字，存储于普通文件系统之中。
2，任何具有相应权限的进程都可以使用 open( )来获取 FIFO 的文件描述符。
3，跟普通文件一样：使用统一的 read( )/write( )来读写。
4，跟普通文件不同：不能使用 lseek( )来定位，原因同 PIPE。
5，具有写入原子性，支持多写者同时进行写操作而数据不会互相践踏。
6，First In First Out，最先被写入 FIFO 的数据，最先被读出来。

管道文件在打开的时候如果只有一方（读者/写者）则阻塞等待对方到达然后同时打开文件 。

**信号**
kill -l // 罗列出系统中的信号

Linux 系统中有许多信号，其中前面 31 个信号都有一个特殊的名字，对应一个特殊的事件，这些信号都是从 Unix 系统继承下来的，他们还有个名称叫“不可靠信号”，他们有如下的特点：
1，非实时信号不排队，信号的响应会相互嵌套。
2，如果目标进程没有及时响应非实时信号，那么随后到达的该信号将会被丢弃。
3，每一个非实时信号都对应一个系统事件，当这个事件发生时，将产生这个信号。
4，如果进程的挂起信号中含有实时和非实时信号，那么进程优先响应实时信号并且会从大到小依此响应，而非实时信号没有固定的次序。

后面的 31 个信号（从 SIGRTMIN[34] 到 SIGRTMAX[64]）是 Linux 系统新增的实时信号，也被称为“可靠信号”，这些信号的特征是：
1，实时信号的响应次序按接收顺序排队，不嵌套。
2，即使相同的实时信号被同时发送多次，也不会被丢弃，而会依次挨个响应。
3，实时信号没有特殊的系统事件与之对应。

事件发生时会产生相应的信号，但并不是说该信号的产生就一定发生了这个事件。事实上，任何进程都可以使用函数 kill( )来产生任何信号。
信号 SIGKILL 和 SIGSTOP 是两个特殊的信号，他们不能被忽略、阻塞或捕捉，只能按缺省动作来响应。换句话说，除了这两个信号之外的其他信号，接收信号的目标进程，按照如下顺序来做出反应：
A) 如果该信号被阻塞，那么将该信号挂起，不对其做任何处理，等到解除对其阻塞为止。否则进入 B。
B) 如果该信号被捕捉，那么进一步判断捕捉的类型：

- B1) 如果设置了响应函数，那么执行该响应函数。
- B2) 如果设置为忽略，那么直接丢弃该信号。
  否则进入 C。
  C) 执行该信号的缺省动作

`int kill(pid_t pid, int sig);`

`void (*signal(int sig, void(*func)(int)))(int);`
信号响应函数可以继承到子进程中

**消息队列**
消息队列、共享内存和信号量被统称为 system-V IPC，V 是罗马数字 5，是 Unix 的AT&T 分支的其中一个版本，一般习惯称呼他们为 IPC 对象，这些对象的操作接口都比较类似，在系统中他们都使用一种叫做 key 的键值来唯一标识，而且他们都是“持续性”资源——即他们被创建之后，不会因为进程的退出而消失，而会持续地存在，除非调用特殊的函数或者命令删除他们。

跟文件类似，进程每次“打开”一个 IPC 对象，就会获得一个表征这个对象的 ID（相当文件 IO中的文件描述符），进而再使用这个 ID 来操作这个对象。IPC 对象的 key 是唯一的，但是 ID 是可变的。key 类似于文件的路径名，ID 类似于文件的描述符。

系统中的多个进程，如果他们需要使用IPC对象来通信，那么他们必须持有这个对象的键值key

IPC对象的键值key一般用函数ftok()产生
key_t ftok(const char *pathname, int proj_id);
这个函数需要注意的几点:
1，如果两个参数相同，那么产生的key值也相同。
2，第一个参数一般取进程所在的目录，因为在一个项目中需要通信的几个进程通常会出现在同一个目录当中。
3，如果同一个目录中的进程需要超过1个IPC对象，可以通过第二个参数来标识。4，系统中只有一套 key标识，也就是说，不同类型的IPC对象也不能重复

ipcs 查看IPC对象

消息队列（MSG）
消息队列提供一种带有数据标识的特殊管道，使得每一段被写入的数据都变成带标识的消息，读取该段消息的进程只要指定这个标识就可以正确地读取，而不会受到其他消息的干扰。

int msgget(key_t key, int msgflg);

使用这两个收、发消息函数需要注意以下几点：
1，发送消息时，消息必须被组织成以下形式：

```c
struct msgbuf
{
    long mtype; // 消息的标识
    char mtext[1]; // 消息的正文 可以是任何类型数据
};
```

也就是说：发送出去的消息必须以一个 long 型数据打头，作为该消息的标识，后面的数据则没有要求
2，消息的标识可以是任意长整型数值，但不能是 0L。
3，参数 msgsz 是消息中正文的大小，不包含消息的标识。

消息队列的使用方法一般是：
1，发送者：
A) 获取消息队列的 ID
B) 将数据放入一个附带有标识的特殊的结构体，发送给消息队列。
2，接收者：
A) 获取消息队列的 ID
B) 将指定标识的消息读出

**共享内存（SHM）**

- 共享内存是效率最高的IPC，因为他抛弃了内核这个“代理人”，直截了当地将一块裸露的内存放在需要数据传输的进程面前，让他们自己搞，这样的代价是:这些进程必须小心谨慎地操作这块裸露的共享内存，做好诸如同步、互斥等工作，毕竟现在没有人帮他们来管理了，一切都要自己动手。也因为这个原因，共享内存一般不能单独使用，而要配合信号量互斥锁等协调机制，让各个进程在高效交换数据的同时，不会发生数据践踏、破坏等意外
- 共享内存的思想很朴素,进程与进程之间虚拟内存空间本来相互独立,不能互相访问的,但是可以通过某些方式，使得相同的一块物理内存多次映射到不同的进程虚拟空间之中，这样的效果就相当于多个进程的虚拟内存空间部分重叠在一起

使用共享内存的一般步骤是：
1，获取共享内存对象的 ID
2，将共享内存映射至本进程虚拟内存空间的某个区域
3，当不再使用时，解除映射关系
4，当没有进程再需要这块共享内存时，删除它。

**信号量**
1，多个进程或线程有可能同时访问的资源（变量、链表、文件等等）称为**共享资源**，也叫**临界资源**（critical resources）。
2，访问这些资源的代码称为**临界代码**，这些代码区域称为*临界区*（critical zone）。
3，程序进入临界区之前必须要对资源进行申请，这个动作被称为 P 操作（申请资源），这就像你要把车开进停车场之前，先要向保安申请一张停车卡一样，P 操作就是申请资源，如果申请成功，资源数将会减少。如果申请失败，要不在门口等，要不走人。
4，程序离开临界区之后必须要释放相应的资源，这个动作被称为 V 操作，这就像你把车开出停车场之后，要将停车卡归还给保安一样，V 操作就是释放资源，释放资源就是让资源数增加。

信号量的 P、V 操作最核心的特征是：他们是原子性的，也就是说对信号量元素的值的增加和减少，系统保证在 CPU 的电气特性级别上不可分割，这跟整型数据的加减法有本质的区别。

### 多线程

线程基本概念
线程实际上是应用层的概念，在 Linux 内核中，所有的调度实体都被称为任务（task）他们之间的区别是：有些任务自己拥有一套完整的资源，而有些任务彼此之间共享一套资源。

创建一条线程
``int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);``

对此函数的使用需要知道以下几点：
1，线程例程指的是：如果线程创建成功，那么该线程会立即去执行的函数。
2，POSIX 线程库的所有 API 对返回值的处理原则都是一致的：成功返回 0，失败返回错误码 errno。
3，线程属性如果为 NULL，则会创建一个标准属性的线程

线程属性变量的使用步骤是：
1，定义线程属性变量，并且使用 pthread_attr_init( )初始化。
2，使用 pthread_attr_setXXX( )来设置相关的属性。
3，使用该线程属性变量创建相应的线程。
4，使用 pthread_attr_destroy( )销毁该线程属性变量。

一条线程如果是可接合的，意味着这条线程在退出时不会自动释放自身资源，而会成为僵尸线程，同时意味着该线程的退出值可以被其他线程获取。因此，如果不需要某条线程的退出值的话，那么最好将线程设置为分离状态，以保证该线程不会成为僵尸线程。
默认情况下线程是接合属性

线程跟进程类似，在缺省的状态下退出之后，会变成僵尸线程，并且保留退出值。其他线程可以通过相关 API 接合该线程——使其资源被系统回收，如果愿意的话还可以顺便获取其退出值。

1，当线程的调度策略为 SCHED_FIFO 时，其静态优先级（static priority）必须设置为 1-99，这将意味着一旦这种线程处于就绪态时，他能立即抢占任何静态优先级为 0 的普通线程。采用 SCHED_FIFO 调度策略的线程还遵循以下规则：
A) 当他处于就绪态时，就会被放入其所在优先级队列的队尾位置。
B) 当被更高优先级的线程抢占后，他会被放入其所在优先级队列的队头位置，当所有优先级比他高的线程不再运行后，他就恢复运行。
C) 当他调用 sched_yield( )后，他会被放入其所在优先级队列的队尾的位置。
总的来讲，一个具有 SCHED_FIFO 调度策略的线程会一直运行直到发送 I/O 请求，或者被更高优先级线程抢占，或者调用 sched_yield( )主动让出 CPU。
2，当线程的调度策略为 SCHED_RR 时，情况跟 SCHED_FIFO 是一样的，区别在于：每一个 SHCED_RR 策略下的线程都将会被分配一个额度的时间片，当时间片耗光时，他会被放入其所在优先级队列的队尾的位置。可以用 sched_rr_get_interval( )来获得时间片的具体数值。
3，当线程的调度策略为 SCHED_OTHER 时，其静态优先级（static priority）必须设置为 0。该调度策略是 Linux 系统调度的默认策略，处于 0 优先级别的这些线程按照所谓的动态优先级被调度，而动态优先级起始于线程的 nice 值，且每当一个线程已处于就绪态但被调度器调度无视时，其动态优先级会自动增加一个单位，这样能保证这些线程竞争CPU 的公平性。

线程的动态优先级（dynamic prioriy）是非实时的普通线程独有的概念，之所以被称为“动态”，是因为它会随着线程的运行，根据线程的表现而发生改变，具体来讲是——如果一条线程是“CPU 消耗型”的，比如视频解码算法，这类线程只要一运行就黏住 CPU不放，这样的线程的动态优先级会被慢慢地降级，这符合我们的预期，因为这类线程不需要很高的响应速度，你只要保证一定的执行时间片就可以了。相反，另一类线程被称为“IO消耗型”，比如编辑器，这类线程绝大部分的时间都在睡眠，调度器发现每次调度他他都毅然决然地放弃了，将宝贵的 CPU 让给了其他线程，了不起是个大好人，因此会慢慢地提高他的动态优先级，使得这类线程在同等的非实时普通线程中，有越来越高的响应速度，表现出更好的交互性能，这也正是我们想要的结果。

如果发现一条线程的栈有可能会溢出，那么也许需要使用该函数来增大栈空间，但事实上常常不需要这么做，而警戒区指的是没有任何访问权限的内存，用来保护相邻的两条线程的栈空间不被彼此践踏。

而当线程收到一个取消请求时，他将会如何表现取决于两个东西：
一是当前的取消状态：

- PTHREAD_CANCEL_ENABLE 使能 （允许取消。默认值）
- PTHREAD_CANCEL_DISABLE 失能 （不允许取消）
  二是当前的取消类型：
- 延时响应 等待线程遇到取消点时响应取消的请求
- 立即响应
  取消点：

### 线程安全

**POSIX 信号量**：
POSIX 有名信号量：可以在进程之间使用（属于系统级别的资源，基本可以替代IPC中的信号量）
POSIX 无名信号量：只能在进程的内部，线程之间互相使用（使用同一个内存区）

POSIX 有名信号量
这种有名信号量的名字由类似“/somename”这样的字符串组成，注意前面有一个正斜杠，这样的信号量其实是一个特殊的文件，创建成功之后将会被放置在系统的一个特殊的虚拟文件系统/dev/shm 之中，不同的进程间只要约定好一个相同的名字，他们就可以通过这种有名信号量来相互协调。
值得一提的是，有名信号量跟 system-V 的信号量都是系统范畴的，在进程退出之后他们并不会自动消失，而需要手工删除并释放资源。

POSIX 有名信号量的一般使用步骤是：
1，使用 sem_open( )来创建或者打开一个有名信号量。
2，使用 sem_wait( )和 sem_post( )来分别进行 P 操作和 V 操作。
3，使用 sem_close( )来关闭他。
4，使用 sem_unlink( )来删除他，并释放系统资源。

不像 system-V 的信号量可以申请或者释放超过 1 个资源，对于 POSIX 信号量而言，每次申请和释放的资源数都是 1。其中调用 sem_wait( )在资源为 0 时会导致阻塞，如果不想阻塞等待，可以使用 sem_trywait( )来替代。

POSIX 无名信号量
如果我们要解决的是一个进程内部的线程间的同步互斥，那么也许不需要使用有名信号量，因为这些线程共享同一个内存空间，我们可以定义更加轻量化的、基于内存的（不在任何文件系统内部）无名信号量来达到目的。

这种信号量的使用步骤是：
1，在这些线程都能访问到的区域定义这种变量（比如全局变量），类型是 sem_t。
2，在任何线程使用它之前，用 sem_init( )初始化他。
3，使用 sem_wait( )/sem_trywait( )和 sem_post( )来分别进行 P、V 操作。
4，不再需要时，使用 sem_destroy( )来销毁他。

无名信号量一般用在进程内的线程间，因此 pshared 参数一般都为 0。当将此种信号量用在进程间时，必须将他定义在各个进程都能访问的地方——比如共享内存之中。

对于我们接触过的三种信号量：system-V 信号量和 POSIX 信号量（named-sem 和unnamed-sem），下面是他们的区别：
1，sys-V 信号量较古老，语法艰涩。POSIX 信号量简单，轻量。
2，sys-V 信号量可以对代表多种资源的多个信号量元素同一时间进行原子性的 P/V操作，POSIX 信号量每次只能操作一个信号量。
3，sys-V 信号量和 named-sem 是系统范围的资源，进程消失之后继续存在，而unnamed-sem 是进程范围的资源，随着进程的退出而消失。
4，sys-V 信号量的 P/V 操作可以对信号量元素加减大于 1 的数值，而 POSIX 信号量每次 P/V 操作都是加减 1。
5，sys-V 信号量甚至还支持撤销操作——一个进程对 sys-V 信号量进行 P/V 操作时可以给 该操作贴上需要撤销的标识，那么当进程退出之后，系统会自动撤销那些做了标识的操作。而 POSIX 信号没有此功能。
6，sys-V 信号量和 named-sem 适合用在进程间同步互斥，而 unamed-sem 适合用在线程间同步互斥。

总的来说，system-V 的信号量功能强大，强大到臃肿啰嗦，如果在现实工作中不需要那些高级功能，建议使用接口清晰、逻辑简单的 POSIX 信号量

### 互斥锁与读写锁

**互斥锁**
当我们实现的路基为互斥的逻辑时可以使用互斥锁来实现

操作步骤：

1. 初始化互斥锁资源 pthread_mutex_init（）
2. 访问某个资源之前先上锁 pthread_mutex_lock（）
3. 访问结束后应该解锁 pthread_mutex_unlock（）
4. 当不再使用的时候应该销毁到锁资源 pthread_mutex_destroy ( )

pthread_mutex_init（初始化互斥锁）

加锁/尝试加锁/解锁/销毁
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
int pthread_mutex_destroy(pthread_mutex_t *mutex);

**读写锁**
使用互斥锁的时候， 可以有效的保护某一个共共享资源， 使得该资源在任何情况下都只能有一个线程在访问。如果出现多个线程进行读取某一资源的时候就会造成多个线程在获取该资源是阻塞等待， 导致程序的效率降低。
因此以以上情况中，如果某一个资源有可能在同一时间内会有多个线程进行同时访问，那么就可以使用读写锁。
读锁：在同一时间内允许有多个线程进行读取资源，可以同时添加多个读锁
写锁：在同一个时间内只允许有一个线程进行读取资源， 不允许有其它线程持有锁资源

操作步骤：

1. 初始化读写锁pthread_rwlock_init（）
2. 添加读锁 / 写锁pthread_rwlock_rdlock / pthread_rwlock_wrlock
3. 当不再使用共享资源的时候解锁pthread_rwlock_unlock（）
4. 当不需要使用读写锁时可以销毁pthread_rwlock_destroy()

初始化/销毁读写锁：
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
const pthread_rwlockattr_t *restrict attr);

阻塞添加读/写锁/非阻塞添加读/写锁/解锁
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

注意：
不管是读锁还是写锁，在加锁的时候都需要判断当前共享资源的状态：

- 读锁： 当一个线程需要读取消息的时候，应该先检查是否有写锁的存在，如果有则等待，否则添加读锁。
- 写锁： 当一个线程需要写入某个消息的时候，应该先检查是否有人正在读取，如果有则等待，否则添加写锁，进制其它线程进入。

### 条件变量

条件变量是另一种逻辑复杂一点的同步互斥机制，其必须跟互斥锁一起配合使用
作用：
当有多个线程需要获得同一个资源进行操作的时候，如果当前资源量未空， 那么就需要让所有来获取资源的线程进入一个条件变量的等待队列中进行等待，等待资源数据到达， 当资源数据到达的时候条件变量则可以选择从队列中唤醒线程进行读取资源（唤醒可以唤醒一个或多个）

