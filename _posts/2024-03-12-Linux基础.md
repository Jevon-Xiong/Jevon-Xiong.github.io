---
layout: post
title: Linux
author: jevon xiong
tags:
- blog
- 嵌入式
- Liunx
date: 2024-03-12 10:41 +0800
toc: true
---

# Linux下的C编程

标准输入 stdin 对应的是键盘文件
>int ret_val = scanf("%d", &num);
>getchar();//获取一个字符（从标准输入文件中获取）

标准输出 stdout 对应的是终端《带缓冲区》（屏幕）
标准出错 stderr 对应的是终端《无缓冲区》（屏幕）

``` c
printf("%s--%s--%d\n", __FILE__, __FUNCTION__, __LINE__);
__FILE__ 文件名
__FUNCTION__ 函数名
__LINE__ 行号
```

++a;先自加
a++;先运算

进程的虚拟空间：
>内核（kernel）
>栈（stack）--由上往下增长--环境变量、命令行参数、局部变量
>
>堆（heap）--由下往上增长--由malloc(),calloc(),realloc(),free()分配和释放的内存
>数据段--.bss（未初始化的静态数据）,.data（已初始化的静态数据）,.rodata（常量）
>代码段--.text（用户代码），.init（系统初始化代码）
>不可访问

静态变量：
>1. 全局变量：定义在函数体之外的变量
>2. 静态的局部变量：定义在函数体内部，且被static修饰--*初始化语句只会被执行一次*

const指针：
>常指针`char * const p`修饰指针本身，其内容无法改变（所指向的地址无法修改）
>常目标指针`const char * p`修饰所指向的目标，表示无法通过该指针改变目标的数据--用于只读

内联函数：
>inline int max(int x, int y);

## Linux基础

## 文件IO
Linux下的文件类型
1. 普通文件（regular）：存放普通数据
2. 目录文件（directory）：存放目录项
3. 管道文件（pipe）：用于进程间通信的特殊文件
4. 套接字文件（socket）：用于网络间通信的特殊文件
5. 链接文件（link）：用于间接访问另一个目标文件
6. 字符设备文件（character）：字符设备在应用层的访问接口
7. 块设备文件（block）：块设备在应用层的访问接口

man手册：
>man -f open // 通过man -f 来查询open 出现在哪些手册中
>man man
>1 Executable programs or shell commands // 命令手册
>2 System calls (functions provided by the kernel) // 系统函数手册
>3 Library calls (functions within program libraries) // 库函数手册
>...
>
>man 2 open //在第二本手册中查询open函数

### 系统IO：
int open(const char * pathname, int flags);
int open(const char * pathname, int flags, mode_t mode);
pathname --> 需要打开的文件的 路径+名字 （如果没有写路径则默认为当前路径）
flags --> 旗标（标志实质是就是一个数字）
mode --> 文件的初始化权限（只有在创建新文件的时候生效）

ssize_t write (int fd, const void * buf, size_t count);
ssize_t read( int fd, void * buf, size_t count);
fd --> 需要写入的文件的描述符
buf --> 需要写入的数据所在的内存地址
count --> 需要写入的字节数

off_t lseek(int fildes, off_t offset, int whence);
fildes --> 需要移动读写位置的文件的描述符
offset --> 偏移量设置
whence --> 偏移的模式

int close(int fd);
fd --> 需要关闭的文件的描述符

### 标准IO

FILE * fopen(const char * path, const char * mode);
path --> 需要打开的文件的路径+名字
mode --> 打开的形式

size_t fwrite(const void * ptr, size_t size, size_t nmemb, FILE * stream);
ptr --> 需要写入的内容的地址
size --> 需要写入的字节数（10） 《数据块的大小》
nmemb --> 需要写入多少块数据（多少次） （2） 《需要写入多少块数据》
stream --> 需要写入的文件的文件指针

int fclose(FILE * stream);
stream --> 需要关闭的文件的文件指针

移动文件流的读写位置 ：
int fseek(FILE * stream, long offset, int whence);
stream --> 需要操作的文件的文件指针
offset --> 偏移量
whence --> 偏移的模式

取得文件流的读取位置
long ftell(FILE * stream);
stream --> 需要取地读写位置的文件指针

文件内容的读取/写入：

按字节读取/写入文本的内容
int getchar() // 从标准输入文件中读取一个字节
int fgetc(FILE * stream) ; // 函数
int getc(FILE * stream) ; // 宏定义

int putchar (int c); // 把一个字符写入到标准输出文件中
int putc(int c, FILE * stream); // 宏定义
int fputc(int c, FILE * stream); // 把 整型c转为字符并写入到 stream 所对应文件中

char * fgets(char * s, int size, FILE * stream);//按行进行读取/写入到文件中
char * gets(char *s); // 从标准输入中读取一个字符串

int fputs(const char * s, FILE * stream); // 把s所指向则内存写入到stream 所指向的文件中
int puts(const char *s); // 把一个字符串输出到标准输出文件中

int feof(FILE * stream); // 检查文件流是否读到了文件尾，如果到达文件末尾则返回非零值
int ferror(FILE *stream); // 检查文件流是否有错误发生，如有错误发生则返回非 0 值

按指定格式读取/写入文件
int scanf(const char *format, ...); // 从标准输入文件中按指定格式来读取信息
int fscanf(FILE *stream, const char *format, ...);// 从指定文件中按指定格式来读取信息
int sscanf(const char *str, const char *format, ...); //从指定的内存中按指定格式来读取信息
int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int dprintf(int fd, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);

按数据块读取
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite( void *ptr, size_t size, size_t nmemb, FILE *stream);

### 标准IO缓冲区
使用标准 IO 函数处理文件的最大特点是，数据将会先存储在一个标准 IO缓冲区中，而后在一定条件下才被一并 flush（冲洗，或称刷新）至内核缓冲区，而不是像系统 IO 那样，数据直接被 flush 至内核。
缓冲区有份三种： （只有写入操作时需要用到缓冲区）
1. 不缓冲类型
    一旦有数据到达，则立刻刷线到外围设备（硬盘/LCD/终端..）
2. 全缓冲
    一旦数据填满了缓冲区，立刻刷新到外围设备
    程序正常退出，立刻刷新到外围设备
    遇到 fflush()函数强制刷新，立刻刷新到外围设备
    关闭文件，立刻刷新到外围设备
    读取文件内容的时候，立刻刷新到外围设备
    改变缓冲区类型的时候，立刻刷新到外围设备
3. 行缓冲
    一旦数据填满了缓冲区，立刻刷新到外围设备
    程序正常退出，立刻刷新到外围设备
    遇到 fflush()函数强制刷新，立刻刷新到外围设备
    关闭文件，立刻刷新到外围设备
    读取文件内容的时候，立刻刷新到外围设备
    改变缓冲区类型的时候，立刻刷新到外围设备
    当遇到 \n 换行符的时候，立刻刷新到外围设备

缓冲区都是针对写入操作而言， 缓冲区的存在是为了提高效率（外围设备与CPU的速度差）

对于输出设备：
    标准输出而言，默认是行缓冲
    标准出错默认为不缓冲
    普通文件默认是全缓冲
如果有数据滞留在缓冲区中， 并程序异常退出，则有可能导致数据丢失
以上三种缓冲的类型可以通过 setbuf/setvbuf来设置/修改

### 文件属性
在操作文件的时候，经常需要获取文件的属性，比如类型、权限、大小、所有者等等，这些信息对于比如文件的传输、管理等是必不可少的，而这些信息，可以使用下面的函数之一来获取

int stat(const char *path, struct stat *buf)






