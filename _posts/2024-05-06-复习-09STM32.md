---
layout: post
title: 复习-09SMT32
author: jevon xiong
tags:
- blog
- 复习
- STM32
date: 2024-05-06 11:00 +0800
toc: true
---
[TOC]

# STM32

## 0 ARM概述

ARM：经典系列、Cortex-M系列、Cortex-A系列

**Cortex-M4：**Cortex-M3+FPU（浮点运算单元），**168MHz**

Cortex-A系列：消费类电子，高性能设备，手机/平板CPU

**关于内部硬件的控制，按照以下步骤进行库函数的使用**

- 打开硬件电源时钟
- 配置硬件
- 使能硬件工作

## 1 开发平台

![image-20240506101226216](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506101226216.png)

![image-20240506101245592](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506101245592.png)

## 2 环境搭建

MDK就是微控制器开发套件的意思。

keil编程

Define：添加“USE_STDPERIPH_DRIVER”，目的使用ST官方提供的库函数；代码优化等级推荐勾选为“Level 2（-O2）”，利于程序运行速度提高和体积减少。

## 3 GPIO

 GPIO,即通用I/O(输入/输出)端口，是STM32可控制的引脚。

STM32F407有7组IO。分别为GPIOA~GPIOG，每组IO有16个IO口，共有112个IO口。通常称为 PAx、PBx、PCx、PDx、PEx、PFx、PGx，其中x为0-15，并且F4系列是基于Cortex-M4内核。

GPIO的复用：

  STM32F4 有很多的内置外设，这些外设的外部引脚都是与 GPIO 共用的。也就是说，一个引脚可以有很多作用，但是默认为IO口，如果想使用一个 GPIO内置外设的功能引脚，就需要GPIO的复用，那么当这个 **GPIO 作为内置外设使用的时候，就叫做复用**。

**GPIO的工作模式**

**4种输入模式**

（1）GPIO_Mode_IN_FLOATING 浮空输入（即不连接内部上下拉电阻）

（2）GPIO_Mode_IPU 上拉输入

（3）GPIO_Mode_IPD 下拉输入

（4）GPIO_Mode_AIN 模拟输入

**4种输出模式** 

（1）GPIO_Mode_Out_OD 开漏输出（带上拉或者下拉）

（2）GPIO_Mode_AF_OD 复用开漏输出（带上拉或者下拉）

（3）GPIO_Mode_Out_PP 推挽输出（带上拉或者下拉）

（4）GPIO_Mode_AF_PP 复用推挽输出（带上拉或者下拉）

**输出配置**

对 I/O 端口进行编程作为输出时：

- 输出缓冲器被打开：

​    --开漏模式：输出寄存器中的“0”可激活 N-MOS，而输出寄存器中的“1”会使端 口保持高组态 (Hi-Z)（P-MOS 始终不激活）。

​    --推挽模式：输出寄存器中的“0”可激活 N-MOS，而输出寄存器中的“1”可激活P-MOS。 

- 施密特触发器输入被打开
- 根据 GPIOx_PUPDR 寄存器中的值决定是否打开弱上拉电阻和下拉电阻
- 输入数据寄存器每隔 1 个 AHB1 时钟周期对 I/O 引脚上的数据进行一次采样
- 对输入数据寄存器的读访问可获取 I/O 状态
- 对输出数据寄存器的读访问可获取最后的写入值

![image-20240506101649763](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506101649763.png)

 推挽电路（push-pull）就是两个不同极性晶体管间连接的输出电路。推挽电路采用两个参数相同的功率BJT管或MOSFET管，以推挽方式存在于电路中，各负责正负半周的波形放大任务，电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小效率高。推挽输出既可以向负载灌电流，也可以从负载抽取电流。

  在电路设计中，推挽输出是一种很常用的输出模式。推挽输出有很多优点，比如更低的损耗，更安全的输出等。推挽”之意，即为当一个管子推出去时，另一个管子拉回来。输入不同，交替导通。

举个例子

- 当输入信号为高电平的时候，上面的管子导通，下面的管子截止，输出信号为高电平。
- 当输入信号为低电平的时候，上面的管子截止，下面的管子导通，输出信号为低电平。

MOS管

N型mos比P型mos管使用的多

N型mos管比P型mos管的开关速度快（工艺的影响 ），所以Pmos开关损耗多，发热严重

Nmos比Pmos耐压高

Nmos通过电流能力比较大，因此常用于推挽电路的下管。

**输入配置**

对 I/O 端口进行编程作为输入时：

- 输出缓冲器被关闭
- 施密特触发器输入被打开
- 根据 GPIOx_PUPDR 寄存器中的值决定是否打开上拉和下拉电阻
- 输入数据寄存器每隔 1 个 AHB1 时钟周期对 I/O 引脚上的数据进行一次采样
- 对输入数据寄存器的读访问可获取 I/O 状态

![image-20240506101719055](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506101719055.png)

**复用功能配置**

对 I/O 端口进行编程作为复用功能时：

- 可将输出缓冲器配置为开漏或推挽
- 输出缓冲器由来自外设的信号驱动（发送器使能和数据）
- 施密特触发器输入被打开
- 根据 GPIOx_PUPDR 寄存器中的值决定是否打开上拉电阻和下拉电阻
- 输入数据寄存器每隔 1 个 AHB1 时钟周期对 I/O 引脚上的数据进行一次采样
- 对输入数据寄存器的读访问可获取 I/O 状态

![image-20240506101742330](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506101742330.png)

**模拟配置**

对 I/O 端口进行编程作为模拟配置时：

- 输出缓冲器被禁止。
- 施密特触发器输入停用，I/O 引脚的每个模拟输入的功耗变为零。施密特触发器的输出被 强制处理为恒定值 (0)。 
- 弱上拉和下拉电阻被关闭。
- 对输入数据寄存器的读访问值为“0”。

在模拟配置中，I/O 引脚不能为 5 V 容忍

![image-20240506101757170](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506101757170.png)



**4种最大输出速度**

（1）2MHZ (低速)

（2）25MHZ (中速)

（3）50MHZ (快速)

（4）100MHZ (高速)

推挽输出既可以向负载灌电流，也可以从负载抽取电流。

 在电路设计中，推挽输出是一种很常用的输出模式。推挽输出有很多优点，比如更低的损耗，更安全的输出等。推挽”之意，即为当一个管子推出去时，另一个管子拉回来。输入不同，交替导通。

**使用库函数编程技巧**

1. 阅读硬件原理图，了解当前需要使用STM32芯片哪个硬件，就可以知道使用哪些库函数接口。

2. 使用库函数的时候，只需要了解该函数的使用方法，如传入参数、返回值、功能描述就足矣。库函数里面的编写内容不需要了解，这些代码都是由ST公司去实现的。

3. 如何使用库函数实现一个具体的功能，ST公司都会提供例子文档，告诉我们库函数如何使用，如函数前后的调用顺序，详细硬件初始化流程，无论是新手还是老手都要看。

- STM32F4xx中文参考手册.pdf
- stm32f4xx_dsp_stdperiph_lib_um.chm

4. 使用的编程**标准C**，也就是ANSI C编程。
5. 库函数规律

   - 硬件时钟 socket


   - 硬件配置 bind


   - 硬件控制 sendto、recvfrom

       


**1.端口硬件时钟使能**

void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)

**2.GPIO的初始化**

void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)

**3.GPIO初始化结构体**

GPIO_InitTypeDef

**4.GPIO的引脚电平设置**

void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)

- 设置低电平

  void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)

  设置引脚电平，可以尝试GPIO_Write、GPIO_WriteBit函数

- 读取某个端口引脚电平

  uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)

## 4 时钟体系

**时钟体系**给单片机提供一个时钟信号（一个非常稳定的频率信号），使单片机各内部组件同步工作，并且在和外部设备通信时是也能达到同步。

动态调整运行频率，就可以控制性能与功耗！

1、参考手册 STM32F4xx 中文参考手册.pdf 第 106 页

2、时钟源

a.可以使用三种不同的时钟源来驱动**系统时钟 (SYSCLK)**，CPU 运行的频率为 168MHz：

● **HSI** 振荡器时钟，也就是高速内部时钟，**一般来说很少用，因为精度没有外部高速时钟那么高。**

● **HSE** 振荡器时钟，也就是高速外部时钟，GECM4 开发板 8MHz。

● 主 PLL (**PLL**) 时钟

b.器件具有以下两个次级时钟源：

● 32 kHz 低速内部 RC (**LSI RC**)，该 RC 用于驱动独立看门狗，也可选择提供给 RTC 用于停机/待机模式下的自动唤醒。

● 32.768 kHz 低速外部晶振（**LSE 晶振**），用于驱动 RTC 时钟 (RTCCLK)对于每个时钟源来说，在未使用时都可单独打开或者关闭，以降低功耗。

![image-20240506102135307](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506102135307.png)

**二、PLL倍频公式**

![image-20240506102143499](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506102143499.png)

不同的芯片，倍频（频率翻倍）公式是不一样的，需要查询芯片手册！

**三、SystemInit系统初始化函数**

1.其实第一个执行的文件是汇编文件

- 栈的初始化，提供函数调用的时候进行现场保护和现场恢复

- 堆的初始化，为申请内存提供空间，调用malloc

- 执行Reset_Handler，意思说上电复位后执行的动作

- 执行SystemInit函数

- 跳转到main函数

2.初始化Flash接口，更新PLL系统频率  

**SetSysClock();**

3.调用SetSysClock函数设置PLL时钟，然后进行分频

  **RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |**          **(RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);**

system_stm32f4xx.c文件有以下倍频(PLL_N)与分频(PLL_M、PLL_P)因子：

```
/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N */
#define PLL_M      25     //(记得修改为8)
/* USB OTG FS, SDIO and RNG Clock =  PLL_VCO / PLLQ */
#define PLL_Q      7
 
#if defined (STM32F40_41xxx)
#define PLL_N      336
/* SYSCLK = PLL_VCO / PLL_P */
#define PLL_P      2
#endif /* STM32F40_41xxx */
```

由于官方的代码是使用外部高速晶振25MHz，GEC-M4开发板是使用外部高速晶振8MHz，所以PLL的倍频因子要进行修改，只修改**PLL_M为8**。

4.阅读system_stm32f4xx.c文件的头部注释

 \*    HSE Frequency(Hz)           | 25000000  粤嵌开发板外部晶振是8MHz，我们要将25MHz修改为8MHz

接着修改stm32f4xx.h以下内容，行127将外部晶振频率值修改为8MHz。

```
#if !defined  (HSE_VALUE)
  #define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz */
#endif /* HSE_VALUE */
```

最后按照PLL的运算公式，最终得到输出频率为168MHz。

![image-20240506102758781](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506102758781.png)

\#注意事项

1.在《STM32F4xx中文参考手册》 P117页，PLL_M、PLL_N、PLL_P，这三个参数都有一定的范围限制，详细如下：

2≤ PLL_M ≤63 

192≤ PLL_N ≤432 

PLL_P：2、4、6、8

在保证功能实现的前提下，尽可能降低功耗，可以切换**频率更低的时钟源提供给系统时钟**。

![image-20240506102841858](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506102841858.png)

1.选择**PLL**作为系统时钟源（最大168MHz）

RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW)); 

RCC->CFGR |= RCC_CFGR_SW_PLL;	

2.选择**HSI**作为系统时钟源（16MHz）

RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW)); 

RCC->CFGR |= RCC_CFGR_SW_HSI;	

3.选择**HSE**作为系统时钟源（8MHz）

RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW)); 

RCC->CFGR |= RCC_CFGR_SW_HSE;

这就对应调节 CPU 的运行频率，来控制系统的性能与功耗，比如手机/笔记本电脑都有高性能模式、平衡模式、低性能模式。

## 5 位带操作

1.意义

回想以前写51代码

P0 = 0x10;   //将P0端口设置为0x10 

P1_0=1;    //将P1端口0号引脚设置为高电平 

a = P2_2;   //获取P2端口2号引脚的电平

根据上述的方法，我们可以发现快速定位修改某个引脚的电平还有获取引脚的状态

GPIO_SetBits、GPIO_ResetBits操作IO口的**性能**没有达到极致，因为这些函数都需要进行现场保护和现场恢复的动作，**比较耗时间**，没有进行一步到位，使用位带操作则没有上述的烦恼，**简单快速！**

示例1：

GPIO_SetBits(GPIOF,GPIO_Pin_9); 

修改为 

PFout(9)=1;

示例2： 

GPIO_ResetBits(GPIOF,GPIO_Pin_9); 

修改为 

PFout(9)=0;

 因为使用对引脚设置电平或读取电平，库函数效率是不高的，很难应付高性能的场合，如下代码，修改某引脚电平要执行起码3行代码，还不包括隐含的调用函数与函数返回的过程。

```
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
}
```



位带操作常用于I/O高度密集的芯片。

 Bit-band operation support allows a single load/store operation to access (read/write) to a single data bit. In the Cortex-M3 and Cortex-M4 processors, this is supported in **two pre-defifined memory regions（静态映射）** called bit-band regions. One of them is

![image-20240506103105519](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103105519.png)

There are two regions of memory for bit-band operations:

• 0x20000000~0x200FFFFF (SRAM, 1MB)

• 0x40000000~0x400FFFFF (Peripherals, 1MB)

2.映射表

![image-20240506103133517](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103133517.png)

![image-20240506103138429](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103138429.png)



关于IO引脚对应的访问地址，可以参考以下公式

寄存器的位带别名 = 0x42000000 + （寄存器的地址-0x40000000）x32 + 引脚编号x4

```C
// 将端口的访问封装为Pxout、Pxin，例如端口F引脚电平设置PFout，端口A引脚电平读取PAin。
#define PFout(x)	*(volatile uint32_t *)(0x42000000 + (GPIOF_BASE + 0x14 - 0x40000000)*32 + x*4)
#define PAin(x)	*(volatile uint32_t *)(0x42000000 + (GPIOA_BASE + 0x10 - 0x40000000)*32 + x*4)
```

![image-20240506103209727](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103209727.png)



优化：编译器想尽办法去压缩程序存储空间，提高运行速度。

一般编译器，优化有多个等级：-O0、-O1、-O2、-O3。 

-O0：缺省优化级别，不压缩程序存储空间，不提高程序运行速度，保证程序的可靠执行。

-O1：轻度优化，轻度压缩程序存储空间，轻度优化程序运行速度。

-O2：**推荐优化**等级，在程序存储空间和程序运行速度取得平衡点。

-O3：最高级别的优化等级，有可能导致程序不能运行，也会使用以空间换时间的方法，导致程序体积增大。



**volatile关键字**

volatile关键字分析，往往应用在三种场合

1）多线程编程共享全局变量的时候，该全局变量要加上**volatile**进行修饰，让编译器不要优化该变量。

2）裸机编程的时候，某函数与中断服务函数共享全局变量的时候，该全局变量要加上**volatile**进行修饰，让编译器不要优化该变量。

3）ARM定义寄存器的时候，寄存器是指向一个地址，要加上**volatile**进行修饰，让编译器不要优化而省略该变量的访问。

编译器不要优化该变量指的是防止编译器出现优化过度，导致代码运行失效。

**加上volatile关键字生成的汇编代码会发生明显的变化，同样调用delay函数，灯的速度发生变化！**

- 不添加volatile关键字

![image-20240506103329874](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103329874.png)

- 添加volatile关键字

![image-20240506103337955](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103337955.png)



## 6 外部中断

《Cortex M3与M4权威指南》章节4.5 P104

 Exceptions are events that cause changes to program flow. When one happens, the processor suspends the current executing task and executes a part of the program called the exception handler. After the execution of the exception handler is completed, the processor then resumes normal program execution. In the ARM architecture, interrupts are one type of exception. Interrupts are usually generated from peripheral or external inputs, and in some cases they can be triggered by software. The exception handlers for interrupts are also referred to as Interrupt Service Routines (ISR)。

 Each exception source has an exception number. **Exception numbers 1 to 15 as system exceptions, and exceptions 16 and above are for interrupts.** The design of the NVIC in the Cortex-M3 and Cortex-M4 processors can support up to 240 interrupt inputs. However, in practice the number of interrupt inputs imple mented in the design is far less, typically in the range of 16 to 100. In this way the silicon size of the design can be reduced, which also reduces power consumption.

![image-20240506103444698](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103444698.png)

Nested vectored interrupt controller (NVIC)

  The NVIC is a part of the Cortex-M processor. It is programmable and its registers are located in the System Control Space (SCS) of the memory map 

  The NVIC handles the exceptions and interrupt configurations, prioritization, and interrupt masking. The NVIC has the following features:

• Flexible exception and interrupt management

• Nested exception/interrupt support

• Vectored exception/interrupt entry

• Interrupt masking

1.系统异常

《Cortex M3与M4权威指南》章节7.2 P232

![image-20240506103505945](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103505945.png)

2.中断

![image-20240506103514606](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103514606.png)

（三）中断控制

《Cortex M3与M4权威指南》章节7.3 P235

![image-20240506103528283](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103528283.png)

After reset, all interrupts are disabled and given a priority-level value of 0. Before using any interrupts, you need to:

- Set up the priority level of the required interrupt (this step is optional)
- Enable the interrupt generation control in the peripheral that triggers the interrupt
- Enable the interrupt in the NVIC

In most typical applications, this is all you need to do. When the interrupt triggers, the corresponding Interrupt Service Routine (ISR) will execute (you might need to clear the interrupt request from the peripheral within the handler). The name of the ISR can be found inside the vector table inside the startup code, which is also provided by the microcontroller vendor. **The name of the ISR needs to match the name** **used in the vector table** **so that the linker can place the starting address of the ISR into the vector table correctly.**

 3.向量表（Vector table）

《Cortex M3与M4权威指南》章节4.5.3 P107

  When an exception event takes place and is accepted by the processor core, the corresponding exception handler is executed. To determine the starting address of the exception handler, a vector table mechanism is used. The vector table is an array of word data inside the system memory, each representing the starting address of one exception type。

二、ARM Cortex-M4 的中断体系

1、定义

中断，意味着**中途打断**现在干的事情，要立即处理紧急的事件

多达 140 个 GPIO（STM32F405xx/07xx 和 STM32F415xx/17xx）通过以下方式连接到 16 个外部中断/事件线。（  例如：PA0占用了EXTI0，其他PB0~PI0是不能使用的）

![image-20240506103623645](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103623645.png)

2.

  多达 140 个 GPIO（STM32F405xx/07xx 和 STM32F415xx/17xx）通过以下方式连接到 16 个外部中断/事件线。

  例如：PA0占用了EXTI0，其他PB0~PI0是不能使用的。

![image-20240506103652653](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103652653.png)



**引脚编号**决定了对应**哪个外部中断**。



二、代码思路

1.8051单片机

外部中断的触发方式：低电平触发、下降沿触发 IT0=1

允许外部中断引脚申请中断请求 EX0=1

优先级的配置

中断服务函数

2.STM32

**端口A硬件时钟使能**

**SYSCFG硬件时钟使能**

**配置引脚的工作模式**

**将引脚连接到外部中断**

**中断触发方式：电平触发、边沿触发**

**允许外部中断引脚申请中断请求**

**优先级的配置**

**中断服务函数**

注：

  中断服务函数是不能被**调用**，编写格式**不能随意编写**，这是它特有的存在形式。不同的硬件平台，其编写方法是不一样的。

三、函数接口

1.为引脚选择使用哪个中断

void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)

2.配置外部中断

void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)

3.中断优先级配置

void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)

4.获取外部中断状态

ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)

5.清空外部中断标志位

void EXTI_ClearITPendingBit(uint32_t EXTI_Line)

三、中断优先级

中断优先级的一个意义：出现多个中断同时触发，但是不能同时处理，所以**先后顺序**之分，要根据实际上的运行环境优先处理重要的中断。

 STM32 对中断优先级进行分组，共 5 组，组 0~4，这些分组是用于指定当前M4支持多少个抢占优先级和多少个响应优先级。同时，对每个中断设置一个抢占优先级和一个响应优先级。

```C
/**
  * @brief  Configures the priority grouping: pre-emption priority and subpriority.
  * @param  NVIC_PriorityGroup: specifies the priority grouping bits length. 
  *   This parameter can be one of the following values:
  *     @arg NVIC_PriorityGroup_0: 0 bits for pre-emption priority    //不支持抢占优先级
  *                                4 bits for subpriority             //支持16个响应优先级
  *     @arg NVIC_PriorityGroup_1: 1 bits for pre-emption priority    //支持2个抢占优先级
  *                                3 bits for subpriority             //支持8个响应优先级
  *     @arg NVIC_PriorityGroup_2: 2 bits for pre-emption priority    //支持4个抢占优先级
  *                                2 bits for subpriority             //支持4个响应优先级
  *     @arg NVIC_PriorityGroup_3: 3 bits for pre-emption priority    //支持8个抢占优先级
  *                                1 bits for subpriority             //支持2个响应优先级
  *     @arg NVIC_PriorityGroup_4: 4 bits for pre-emption priority    //支持16个抢占优先级
  *                                0 bits for subpriority             //不支持响应优先级
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t， NVIC_PriorityGroup)
```

**只要开机初始化一次就可以了。**

2.抢占优先级与响应优先级区别

1)高抢占优先级是可以打断正在进行的低抢占优先级的中断。抢占优先级若相同，则不会出现抢占的过程。

![image-20240506103839888](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103839888.png)

2)抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。

![image-20240506103846979](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103846979.png)

3)抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。

![image-20240506103852394](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103852394.png)

4)抢占优先级相同且响应优先级相同的中断，假如同时发生，会按照硬件内部固定的优先级执行，如下图。

![image-20240506103859007](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103859007.png)

![image-20240506103910254](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103910254.png)

5)无论是抢占优先级还是响应优先级，优先级数值越小，就代表优先级越高。

四、中断服务函数

中断服务函数要简单、高效完成，以下的delay函数是为了方便观察中断现象，在实际项目开发过程，是不会这么做的。

![image-20240506103931780](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103931780.png)

## 7 启动文件

一、复位顺序

《Cortex M3与M4权威指南》章节4.8 P113

![image-20240506103956284](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506103956284.png)

  After reset and before the processor starts executing the program, the Cortex-M processors read the first two words from the memory . The beginning of the memory space contains the vector table, and the first two words in the vector table are the initial value for the Main Stack Pointer (MSP), and the reset vector, which is the starting address of the reset handler . After these two words are read by the processor, the processor then sets up the MSP and the Program Counter (PC) with these values.

二、启动文件，startup_stm32f40x_41xx.s

1、定义

  启动文件由汇编编写，是系统上电复位后第一执行的程序。

2、特征

1）初始化堆栈指针，主要是为 C 语言提供良好的运行环境

2）进行复位处理，执行该 Reset_Handler 函数

3）初始化向量表，**中断入口地址列表**

4）配置系统的时钟，调用 SystemInit

5）调用 C 库函数__main 进入 main.c 中的 main 函数执行

三、异常向量表

1、8051

AT89S51 共有 5 个中断源，2 个外部中断、2 个定时器中断、1 个串口中断。

```
中断源		入口地址 	中断号
外部中断 0 		0003H 		0
定时器 0 		000BH 		1
外部中断 1 		0013H 		2
定时器 1 		001BH 		3
串口中断 		0023H 		4
```

![image-20240506104143135](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506104143135.png)

2.STM32

1）背景

  In most typical applications, this is all you need to do. When the interrupt triggers, the corresponding Interrupt Service Routine (ISR) will execute (you might need to clear the interrupt request from the peripheral within the handler). The name of the ISR can be found inside the vector table inside the startup code, which is also provided by the microcontroller vendor. **The name of the ISR needs to match the name** **used in the vector table** **so that the linker can place the starting address of the ISR into the vector table correctly.**

**中断服务函数的指定运行，由编译链接阶段已经决定好。**

2）有效的中断跳转

![image-20240506104210813](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506104210813.png)

3）无效的中断跳转

![image-20240506104219764](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506104219764.png)

WEAK关键字：

表示弱声明，若外部文件没有声明EXTI0_IRQHandler函数，则在编译链接的阶段，链接本文件即启动代码中的EXTI0_IRQHandler函数。反之，链接外部文件中的EXTI0_IRQHandler函数。

B  .:

  等同于一个while(1)循环，作用是捕获有问题的中断。例如中断服务函数名字有误或跟没有编写。当产生中断请求后，则跳转到启动代码中的中断服务函数执行程序，但启动代码中的中断服务函数是空函数，程序又得向下执行，最后被“B  .”捕捉到。

## 8 系统定时器

一、系统定时器

1. 简介

  SysTick 叫做系统滴答时钟、系统定时器，属于 Cortex-M4 内核中的一个外设(外围设备)，并且是**24bit 向下递减的计数器**。

《STM32中文参考手册》P108

  RCC 向 Cortex 系统定时器 (SysTick) 馈送 8 分频的 AHB 时钟 (HCLK)。SysTick 可使用此时钟作为时钟源，也可使用 HCLK 作为时钟源，具体可在 SysTick 控制和状态寄存器中配置。

注意：

- 定时器的位数越多，定时时间更长。
- 通过计数值间接计算定时时间，不能像操作系统直接调用函数实现延时或定时功能。

计数值，就是要进行多少个计数。

![image-20240506104327381](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506104327381.png)

三、库函数

参考文档：《Cortex M3与M4权威指南.pdf》第314页

1.系统定时器配置

__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)

```C
示例：
	//系统定时器触发1KHz的中断,中断周期时间T= 1/f = 1000ms/1000=1ms
	//系统定时器连接到PLL输出的168MHz时钟
	//只要系统定时器进行168000000次计数，就是1秒时间的到达
	//只要系统定时器进行168000次计数，就是1ms时间的到达
	//只要系统定时器进行168次计数，就是1us时间的到达	
	SysTick_Config(SystemCoreClock/1000);
```

四、最大定时时间

1.确定最大的计数值2^24 -1，若计算到0，则进行2^24次计数。

1000ms    Tmax
		-------- = -------- 
		168000000  2^24

Tmax = 2^24 *1000ms/168000000 = 99.86ms。

总结：填写中断频率值不能小于**11**，否则定时时间不准确。

SysTick_Config(SystemCoreClock/**11**);

五、延时函数

1.系统定时器的用途

- 没有操作系统：只用于延时
- 有操作系统（ucos2 ucos3 freertos....）:为操作系统提供精准的定时中断（1ms~50ms）

2.官方示例

参考文档：《Cortex M3与M4权威指南.pdf》第314页

  In many cases you might not want to use the SysTick_Config function because you might want to use the reference clock or you might not want to enable the SysTick interrupt. In these cases you need to program the SysTick registers directly,and the following sequence is recommended:

1). Disable the SysTick timer by writing 0 to SysTick->CTRL. This step is optional.It is recommended for reusable code because the SysTick could have been enabled previously.

2). Write the new reload value to SysTick->LOAD.

3). Write to the SysTick Current Value register SysTick->VAL with any value to clear the current value to 0.

4). Write to the SysTick Control and Status register SysTick->CTRL to start the SysTick timer.

参考文档：《Cortex M3与M4权威指南.pdf》第316页

  If you want to use the SysTick timer in polling mode, you can use the count flag in the SysTick Control and Status Register (SysTick->CTRL) to determine when the timer reaches zero. For example, you can create a timed delay by setting the SysTick timer to a certain value and waiting until it reaches zero:

```
SysTick->CTRL = 0; // Disable SysTick
SysTick->LOAD = 0xFF; // Count from 255 to 0 (256 cycles)
SysTick->VAL = 0; // Clear current value as well as count flag
SysTick->CTRL = 5; // Enable SysTick timer with processor clock
while ((SysTick->CTRL & 0x00010000)==0);// Wait until count flag is set
SysTick->CTRL = 0; // Disable SysTick
```

3.寄存器

![image-20240506104546092](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506104546092.png)

![image-20240506104549883](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506104549883.png)

![image-20240506104553333](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506104553333.png)



4.毫秒级延时函数

```C
void delay_ms(uint32_t ms)
{
	while(ms --)
	{
		SysTick->CTRL = 0; 			// 关闭系统定时器后才能配置寄存器
		SysTick->LOAD = 21000; 			// 设置计数值，用于设置定时的时间
		SysTick->VAL = 0; 			// 清空当前值还有计数标志位
		SysTick->CTRL = 1; 			// 使能系统定时器工作，且时钟源为系统时钟的8分频（168MHz/8=21MHz）
		while ((SysTick->CTRL & (1<<16))==0);	// 等待系统定时器计数完毕
		SysTick->CTRL = 0; 			// 关闭系统定时器	
	}
}
```

5.微秒和毫秒延时的优化[拓展]，官方代码没有想到意外关闭的问题

```C
int32_t delay_us(uint32_t nus)
{
	uint32_t temp;

	SysTick->CTRL = 0; 					
	SysTick->LOAD = (nus*21)-1; 		
	SysTick->VAL = 0; 					
	SysTick->CTRL = 1; 					
	
	while(1)
	{
	
		temp=SysTick->CTRL;
		
		//检测count flag
		if(SysTick->CTRL & 0x00010000)
			break;
		
		//检测系统定时器是否意外关闭	
		if((SysTick->CTRL & 0x1)==0)
			return -1;		
	}
	
	SysTick->CTRL = 0; 					

	return 0;
}



int32_t  delay_ms(uint32_t nms)
{
	uint32_t t = nms;

	uint32_t temp;
	
	
	while(t--)
	{
		SysTick->CTRL = 0; 			
		SysTick->LOAD = 21000-1; 	
		SysTick->VAL = 0; 			
		SysTick->CTRL = 1; 			
		while(1)
		{

			temp=SysTick->CTRL;
			
			//检测count flag
			if(SysTick->CTRL & 0x00010000)
				break;
			
			//检测系统定时器是否意外关闭	
			if((SysTick->CTRL & 0x1)==0)
				return -1;		
		}
	}	
	
	SysTick->CTRL = 0; 	
	
	return 0;
}
```

## 9 硬件定时器

一、硬件定时器

1. 定义

  设置等待时间，到达后则执行指定操作的硬件。

2. STM32F407 的定时器有以下特征

  具有基本的定时功能，也有 **PWM** 输出（灯光亮度控制、电机的转速）、脉冲捕获功能（红外捕捉）。

2 个高级控制定时器、10 个通用定时器和 2 个基本定时器：

- 高级控制定时器（TIM1 和 TIM8），挂载到**APB2**

  具有 16 位定时器功能，也具有 PWM 输出高级控制功能

- 通用定时器（TIM2 到 TIM5），挂载到**APB1**

  具有 16或32位定时功能，也具有 PWM 输出控制功能

- 通用定时器（TIM9 到 TIM14），挂载到**APB1**

  具有 16 位定时功能，也具有 PWM 输出控制功能

- 基本定时器（TIM6 和 TIM7），挂载到**APB1**

  具有 16 位定时功能。

**注：**

**1）TIM 是 TIMER 英文的缩写。**

**2）通用定时器与高级控制定时器**

![image-20240506104633932](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506104633932.png)

**二、定时计算**

1.定时器时钟频率由硬件自动设置

STM32F405xx/07xx 和 STM32F415xx/17xx 的**定时器时钟频率由硬件自动设置**。分为两种情况： **如果 APB 预分频器为 1，定时器时钟频率等于 APB 域（APB1和APB2）的频率**。 否则，**等于 APB 域（APB1和APB2）的频率的两倍 (×2)**。

2.定时器3硬件时钟

![image-20240506104701607](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506104701607.png)

3.定时500ms，关键代码编写如下	

```C
	TIM_TimeBaseStructure.TIM_Period = (10000/2)-1;			//定时时间的配置，也就是配置计数值
	TIM_TimeBaseStructure.TIM_Prescaler = 8400-1;			//配置分频值，确定定时器的时钟频率
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;	//向上计数，0->TIM_Period就会触发中断请求
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
```

**拓展1：****若定时器3的硬件时钟频率为10000Hz，最大的定时时间？**

```
1000ms     Tmax
------- = ------- 
10000      65536

Tmax = 6553.6ms = 6.5536s
```

**拓展2：**

**下图STM32F407无时钟分频。**

![image-20240506104738645](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506104738645.png)

**其他ARM平台具有时钟分频（Clock Division），如下图S3C2440 定时器硬件时钟。**

![image-20240506104747830](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506104747830.png)



**三、库函数**

1.定时器基本初始化

void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)

2.定时器中断配置

void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)

3.定时器工作使能

void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)

四、代码思路

- 使能定时器硬件时钟
- 设置定时器分频值
- 确定定时器计数值
- 使能定时器工作
- 使能定时器更新中断触发
- 配置定时器中断优先级
- 编写定时器中断服务函数

## 10 PWM

PWM（Pulse Width Modulation），脉冲宽度调制。

脉冲：方波，频率(freq)

宽度：高电平的宽度，占空比(duty)

**二、库函数**

1.GPIO引脚映射

void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)

2.定时器通道1配置

void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)

注：

通道1:TIM_OC1Init

通道2:TIM_OC2Init

通道3:TIM_OC3Init

通道4:TIM_OC4Init、

3.定时器通道1比较值

void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)

注：

通道1:TIM_SetCompare1

通道2:TIM_SetCompare2

通道3:TIM_SetCompare3

通道4:TIM_SetCompare4

**三、PWM1和PWM2模式**

《stm32f4xx中文参考手册》.pdf P477

1.定义

PWM 模式 1——只要 TIMx_CNT < TIMx_CCR1，通道 1 便为有效状态，否则为无效状态。

PWM 模式 2——只要 TIMx_CNT < TIMx_CCR1，通道 1 便为无效状态，否则为有效状态。

TIMx_CNT由TIM_TimeBaseStructure.TIM_Period决定；

TIMx_CCR1由TIM_SetComparex(x:1、2、3、4)函数决定；

有效状态由TIM_OCInitStructure.TIM_OCPolarity决定；

频率值：由计数值决定

占空比：由比较值决定

2.示例

TIM_TimeBaseStructure.TIM_Period = (10000/100)-1;		//输出脉冲的频率100Hz 		...... 

TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;		//通道工作在PWM模式1 

...... 

TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;	//有效状态为高电平 		......

TIM_SetCompare1(TIM14,20); //占空比20%



usb逻辑分析仪支持协议: SPI,IIC,UART,I2S,CAN,1-Wite,PS/2等协议，是分析通信协议的利器。

## 11 串口

串口通信是一种设备间非常常用的**串行接口，**以**比特位**的形式发送或接收数据，电子工程师经常使用这种方式来调试数据。

UART，通用异步收发器。

![image-20240506105047789](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105047789.png)

**二、库函数**

1.很多模块默认出厂的硬件参数配置如下：

配置串口，遵循“9600，N，8,1”。

波特率：9600bps

无校验位：N

数据位：8

停止位：1

对于ARM的高速芯片，波特率默认上浮到115200bps。

代码初始化思路：

**a.硬件时钟**

端口A硬件时钟使能

串口1硬件时钟使能

**b.硬件配置**

引脚配置为复用功能模式

引脚连接到串口1硬件

配置串口相关参数：波特率、校验位、数据位、停止位

配置串口中断

编写中断服务函数

**c.硬件控制**

串口1发送数据

串口1读取数据

**三、重定向printf**

1.概述

《Cortex M3与M4权威指南.pdf》章节18.1 P583

  A common task for beginners is to generate a simple output message of “Hello world!” In C language, this is commonly handled with a “printf” statement. Under the hood, the message output can be redirected to different forms of communication interfaces. Typically this is known as re-targeting. For example, it is very common to retarget printf to a UART during embedded software development.

《Cortex M3与M4权威指南.pdf》章节18.2.2 P584

  In Keil MDK-ARM (or other ARM toolchains such as DS-5 Professional), the function that needs to be implemented to support printf is “fputc.”

```
/* Short version of retarget.c - Minimum code to support simple printf in Keil
MDK-ARM */
/**************************************************************/
/* Minimum retarget functions for
ARM DS-5 Professional / Keil MDK */
/**************************************************************/
#pragma import(__use_no_semihosting_swi)
#include "stm32f4xx.h"
#include <stdio.h>

struct __FILE { int handle; /* Add whatever you need here */ };
FILE __stdout;
FILE __stdin;

int fputc(int ch, FILE *f) {
	return (ITM_SendChar(ch));
}

void _sys_exit(int return_code) {
label: goto label; /* endless loop */
}
```

2.关键分析

  pragma用于指示编译器完成一些特定的动作。

\#pragma import(__use_no_semihosting_swi)

  在嵌入式程序编译时如果出现printf、fopen、fclose等文件操作，因程序中并没有对这些函数的底层实现，使得设备运行时会进入软件中断BAEB处，这时就需要__use_no_semihosting_swi这个声明，使程序遇到这些文件操作函数时不停在此中断处。

## 12 超声波

![image-20240506105214066](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105214066.png)

VCC引脚：5V电源

TRIG引脚：触发信号引脚，单片机给超声波模块一个信号，超声波模块就会工作。

ECHO引脚：回响信号引脚，当超声波模块已经测量距离成功后，通过该引脚告诉单片机当前超声波传输的时间。

GND：信号地。

**时序图**

看时序图的技巧，从上到下，从左到右，因为一般的时序图是隐含了时间轴。

![image-20240506105233801](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105233801.png)

编写简单代码如下：

```c
int32_t sr04_get_distance(void)
{
	uint32_t t=0;
	uint32_t d=0;
	
	//1.PB6引脚输出至少10us以上的高电平
	PBout(6)=1;
	
	delay_us(20);
	
	PBout(6)=0;	

	//2.等待超声波模块测距完毕，标志性的动作就是回响信号引脚从输出低电平变为输出高电平
	//在等待过程当中，最好添加超时处理
	
	t=0;
	while(PEin(6)==0)
	{
	
		delay_us(1);
		
		t++;
		
		//超时处理
		if(t >= 1000000)
			return -1;
	}
	
	
	//3.测量PE6引脚的高电平时间，该高电平的持续时间就是超声波模块的传输时间
	
	t=0;
	while(PEin(6))
	{
		
		delay_us(9); //9us == 3mm
		t++;
		
		//超时处理
		if(t >= 1000000)
			return -2;	
	}

	//4.将时间转换为距离
	d =  t*3/2;
	
	return  d;
}


```



## 13 蓝牙2.0

AT模式与指令

![image-20240506105332442](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105332442.png)

 HC-05上电开机，红灯快闪，按住按键或EN引脚电平拉高，HC-05进入AT命令模式。退出AT模式，EN引脚电平拉低。

![image-20240506105347868](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105347868.png)

详细的蓝牙2.0的AT指令，请参考《HC05指令集》.pdf。

**四、进入/退出AT指令模式硬件连接与示例代码**

1.硬件连接：

- TXD3 -> 蓝牙2.0的RX引脚
- RXD3 -> 蓝牙2.0的TX引脚
- PE6 -> 蓝牙2.0的EN引脚
- PB6 -> 蓝牙2.0的STATE引脚（可选）

示例代码

```
void at_config(void)
{
    //PE6引脚输出高电平，即EN引脚为高电平，进入AT指令模式
	PEout(6)=1;
 
	delay_ms(500);
	delay_ms(500);
	
#if 0 //若恢复出厂配置，请打开该宏编译开关

	//串口3初始化，波特率请尝试使用为9600bps/38400bps进行测试	
	usart3_init(38400);
	
	//恢复出厂配置：蓝牙模块的波特率为38400bps、角色为从机角色、配对码"1234"等
	usart3_send_str("AT+ORGL\r\n");
	
	delay_ms(1000);	
	delay_ms(1000);	
	
#endif

	
	//串口3初始化，波特率为38400bps	
	usart3_init(38400);
	delay_ms(500);
	
	
	//配置蓝牙模块的名字,名字不能太长
	usart3_send_str("AT+NAME=TWen\r\n");
	
	delay_ms(500);
	
	//获取模块角色
	usart3_send_str("AT+ROLE?\r\n");
	
	delay_ms(500);		
	
	//获取模块的地址
	usart3_send_str("AT+ADDR?\r\n");
	
	delay_ms(500);	
	
	usart3_send_str("AT+PSWD=1234\r\n");
	
	delay_ms(500);	

	//复位模块
	usart3_send_str("AT+RESET\r\n");
	delay_ms(500);
	
	
	//PE6引脚输出低电平，即EN引脚为低电平，退出AT指令模式
	PEout(6)=0;
	
	delay_ms(1000);
 ｝
```

蓝牙2.0模块的使用大致与蓝牙4.0模块相似，不同点有以下：

- AT指令大致相同，稍有差异，使用时认真阅读数据手册。
- AT指令的进入/退出场景不同，使用时认真阅读数据手册。
- 蓝牙2.0模块在安卓手机请安装“蓝牙调试器.apk”，蓝牙4.0直接在微信小程序用“蓝牙串口”就可以了。

## 14 蓝牙4.0

AT指令模式

![image-20240506105507222](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105507222.png)

![image-20240506105515818](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105515818.png)

![image-20240506105522835](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105522835.png)

数据透传模式

![image-20240506105530246](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105530246.png)

**思考题：**通过PC转发数据给手机的时候，如何杜绝丢包的事情，有什么解决办法？

回答：

方法1：设置串口1的波特率等于串口3的波特率就可以了，缺点就是降低了串口1的波特率。

方法2：在串口1中断服务函数实现连续接收数据，接收数据完毕后才全部发送给串口3。

总结，方法2为最优的解决方案，且蓝牙模块收发一次数据包的大小不能超过20字节。

## 15 温湿度

 DATA引脚用于微处理器与DHT11之间的通讯和同步,采用**单总线数据格式,**一次通讯时间4ms左右,数据分小数部分和整数部分,具体格式在下面说明,当前小数部分用于以后扩展,现读出为零.操作流程如下:

  一次完整的数据传输为40bit,高位先出。

数据格式:8bit湿度整数数据+8bit湿度小数数据+8bit温度整数数据+8bit温度小数数据+8bit校验和。

**注：**

**何为高位先出（MSB）**呢，例如接收一个字节为0xF4，该二进制编码为 1111 0100，我们是先接收数据的数据为11110100**； **

如果低位先出(LSB)，顺序是0010 1111。

2.整个通信过程如下：

![image-20240506105642367](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105642367.png)

3.通信的开始

数据手册原图：

![image-20240506105659224](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105659224.png)

4. 数据的判断

**A. 比特0**

数据手册原图：

 ![image-20240506105716156](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105716156.png)



**B. 比特1**

数据手册原图：

![image-20240506105729262](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105729262.png)

**注意事项：**

1.如果想去跟踪温湿度代码跑到哪个位置，禁止使用串口打印输出，因为你们使用115200bps的时候，每打印一个字节都占用86us，会导致温湿度的检测超时。开发板总共有4盏LED灯，代表16种状态，因为IO口速度是100MHz，所花的时间是10ns。

2.8位校验和，假如读取到的数据30 50 88 20，分别定义两个变量来保存当前的求和。

uint8_t  check_sum_8 ; //结果溢出 

uint32_t check_sum_32; //结果是不溢出

## 15 独立看门狗

在由单片机构成的微型计算机系统中，由于单片机的工作常常会受到来自外界电磁场的干扰，造成各种寄存器和内存的数据混乱，会导致程序指针错误，不在程序区，取出错误的程序指令等，都会陷入死循环，程序的正常运行被打断，由单片机控制的系统无法继续正常工作，会造成整个系统的陷入停滞状态，发生不可预料的后果。

  **看门狗就是定期的查看芯片内部的情况，一旦发生错误就向芯片发出重启信号的电路。看门狗命令在程序的中断中拥有最高的优先级**。

看门狗电路的应用，使单片机可以在无人状态下实现连续工作，其工作原理是:看门狗芯片和单片机的一个I/O引脚相连，该I/O引脚通过程序控制它定时地往看门狗的这个引脚上送入高电平（或低电平），这一程序语句是分散地放在单片机其他控制语句中间的，一旦单片机由于干扰造成程序跑飞后而陷入某一程序段进入死循环状态时，写看门狗引脚的程序便不能被执行，这个时候，看门狗电路就会由于得不到单片机送来的信号，便在它和单片机复位引脚相连的引脚上送出一个复位信号，使单片机发生复位。即程序从程序存储器的起始位置开始执行，这样便实现了单片机的自动复位。

![image-20240506105845082](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105845082.png)

独立看门狗（IWDG）由专用低速时钟（LSI）驱动，因此即使在主时钟发生故障时仍然保持工作状态。

![image-20240506105900710](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105900710.png)

窗口看门狗（WWDG）时钟由APB1时钟经预分频后提供，通过可配置的时间窗口来检测应用程序非正常的过迟或过早的操作。

**三、时钟源**

![image-20240506105927188](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506105927188.png)

**四、程序设计**

1. **添加复位检测代码**，有助于观察当前产品工作的**可靠性**，如果看门狗复位次数过多，请检查硬件与软件是否有问题的。

```
/* 检查当前复位是否有独立看门狗导致 */
if (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET)
{
    /* IWDGRST flag set */
    printf("iwdg reset cpu\r\n");
 

}
else
{
    /* IWDGRST flag is not set */
    printf("normal reset cpu\r\n");
}
/* Clear reset flags */
RCC_ClearFlag();
```

2. 喂狗时间设置

```
/* 独立看门狗是受到保护的，现在进行解锁动作 */
IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
 
/* 设置看门狗的时钟 = 32KHz / 256 =125Hz */
IWDG_SetPrescaler(IWDG_Prescaler_256);
 
/* 设置看门狗的超时时间，也就是设置它的计数值
当前看门狗的时钟为125Hz，然后设置超时时间为1秒，那么重载值为125-1
当前看门狗的时钟为125Hz，然后设置超时时间为2秒，那么重载值为250-1
*/   
IWDG_SetReload(125-1);
 
/* Reload IWDG counter，重载独立看门狗的计数值，说白了就是喂狗 */
IWDG_ReloadCounter();
 
/* Enable IWDG (the LSI oscillator will be enabled by hardware)，使能独立看门狗 */
IWDG_Enable();
```

3. 喂狗

1）在main函数死循环里每隔500毫秒喂狗，CPU无复位

```
while(1)
{
    //刷新计数值，让计数值非0==喂狗
    IWDG_ReloadCounter();  
    delay_ms(500);
}
```

2）在main函数死循环里每隔1100毫秒不及时（超时了）喂狗，CPU复位。

```
while(1)
{
    //刷新计数值，让计数值非0==喂狗
    IWDG_ReloadCounter();  
    delay_ms(500);
    delay_ms(600);
 
}
```

3）在main函数死循环里不喂狗，CPU复位。

4. 喂狗技巧

1.在**裸机代码实现喂狗**，放在定时器里面，因为定时器与看门狗是使用不同的时钟源，允许这么做！

![image-20240506110058792](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110058792.png)

2. 如果**有实时的操作系统**的加持，可以在**任务里面添加喂狗动作**，如果操作系统崩溃了，能够检测到软件的错误，触发CPU的复位。

## 16 窗口看门狗

![image-20240506110124367](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110124367.png)

**三、程序设计**

1.检查复位状态，有助于观察当前工作的可靠性

```
	/* 检查是否窗口看门狗导致的复位，如果发现由窗口看门狗导致的复位，输出打印信息 */
	if (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) != RESET)
	{ 
		/* WWDGRST flag set */
		printf("wwdg reset cpu\r\n");

		/* Clear reset flags */
		RCC_ClearFlag();
	}
	else
	{
		/* WWDGRST flag is not set */
		printf("normal reset cpu\r\n");
	}
	
	delay_ms(500);
	delay_ms(500);


2.窗口看门狗的初始化

	/* 窗口看门狗的配置 */
	/* 使能窗口看门狗的时钟 */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);

	/* 窗口看门狗的时钟 = (PCLK1 (42MHz)/4096)/8 = 1281 Hz (~780 us)  */
	WWDG_SetPrescaler(WWDG_Prescaler_8);

	/* 	设置窗口的上限值为80 */
	WWDG_SetWindowValue(80);

	/* 设置计数值的初值为127，则窗口看门狗的最大超时时间 = 780 us * 64 = 49.92 ms 
		这个时候窗口刷新时间如下
        ~780 * (127-80) = 36.66ms < refresh window < ~780 * 64 = 49.9ms */
	WWDG_Enable(127);

	//WWDG NVIC 配置
	NVIC_InitStructure.NVIC_IRQChannel = WWDG_IRQn;			//窗口看门狗中断通道
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0;		//抢占优先级0
	NVIC_InitStructure.NVIC_IRQChannelSubPriority =0;		//子优先级0
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
	NVIC_Init(&NVIC_InitStructure);					//根据指定的参数初始化VIC寄存器	
	//清空提前唤醒中断标志位
	WWDG_ClearFlag();
	
	//使能提前唤醒中断
	WWDG_EnableIT();
```

![image-20240506110205555](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110205555.png)

```
3.看门狗中断服务函数
void WWDG_IRQHandler(void)
{
	if(WWDG_GetFlagStatus()==SET)
	{
		//进行喂狗
		WWDG_SetCounter(127);

		//清空提前唤醒中断标志位
		WWDG_ClearFlag();
	}
}
```

4.看门狗中断高级特性

《STM32F4xx中文参考手册.pdf》P500

  如果在产生实际复位之前必须执行特定的安全操作或数据记录，则可使用提前唤醒中断(EWI)。通过设置 WWDG_CFR 寄存器中的 EWI 位使能 EWI 中断。当递减计数器的值为0x40 时，将生成 EWI 中断。在复位器件之前，可以使用相应的中断服务程序 (ISR) 来触发特定操作（例如通信或数据记录）。

  在某些应用中，可以使用 EWI 中断来管理软件系统检查，而不会生成 WWDG 复位。在这种情况下，相应的中断服务程序 (ISR) 可用来重载 WWDG 计数器以避免 WWDG 复位，然后再触发所需操作。



**#思考**

  如果在while(1)循环体一直重设窗口看门狗值,系统会不会复位？

答案：会复位，因为是在窗口之外进行喂狗！



## 17 红外

 通常红外遥控为了提高抗干扰性能和降低电源消耗，红外遥控器常用载波的方式传送二进制编码，常用的载波频率为38KHz，这是由发射端所使用的455KHz晶振来决定的。在发射端要对晶振进行整数分频，分频系数一般取12，所以455KHz÷12≈37.9KHz≈38KHz。也有一些遥控系统采用36KHz、40 KHz、56 KHz等，一般由发射端晶振的振荡频率来决定。所以，通常的红外遥控器是将遥控信号（二进制脉冲码）调制在38KHz的载波上，经缓冲放大后送至红外发光二极管，转化为红外信号发射出去的。

![image-20240506110254584](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110254584.png)

 二进制脉冲码的形式有多种，其中最为常用的是PWM码（脉冲宽度调制码）和PPM码（脉冲位置调制码，脉冲串之间的时间间隔来实现信号调制）。如果要开发红外接收设备，一定要知道红外遥控器的编码方式和载波频率，我们才可以选取一体化红外接收头和制定解码方案。

现有的红外遥控包括两种方式：**PWM（脉冲宽度调制）**和**PPM（脉冲位置调制）**。

**PWM（脉冲宽度调制）**：以发射红外载波的占空比代表“0”和“1”。为了节省能量，一般情况下，**发射红外载波的时间固定，通过改变不发射载波的时间来改变占空比**。例如常用的电视遥控器，使用**NEC upd6121**，其**“0”为载波发射0.56ms，不发射0.56ms**；其**“1”为载波发射0.56ms，不发射1.68ms**；此外，为了解码的方便，还有引导码，upd6121 的**引导码为载波发射9ms，不发射4.5ms**。upd6121 总共的编码长度为108ms。

但并不是所有的编码器都是如此，比如TOSHIBA 的TC9012，其引导码为载波发射4.5ms，不发射4.5ms，其“0”为载波发射0.52ms，不发射0.52ms，其“1”为载波发射0.52ms，不发射1.04ms。

**PPM（脉冲位置调制）**：**以发射载波的位置表示“0”和“1”**。从发射载波到不发射载波为0，从不发射载波到发射载波为1。其发射载波和不发射载波的时间相同，都为0.68ms，也就是每位的时间是固定的。

红外遥控器的编码格式通常有两种格式：NEC 和RC5。

1.NEC 格式的特征：

- 使用38 kHz 载波频率
- 引导码间隔是9 ms + 4.5 ms
- 使用16 位客户代码
- 使用8 位数据代码和8 位取反的数据代码

![image-20240506110322264](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110322264.png)

红外通信的过程，反码的作用是什么？

反码的作用是用于校验，如果反码不正确，也代表说当前接收到红外数据是有问题的！

思考题2：红外接收检测使用中断检测，优点是什么？

回答： 因为接收红外脉冲的时刻是随机发生的，必须使用中断，达到实时响应，实例代码可如下：

编写中断服务函数，引脚使用下降沿触发方式，在中断服务函数当中，然后实现这个接收过程。

void 中断服务函数 (void) {    ......    ir_read(buf);   ......   }

红外接收注意事项

1. LSB和MSB

LSB（least significant bit）：最低有效位优先，例如红外通信是以最低有效位发送和接收的。 MSB（Most Significant Bit）：最高有效位优先，例如获取温湿度比特流数据的时候是以最高有效位接收的。

例子，发送0xF4(1111 0100)，采用LSB和MSB区别如下：

LSB发送的比特顺序： 0010 1111 MSB

发送的比特顺序： 1111 0100

1. 写代码思路

参考温湿度传感器DHT11的例子。

```c
 3. 参考源码
int32_t ir_read(uint8_t *pbuf)
{
	uint32_t t=0;
	int32_t i=0,j=0;
	uint8_t d=0;
	
	
	if(PAin(8))
		return -1;
		
	//检测低电平的有效性，持续9ms
	t=0;	
	while(PAin(8)==0)
	{
		t++;
		
		delay_us(10);
		
		//该超时时间必须大于9ms
		if(t > 1000)
			return -2;
	}
	
	
	//检测高电平的有效性，持续4.5ms
	t=0;
	while(PAin(8))
	{
		t++;
		
		delay_us(10);
		//该超时时间必须大于4.5ms	
		if(t > 5000)
			return -3;
	}
	
	//重复4次接收字节的过程
	for(j=0; j<4; j++)
	{
		//接收1个字节
		//低位先出,LSB
		for(i=0; i<8; i++)
		{
		
			//检测低电平的有效性，持续560us
			t=0;
			while(PAin(8)==0)
			{
				t++;
				
				delay_us(10);
				
				//该超时时间必须大于560us
				if(t > 100)
					return -4;
			}
			
			//延时600us
			delay_us(600);
			
			
			if(PAin(8))
			{
				//就将对应的bit位置1
				d|=1<<i;
				
				//等待高电平持续完毕
				t=0;
				while(PAin(8))
				{
					t++;
					
					delay_us(10);
					//该超时时间必须大于1ms		
					if(t > 200)
						return -5;
				}			
			
			}
		
		}
		
		pbuf[j]=d;
		
		d=0;	
	}
	
	//通信的结束
	delay_us(600);
	

	//判断接收数据的准确性
	if(pbuf[0]+pbuf[1]==255)
		if(pbuf[2]+pbuf[3]==255)
			return 0;
	
	return -6;
}


```



## 18 RTC

RTC就是实时时钟，详细英文 Real Time Clock。



![image-20240506110520665](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110520665.png)



![image-20240506110534803](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110534803.png)

![image-20240506110538958](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110538958.png)

供电

  当主电源 VDD 断电时，可通过 VBAT 电压为实时时钟 (RTC)、RTC 备份寄存器和备份 SRAM (BKP SRAM) 供电。

![image-20240506110550089](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110550089.png)

 程序设计

```c
rtc的初始化

void rtc_init(void)
{

	 /* Enable the PWR clock ,使能电源时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);

	/* Allow access to RTC ，允许访问RTC*/
	PWR_BackupAccessCmd(ENABLE);
	
#if 0
	/* 使能LSE*/
	RCC_LSEConfig(RCC_LSE_ON);
	
	/* 检查该LSE是否有效*/  
	while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET);

	/* 选择LSE作为RTC的硬件时钟源*/
	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
	

#else  //若LSE无法工作，可用内部LSI
	/* 使能LSI*/
	RCC_LSICmd(ENABLE);
	
	/* 检查该LSI是否有效*/  
	while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET);

	/* 选择LSI作为RTC的硬件时钟源*/
	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
	

#endif
	
	/* ck_spre(1Hz) = RTCCLK(LSE) /(uwAsynchPrediv + 1)*(uwSynchPrediv + 1)*/
	/* Enable the RTC Clock ，使能RTC时钟*/
	RCC_RTCCLKCmd(ENABLE);

	/* Wait for RTC APB registers synchronisation ，等待RTC相关寄存器就绪*/
	RTC_WaitForSynchro();
 
 #if 0 //LSE
	/* Configure the RTC data register and RTC prescaler，配置RTC数据寄存器与RTC的分频值 */
	RTC_InitStructure.RTC_AsynchPrediv = 0x7F;				//异步分频系数
	RTC_InitStructure.RTC_SynchPrediv = 0xFF;				//同步分频系数
	RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;	//24小时格式
	RTC_Init(&RTC_InitStructure);
#else //LSI
	/* Configure the RTC data register and RTC prescaler，配置RTC数据寄存器与RTC的分频值 */
	RTC_InitStructure.RTC_AsynchPrediv = 0x7F;				//异步分频系数
	RTC_InitStructure.RTC_SynchPrediv = 0xF9;				//同步分频系数
	RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;	//24小时格式
	RTC_Init(&RTC_InitStructure);

#endif

	/* Set the date: Wednesday 2017/11/29 */
	RTC_DateStructure.RTC_Year = 0x17;
	RTC_DateStructure.RTC_Month = RTC_Month_November;
	RTC_DateStructure.RTC_Date = 0x29;
	RTC_DateStructure.RTC_WeekDay = RTC_Weekday_Wednesday;
	RTC_SetDate(RTC_Format_BCD, &RTC_DateStructure);

	/* Set the time to 14h 56mn 00s PM  */
	RTC_TimeStructure.RTC_H12     = RTC_H12_PM;
	RTC_TimeStructure.RTC_Hours   = 0x14;
	RTC_TimeStructure.RTC_Minutes = 0x56;
	RTC_TimeStructure.RTC_Seconds = 0x00; 
	RTC_SetTime(RTC_Format_BCD, &RTC_TimeStructure); 
	
	//关闭唤醒功能
	RTC_WakeUpCmd(DISABLE);
	
	//为唤醒功能选择RTC配置好的时钟源
	RTC_WakeUpClockConfig(RTC_WakeUpClock_CK_SPRE_16bits);
	
	//设置唤醒计数值为自动重载，写入值默认是0
	RTC_SetWakeUpCounter(0);
	
	//清除RTC唤醒中断标志
	RTC_ClearITPendingBit(RTC_IT_WUT);
	
	//使能RTC唤醒中断
	RTC_ITConfig(RTC_IT_WUT, ENABLE);

	//使能唤醒功能
	RTC_WakeUpCmd(ENABLE);

	/* Configure EXTI Line22，配置外部中断控制线22 */
	EXTI_InitStructure.EXTI_Line = EXTI_Line22;			//当前使用外部中断控制线22
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;		//中断模式
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;		//上升沿触发中断 
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;			//使能外部中断控制线22
	EXTI_Init(&EXTI_InitStructure);
	
	NVIC_InitStructure.NVIC_IRQChannel = RTC_WKUP_IRQn;		//允许RTC唤醒中断触发
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x03;	//抢占优先级为0x3
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03;		//响应优先级为0x3
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//使能
	NVIC_Init(&NVIC_InitStructure);
}



rtc的唤醒中断服务函数

void RTC_WKUP_IRQHandler(void)
{
	if(RTC_GetITStatus(RTC_IT_WUT) != RESET)
	{
		printf("RTC_WKUP_IRQHandler\r\n");
		RTC_ClearITPendingBit(RTC_IT_WUT);
		EXTI_ClearITPendingBit(EXTI_Line22);
	} 
}


获取时间与日期

//获取时间
RTC_GetTime(RTC_Format_BCD,&RTC_TimeStructure);
printf("%02x:%02x:%02x\r\n",RTC_TimeStructure.RTC_Hours,RTC_TimeStructure.RTC_Minutes,RTC_TimeStructure.RTC_Seconds);

//获取日期
RTC_GetDate(RTC_Format_BCD,&RTC_DateStructure);
printf("20%02x/%02x/%02xWeek:%x\r\n",RTC_DateStructure.RTC_Year,RTC_DateStructure.RTC_Month,RTC_DateStructure.RTC_Date,RTC_DateStructure.RTC_WeekDay);			


改写时间与日期

/* Set the date: Wednesday 2017/11/29 */
RTC_DateStructure.RTC_Year = 0x17;
RTC_DateStructure.RTC_Month = RTC_Month_November;
RTC_DateStructure.RTC_Date = 0x29;
RTC_DateStructure.RTC_WeekDay = RTC_Weekday_Wednesday;
RTC_SetDate(RTC_Format_BCD, &RTC_DateStructure);

/* Set the time to 14h 56mn 00s PM  */
RTC_TimeStructure.RTC_H12     = RTC_H12_PM;
RTC_TimeStructure.RTC_Hours   = 0x14;
RTC_TimeStructure.RTC_Minutes = 0x56;
RTC_TimeStructure.RTC_Seconds = 0x00; 
RTC_SetTime(RTC_Format_BCD, &RTC_TimeStructure); 
```



二进制编码的十进制数，简称BCD码（Binary Coded Decimal）

这种方法是用4位二进制码的组合代表十进制数的0，1，2，3，4，5，6 ，7，8，9 十个数符。4位二进制数码有16种组合，原则上可任选其中的10种作为代码，分别代表十进制中的0，1，2，3，4，5，6，7，8，9 这十个数符。最常用的BCD码称为8421BCD码，8.4.2.1 分别是4位二进数的位取值。

![image-20240506110718135](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110718135.png)

闹钟代码

```
1.闹钟初始化

void rtc_alarm_init(void)
{
	/* 允许RTC的A闹钟触发中断 */
	RTC_ITConfig(RTC_IT_ALRA, ENABLE);
	
	/* 清空标志位 */
	RTC_ClearFlag(RTC_FLAG_ALRAF);

	/*使能外部中断控制线17的中断*/
	EXTI_ClearITPendingBit(EXTI_Line17);
	EXTI_InitStructure.EXTI_Line = EXTI_Line17;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_Init(&EXTI_InitStructure);
	
	/*使能闹钟的中断 */
	NVIC_InitStructure.NVIC_IRQChannel = RTC_Alarm_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
}


2.设定闹钟的时间

void rtc_alarm_set(RTC_AlarmTypeDef RTC_AlarmStructure)
{
	/* 关闭闹钟，若不关闭，配置闹钟触发的中断有BUG，无论怎么配置，只要到00秒，则触发中断*/
	RTC_AlarmCmd(RTC_Alarm_A, DISABLE);
	
	/* 配置RTC的A闹钟，注：RTC的闹钟有两个，分别为闹钟A与闹钟B */
	RTC_SetAlarm(RTC_Format_BCD, RTC_Alarm_A, &RTC_AlarmStructure);
	
	/* 让RTC的闹钟A工作*/
	RTC_AlarmCmd(RTC_Alarm_A, ENABLE);
}
```

示例：

```
RTC_AlarmTypeDef RTC_AlarmStructure;

int main(void)
{
    ......
  
#if 1  
     //闹钟每天生效
    RTC_AlarmStructure.RTC_AlarmMask = RTC_AlarmMask_DateWeekDay;
    rtc_alarm_set(RTC_AlarmStructure); 
#endif
 
#if 0           
    //闹钟指定20号生效
 	 RTC_AlarmStructure.RTC_AlarmDateWeekDay = 0x20;				//20号
	 RTC_AlarmStructure.RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;	//指定哪一天生效
	 RTC_AlarmStructure.RTC_AlarmMask = RTC_AlarmMask_None;				//不屏蔽哪一天和星期的配置   
     rtc_alarm_set(RTC_AlarmStructure);
     #endif
#if 0      
    //闹钟指定星期三
	 RTC_AlarmStructure.RTC_AlarmDateWeekDay = RTC_Weekday_Wednesday;		//星期三
	 RTC_AlarmStructure.RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_WeekDay;//指定星期几生效
	 RTC_AlarmStructure.RTC_AlarmMask = RTC_AlarmMask_None;				//不屏蔽哪一天和星期的配置   
     rtc_alarm_set(RTC_AlarmStructure);
#endif
     
     ...... 
}
```

3. 闹钟相关参数详细分析

1） RTC_AlarmTime：闹钟时间设置，配置的是 RTC时间初始化结构体，主要配置小时的制式，有 12小时或者是 24 小时，配套具体的时、分、秒。 

2） RTC_AlarmMask：闹钟掩码字段选择，即选择闹钟时间哪些字段无效，取值可为：

- RTC_AlarmMask_None(全部有效)

- RTC_AlarmMask_DateWeekDay（日期或者星期无效）

- RTC_AlarmMask_Hours（小时无效）

- RTC_AlarmMask_Minutes（分钟无效）

- RTC_AlarmMask_Seconds（秒钟无效

- RTC_AlarmMask_All（全部无效）。

  比如我们选择 RTC_AlarmMask_DateWeekDay，那么就是当 RTC 的时间的小时等于闹钟时间小时字段时，每天的这个小时都会产生闹钟中断。

3） RTC_AlarmDateWeekDaySel ： 闹 钟 日 期 或 者 星 期 选 择 ， 可 选 择RTC_AlarmDateWeekDaySel_WeekDay 或者 RTC_AlarmDateWeekDaySel_Date。要想这个配置有效，则 RTC_AlarmMask 不能配置为 RTC_AlarmMask_DateWeekDay，否则会被 MASK掉。

4） RTC_AlarmDateWeekDay：具体的日期或者星期几，当 RTC_AlarmDateWeekDaySel 设置成 RTC_AlarmDateWeekDaySel_WeekDay时，取值为 1~7，对应星期一~星期日，当设置成 RTC_AlarmMask_DateWeekDay时，取值为 1~31。



1.为了防止每次复位重置RTC时间，可以利用RTC自带的备份寄存器来实现。步骤如下：

- 初始化RTC时间的时候，接着去设置RTC备份寄存器的值。
- 复位的时候，去读取RTC备份寄存器的值，判断是否跟之前的值是否一致，若一致，则执行普通的时钟、电源、中断初始化。

2.备份寄存器细节，STM32中文参考手册 P604，有以下描述

//用于建立重启标志，是否需要重置RTC的时间

 RTC_WriteBackupRegister(RTC_BKP_DR0,0x5678);

  **当** **VDD 关闭时，这些寄存器由 VBAT 供电，因而系统复位时，这些寄存器不会复位，并且当器件在低功耗模式下工作时，寄存器的内容仍然有效。**

## 19 FLASH

闪存（Flash Memory）是一种长寿命的非易失性（在断电情况下仍能保持所存储的数据信息）的存储器。用途SD卡、固态硬盘、芯片内存存储单元存储代码。

![image-20240506110856289](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110856289.png)

**二、内部FLASH**

![image-20240506110923598](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110923598.png)

![image-20240506110927821](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110927821.png)

![image-20240506110933061](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110933061.png)

字节：8位 

半字：16位 

字：32位 

双字：64位 

uint32_t i; 

uint64_t i;  

word i; 

dword i;

**三、编程细节**

以分区形式进行规划，配置数据最好从最后扇区进行操作，防止覆盖扇区0的代码。

![image-20240506110948354](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506110948354.png)

2.写入数据之前得先擦除数据，类似与读书时的黑板原理。

思考题1：擦除完之后，扇区里面所有的数据是什么？

答：所有的数据都是为0xFF，所有bit位都是1

思考题2：假如说现在已经擦除完扇区，先写入了1个字，然后在**下一个偏移地址**再次写入新的字是否在需要擦除扇区？

答案：不需要的。

思考题3：假如说现在已经擦除完扇区，先写了1个字，然后在**同一个地址**再次写入新的字是否需要擦除扇区？

答案：需要进行擦除！

**总结：**

  判断是否允许写入字，只需要判断当前的地址存储的数据是否为0xFFFFFFFF，若为0xFFFFFFFF，可以写入数据，不需要进行扇区擦除。

## 20 ADC

ADC，Analog-to-Digital Converter的缩写，指模/数转换器或者模数转换器。是指将**连续变化的模拟信号转换为离散的数字信号的器件**。真实世界的模拟信号，例如温度、压力、声音或者图像等，需要转换成更容易储存、处理和发射的数字形式。模/数转换器可以实现这个功能，在各种不同的产品中都可以找到它的身影。

模拟信号，就是数值上是连续的，就是数值的数量是无限多。

数字信号，就是数值是不连续的，就是数值的数量是有限的。

![image-20240506111035496](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111035496.png)

![image-20240506111052450](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111052450.png)

  12位精度：3300mv/4096=0.8mv，也就是说只要电压值有±0.8mv的变化，adc才能分辨出来。

  10位精度：3300mv/1024=3.22mv，也就是说只要电压值有±3.22mv的变化，adc才能分辨出来。

  8位精度：3300mv/256=12mv，也就是说只要电压值有±12mv的变化，adc才能分辨出来。

  6位精度：3300mv/64=51.5625mv，也就是说只要电压值有±51.5625mv的变化，adc才能分辨出来。

**注意事项：**

1. 如何知道当前是使用哪个ADC硬件，同时使用哪个通道？

答：PA5/ADC12_IN5，表示PA5引脚支持ADC1或ADC2进行扫描，使用通道是第五个输入通道

存储对齐方式

![image-20240506111131946](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111131946.png)

![image-20240228205312243](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240228205312243.png)

## 21 DAC

![image-20240506111202074](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111202074.png)

![image-20240506111211329](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111211329.png)

 为了让数据更加平滑，可以采用中值平均滤波算法。如果最后得到的结果还是有一点的偏差，就得自我数据补偿，纠正并接近实际值，以下代码是求平均值并加上数据补偿的例子：

```
for(sum=0,i=0; i<1000; i++)
{
	//等待ADC1转换结束
	while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);
	ADC_ClearFlag(ADC1,ADC_FLAG_EOC);


	//读取转换结果
	adc_val = ADC_GetConversionValue(ADC1);


	//将结果值转换为电压值
	adc_vol = adc_val * 3300 /4095;	
 
	sum+=adc_vol;

}

adc_vol = sum/1000;

//adc_vol减去10就是一个数据补偿,纠正并接近实际值
adc_vol -=10;

printf("adc vol = %dmv\r\n",adc_vol);
```



## 22 SPI

SPI，serial peripheral interface，是串行外设接口。是一种高速（10Mbps），全双工，同步的通信总线，只有4根线。

![image-20240506111251193](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111251193.png)



**单机通信**

![image-20240506111257860](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111257860.png)

**多机通信**

![image-20240506111306883](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111306883.png)

**三、工作模式**

 SPI总线有四种工作方式，其中使用的最为广泛的是**模式0**和**模式3**方式。

CPOL(Clock Polarity)：**时钟极性选择**，**为0时SPI总线空闲时，时钟线为低电平** ；**为1时SPI总线空闲时，时钟线为高电平**。

CPHA(Clock Phase)：**时钟相位选择**，**为0时在SCLK第一个跳变沿，主机对MISO引脚电平采样**；**为1时在SCLK第二个跳变沿，主机对MISO引脚电平采样**。

![image-20240506111330814](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111330814.png)

![image-20240506111334676](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111334676.png)

![image-20240506111338068](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111338068.png)

![image-20240506111341355](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111341355.png)



全双工通信：发送数据的时候，能够接受数据；接受数据的时候，能够发送数据。如SPI。

半双工通信：发送数据的时候，不能接受数据；接受数据的时候，不能发送数据。如RS485。

同步通信：发送数据的时候，必须同时接收到数据。如SPI

异步通信：发送数据的时候，可以接受数据也可不接受数据。如串口UART

**时序图**

![image-20240506111406615](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111406615.png)

**参考源码**

```
uint16_t w25qxx_read_id(void)
{
	uint16_t id=0;

	//片选引脚拉低
	W25QXX_SS=0;
	
	//发送0x90
	SPI1_SendByte(0x90);

	//发送24bit的地址，全为0
	SPI1_SendByte(0x00);
	SPI1_SendByte(0x00);
	SPI1_SendByte(0x00);
	
	//读取厂商id，参数可以为任意参数
	id = SPI1_SendByte(0xFF)<<8;
	
	//读取设备id
	id|= SPI1_SendByte(0xFF);

	//片选引脚拉高	
	W25QXX_SS=1;
	
	return id;
}
```



**模拟SPI**

在有些情况下没有硬件SPI的支持，只能通过IO口来模拟SPI时序图

**7.1 模式0**

```
void w25qxx_init(void)
{
	
	//使能端口B的硬件时钟
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);	
	
	//配置端口B PB3 PB5 PB14为输出模式
	GPIO_InitStruct.GPIO_Pin=GPIO_Pin_3|GPIO_Pin_5|GPIO_Pin_14;	//第3 5 14个引脚
	GPIO_InitStruct.GPIO_Mode=GPIO_Mode_OUT;		//输出模
	GPIO_InitStruct.GPIO_Speed=GPIO_High_Speed;		//引脚高速工作，收到指令立即工作；缺点：功耗高
	GPIO_InitStruct.GPIO_OType=GPIO_OType_PP;		//增加输出电流的能力
	GPIO_InitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;	//不需要上下拉电阻
	GPIO_Init(GPIOB,&GPIO_InitStruct);
	
	
	//配置端口B PB4为输入模式
	GPIO_InitStruct.GPIO_Pin=GPIO_Pin_4;		//第4个引脚
	GPIO_InitStruct.GPIO_Mode=GPIO_Mode_IN;		//输出模式
	GPIO_InitStruct.GPIO_Speed=GPIO_High_Speed;	//引脚高速工作，收到指令立即工作；缺点：功耗高
	GPIO_InitStruct.GPIO_OType=GPIO_OType_PP;	//增加输出电流的能力
	GPIO_InitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;	//不需要上下拉电阻
	GPIO_Init(GPIOB,&GPIO_InitStruct);
	
	//【*】看时序图，只要是输出模式，初始状态要输出对应的电平
	PBout(14)=1;	//SS引脚
	PBout(3)=0;     //SCLK引脚
	PBout(5)=1;	//MOSI引脚，随意，因为时序图没有告诉实际上的电平，模式0~模式3没有描述MOSI引脚相关
}

uint8_t SPI1_SendByte(uint8_t byte)
{
	int32_t i=0;
	uint8_t d=0;
	
	for(i=7; i>=0; i--)
	{
		//MSB，最高有效位发送数据
		if(byte & (1<<i))
			W25QXX_MOSI =1;
		else
			W25QXX_MOSI =0;
   
		//设置SCLK引脚为高电平,告诉从机，我开始采集MISO引脚电平
		W25QXX_SCLK=1;
		delay_us(2);	
  
 		//主机采集MISO引脚电平
		if(W25QXX_MISO)
			d|=1<<i; 
   		
		//设置SCLK引脚为低电平，这个时候，从机会开始读取MOSI引脚电平
		W25QXX_SCLK=0;
		delay_us(2);
	}
	return d;
}
```



**7.2 模式3**

```
void w25qxx_init(void)
{
	
	//使能端口B的硬件时钟
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);	
	
	//配置端口B PB3 PB5 PB14为输出模式
	GPIO_InitStruct.GPIO_Pin=GPIO_Pin_3|GPIO_Pin_5|GPIO_Pin_14;	//第3 5 14个引脚
	GPIO_InitStruct.GPIO_Mode=GPIO_Mode_OUT;		//输出模
	GPIO_InitStruct.GPIO_Speed=GPIO_High_Speed;		//引脚高速工作，收到指令立即工作；缺点：功耗高
	GPIO_InitStruct.GPIO_OType=GPIO_OType_PP;		//增加输出电流的能力
	GPIO_InitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;	//不需要上下拉电阻
	GPIO_Init(GPIOB,&GPIO_InitStruct);
	
	
	//配置端口B PB4为输入模式
	GPIO_InitStruct.GPIO_Pin=GPIO_Pin_4;		//第4个引脚
	GPIO_InitStruct.GPIO_Mode=GPIO_Mode_IN;		//输出模式
	GPIO_InitStruct.GPIO_Speed=GPIO_High_Speed;	//引脚高速工作，收到指令立即工作；缺点：功耗高
	GPIO_InitStruct.GPIO_OType=GPIO_OType_PP;	//增加输出电流的能力
	GPIO_InitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;	//不需要上下拉电阻
	GPIO_Init(GPIOB,&GPIO_InitStruct);
	
	//【*】看时序图，只要是输出模式，初始状态要输出对应的电平
	PBout(14)=1;	//SS引脚
	PBout(3)=1;     //SCLK引脚
	PBout(5)=1;	//MOSI引脚，随意，因为时序图没有告诉实际上的电平，模式0~模式3没有描述MOSI引脚相关
}

uint8_t SPI1_SendByte(uint8_t byte)
{
	int32_t i=0;
	uint8_t d=0;
	
	for(i=7; i>=0; i--)
	{
		//MSB，最高有效位发送数据
		if(byte & (1<<i))
			W25QXX_MOSI =1;
		else
			W25QXX_MOSI =0;
		
		//设置SCLK引脚为低电平，这个时候，从机会开始读取MOSI引脚电平
		W25QXX_SCLK=0;
		delay_us(2);
		
		//设置SCLK引脚为高电平,告诉从机，主机准备采集MISO电平
		W25QXX_SCLK=1;
		delay_us(2);
  	
           //主机采集MISO引脚电平
		if(W25QXX_MISO)
			d |= 1<<i; 
	}
	return d;
}
```





## I2C

![image-20240506111524994](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111524994.png)

![image-20240506111532112](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111532112.png)

![image-20240506111535299](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111535299.png)

IIC，inter-intergrated circuit，集成电路总线，一般两根信号线：

一根是双向的数据线SDA，另一根是时钟线SCL。

总线的运行（数据传输）由主机控制。所谓主机是指启动数据的传送、发出时钟信号以及传送结束是发出的停止信号的设备。每个接到I2C总线的设备都有一个唯一大的地址。

![image-20240506111548766](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111548766.png)



I2C通信，存在几种信号

1）起始信号（条件）：通知从机做好通信的准备。

2）应答信号：有应答和无应答。有应答是低电平，无应答是高电平。

3）停止信号（条件）：告诉从机通信已经结束。

- 起始和停止条件

![image-20240506111603128](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111603128.png)

SCL高电平时SDA下降沿是起始信号

SCL高电平时SDA上升沿是停止信号

- 数据传输格式

当SCL为高电平时,便会获取SDA数据值,其中SDA数据必须是稳定的

![image-20240506111645338](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111645338.png)

- 应答信号

![image-20240506111637145](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111637145.png)

I2C总线上的数据都是以**8位数据(字节)**进行的，当发送了8个数据后，发送方会在**第9个时钟脉冲期间释放SDA数据**，**当接收方接收该字节成功**，便会输出一个ACK应答信号，当SDA为高电平,表示为非应答信号NACK，**当SDA为低电平，表示为有效应答信号ACK**

页编程：

![image-20240506111615385](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111615385.png)

（四）连续读

![image-20240506111629336](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240506111629336.png)