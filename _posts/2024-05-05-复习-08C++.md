---
layout: post
title: 复习-08C++
author: jevon xiong
tags:
- blog
- 复习
- C++
date: 2024-05-05 22:00 +0800
toc: true
---
# 复习-08C++



## 01

### 什么是C++ ？ ？

```c++
C 语言中有 一个 运输符   ++  
int  i=0;     i++;   //i 的数据就增加了。 
C语言    ->  C++  所有就是 在 	C 的基础上进行 ++  （增加），所以C++ 中兼容所有的C 语言语法！！ 
```

回顾C 语言的知识点： 

```c++
1.数据类型    （作用：存储基本数据）   char,short,int,float .....
2.运算符      （作用：把基本的数据类型进行运算）   +  -  *  /    && ||  ...... 
3.控制流      （作用：设计程序的逻辑）    if，for,while,switch   .....  
-------------------------------
4.数组        （作用：存储多个数据类型相同的数据）  char  buf[100] , short  buf[100]....
5.指针        （作用：存放内存地址）
-------------------------------
6.函数         （作用：封装代码，让程序模块化）
7.组合数据类型   （作用：让用户自己定义新的类型）    （结构体，共用体，枚举..）
8.宏定义        （作用：增强代码的可读性和移植性）  
```

### 复习内存：

![image-20240503225441326](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240503225441326.png)

### C++ 在C 的基础上增加的内容

```c++
1.命名空间   ： 作用 解决变量名冲突的问题 
2.输入输出   ： 作用 c++ 开发者觉得printf ，scanf 不好用，就重载了 cout,cin  
3.引用      :  作用 解决临时空间的分配问题，节省内存空间
4.函数重载   ： 作用 提高代码的复用性，使一个函数拥有多种功能   
5.类（封装，继承，多态）  ： 作用  整个c++语言的核心！！ 面向对象设计的思想基础         
6.友元      ： 提高代码的访问权限。
7.运算符重载 ： 提高代码的复用性 
8.模板（函数模板，类模板）      ：提高代码的服用性
9.STL库（容器，队列，栈，链表，树） :C++ 官方提供的标准数据结构接口 （给那些对数据结构不熟悉的同学福利！！ ）   
10.异常处理 ： 进行代码语句的检查，提高代码的健壮性！！ 
---------------------------------------------------------
 通过上述的知识点分析： 最多的特性是什么 ？？？      
  提高代码的复用性 ！！！  为什么要提高复用性？？  因为 !懒!!!!!让开发的过程中少些一些代码，提高工作效率。有更多的时间摸鱼 ！！      
```

-----------------------------------

### 第一个 c ++ 代码

提示：   gcc  编译器， 编译c语言代码，不能编译 c++ 代码.  c语言的后缀名    xxx.c  

g++ 编译器，编译C语言和c++ 代码。 c++ 语言的后缀名    xxx.cpp    



![image-20210621111644353](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210621111644353.png)

### c++ 中的输入与输出

```c++
cout : 标准输出   -> printf
cin  : 标准输入   -> scanf  
cerr ：标准出错   -> perror  
endl : 换行 ,刷新缓存区     -> '\n'
-----------------------------------------------
这些接口在使用的时候，需要在前添加  std:: ，因为所有的输入输出接口都在 STD 库中 
使用： std::cout    
      std::cin  
      std::endl  
      std::cerr  

-------------------------------------------------------------
输入数据 cin  等价于scanf   
语法： 
std::cin  >>  变量名
例子：
    int a=0; 
    std::cin >> a; 


特点！！c++ 的标准输入输出都不需要🤔考虑数据的类型，使用起来更加方便！ 
```

### cout  输出的注意事项：

```c++
 	 int  a=10086;  
     char b='A'; 
     float c=3.14; 
     char buf[1024]="hello";     

    //输出数据的地址与内容
    std::cout << &a << ":"  << a << std::endl; 
    std::cout << (void *)&b << ":"  << b << std::endl; 
    std::cout << &c << ":"  << c << std::endl; 
    std::cout << &buf << ":"  << buf << std::endl; 

    //因为 输入输出 有自动类型推导的功能 
    /*&a  -> 推导为   int * 
      &b  -> 推导为   char *    -> 字符串 -> %s 输出，错误的原因
      //因为把 &b 的地址当作是一个字符串去处理了，
      &c  -> 推导为   float * 
      &buf ->推导为   char ** 

      因为char  buf[100] -> buf  类型推导为 char * -> 字符串  

      在c++ 的输入与输出中，遇到 char *他就认为是字符串。 
    */
```

结论：**当c++自动推导出来的类型，不满足用户的需求时，用户需要把类型进行强制转为需要的类型**。 

### 命名空间

作用：解决开发过程中变量名冲突的问题  

![image-20210621152808350](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210621152808350.png)

### 命名空间的定义语法：

```c++
用户声明的名字空间定义以关键字 namespace 开头 后面是名字空间的名字
    
空间名 :与变量的命名规则相同，只能由数字字母下划线组成，数字不能开头。 
    
//定义 
namespace 空间名 
{
    在该空间中的变量，函数,.........  
};

//例子：定义一个命名空间，里面包含变量 a b c  
namespace  XM
{
     int a;
     int b;
    int  c;
};
```

### 命名空间的成员使用

```c++
1.通过域操作符  :: 引用空间中的内容   
    空间名::变量名
例子： XM::a   
      XM::b  
      XM::c 

2.通过using 把整个空间暴露出来  
    using namespace  空间名  
    
例子:  
using namespace  XM;
提示：可以使用这种方式把 std 的空间暴露出来，后面使用 cout ,cin,endl,cerr 就不需要添加 std:: 


3.只暴露空间中的某一成员   
   using  空间名::成员名  
例子： using  XM::a;   //在暴露XM 空间中的 a 成员 
```

### 命名空间的嵌套定义

```c++
语法: 
namespace 空间名1
{
    
    namespace  空间名2 
    { 
         //继续不断的定义 
         .....   
    }   
}
----------------------------------------
例子： 
    namespace  TX
	{
    	  namespace  TX1
          {
              namespace  TX2
              {
                   int  a=10086;  
              }  
          }
	}
使用空间中的成员: 
  1:利用域操作符号引用空间中的成员 
      TX::TX1::TX2::a  
  2.暴露  
     using namespace  TX;  
 	using namespace  TX1;
 	using namespace  TX2;
  3.暴露某一个成员 
      using   TX::TX1::TX2::a;
```

## 02

### 匿名空间

 作用： 限制全局变量只能在当前文件中使用   

​		     提示：功能与静态全局变量类似   

回顾静态的特点： 

```c++
静态局部变量： 
1.只能被初始化一次  
2.会改变静态变量的生命周期，存放到数据段中   
    
静态全局变量：
1.只能在当前文件中使用该全局变量 
```

### 匿名空间的定义

```c++
namespace    //不写空间的名称他就是一个匿名空间 
{
   //填写空间中的成员 ， 变量，函数,类 .......   
}

例子： 定义一个匿名空间把全局变量限制在本文件中使用  
namespace 
{
    int a=100; 
    float b=3.14;  
}


```

### 命名空间的跨文件使用

```c++
1.把命名空间定义出来  
namespace  TX
{
     int  a=10086;
}
2.在使用该空间中的文件进行声明 
namespace  TX
{
     extern  a;  //声明该空间中的变量a 是在外部定义的 
}
```

### C 和 C++ 的混合编程

```c++
当c++ 程序使用 C 语言接口使用需要声明为外部 C 接口      
extern  "C"
{
     //添加 使用到的C 语言接口头文件
    
}

//extern  "C"  在这里面的内容都采用 gcc 编译器进行编译不使用 g++  
```

### 计算机中的内存划分

![image-20210622141135165](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210622141135165.png)

### 回顾c 语言分配动态内存空间（堆空间）的方式

```c++
     #include <stdlib.h>

       void *malloc(size_t size); //分配大小为size 的堆空间
       void free(void *ptr);//通过堆空间的首地址释放该空间 

       void *calloc(size_t nmemb, size_t size);//分配 nmemb * size 大小的堆空间 
       void *realloc(void *ptr, size_t size);//把ptr 的堆空间改变大小为size  
       void *reallocarray(void *ptr, size_t nmemb, size_t size);
             //把ptr 的堆空间改变大小为size*nmemb  
```

### c++ 中的动态内存分配

**c++中用 new 分配堆空间 delete 释放**   

### 语法：分配一块堆空间

```c++
数据类型 *变量名  =  new  数据类型; // -> 分配一块内存空间 

例子：分配一块int 类型的堆空间 
    int *p =  new int;//一条龙服务！！自己计算空间的大小，自己进行类型的转换！！  

    int *q =  new  int(10086);  //支持在分配空间的时候对堆空间进行初始化！！ 


释放堆空间：  
delete  变量名 
 
例子： 
delete  p; 
delete  q; 
```

### 语法：分配多块堆空间

```c++
数据类型  *变量名  = new  数据类型[size];    ->size用户需要分配多少块这样的堆空间 
    
例子： 分配100 块int 类型的堆空间 
int *p =  new  int[100];  

例子： 分配多块堆空间并初始化，只初始化了前面5个  
int   *q  =  new  int[20]{1,2,3,4,5}; 
 
释放多块堆空间： 
    delete  []变量名;
    
例子： 
    delete  []p;  
```



例子：利用new  去分配一个二维数组 

![image-20210622153508317](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210622153508317.png)

```c++
int main()
{
    //该数组的类型是什么 ？？？   
   // int  a[10][10];  
    int (*p)[10] =  new  int[10][10]; 

   //对二维数组进行赋值  
   int x=0,y=0; 
    for(y=0;y<10;y++)
    for(x=0;x<10;x++)
    {
        p[y][x]  =  x+y;
    }
    
    //输出 
    for(y=0;y<10;y++)
    for(x=0;x<10;x++)
    {
         cout <<  p[y][x]  << endl;
    }

      //释放 
    delete  []p;
}
```

### 总结new 与 malloc 的区别

```c++
1.new 可以自动计算数据类型的大小 与 类型的转换   malloc 只能手动进行。  
2.new 可以在分配空间的时候初始化   malloc 不行  
    
最重要的特点！！！！  
    3.在分配类的堆空间时， 使用new会调用<<类中的构造函数>>   malloc 不行。 
    
所以在c++开发中分配堆空间，都采用 new 的方式即可！！ 
```

### c++ 中的引用

**引用：给已知的变量取一个别名，内存不会再为该引用分配新的内存空间，节省内存空间！！**

![image-20210622160628308](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210622160628308.png)



### 引用的定义语法：

```c++
数据类型  &引用名   =  引用的变量名; 

例子： 
int  a=100; 
//对变量a 取一个别名  
int  &q=a;     //a 与  q 是完全等价的！！  


有什么好处？？？  
    这样传递参数的过程中就不会分配新的变量空间！！ 节省空间！！ 
    
引用的使用场合！！！  
     一般都是用来作为参数传递，让函数直接访问数据的本身，节省临时空间的产生！！ 
```

## 03

### 常量引用

作用： 1.防止引用名，去修改原来数据的值。

​			 2.对数据常量进行引用  

语法： 

```c++
const  数据类型 &引用名=引用的对象； 
    
例子： 
  int a=10086;  

   //定义常量引用 
    const  int &p=a;  //特点：别名p 无法修改a的值


   //对一个常量进行引用  
    const  int  &q=1000;
```



### 引用作为函数的参数

引用作为函数的参数，用户不需要修改该数据时，那么我们就可以传递常量引用！  

例子： 

```c++
//常量引用作为函数参数的特性
int  add(const int &a,const int &b)
{
    return a+b;  //并未修改ab 的数据，只是访问 
}

int main()
{
        int a=10,b=20;  
        cout << add(a,b)  << endl;  //可以传递变量  

        cout << add(100,200)  << endl; //也可以传递常量
}

```

补充： 常量引用的特殊写法 

```c++
数据类型  &&引用名;

int  &&a=100;   //常量应用  

这种写法只能引用常量， 不能引用变量！！ 
```

### 引用作为函数的返回值

**注意！！！！当引用作为返回值时，必须要保证函数结束后该空间还是存在的！！**

![image-20210623110949123](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210623110949123.png)

引用作为返回值时一般返回：  

```c++
静态变量，全局变量，堆空间，（传递的参数引用）... 

不会被释放的空间！！ 
```

当一个引用作为返回时，该函数可以作为左值

![image-20210623141738456](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210623141738456.png)

```c++
例子： 
//返回一个引用,a的本身 
int  &re_yy()
{
    static  int a=200;
    return  a;
}

//re_yy() 作为右值
int b  = re_yy();  //理解  b = a;

//re_yy() 作为左值 
re_yy()  =  300;  //理解  a = 300;  成立！！   
```

### 引用的注意事项：

```c++
1.引用必须要初始化  （因为引用就是取别名，取别名的对象都没有，哪里来的别名？）
2.引用一个常量时，需要使用const  常量引用 或者   && 右值引用 
3.引用的类型必须要匹配     
```

类型匹配图： 

![image-20210623144357773](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210623144357773.png)

```
4.当引用被初始化后就无法再次修改。 
```

### c ++ 中的多态

   ![image-20210623151741686](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210623151741686.png)

优点：设计一个接口可以实现多种不同的功能！！  

-----------------------------

静态多态：  程序在**编译**的时候，已经确定将要执行状态。 

动态多态： 程序在**运行**的时候，才能确定将要执行的状态。

提示：c++ 中的函数重载就属于静态多态！！

### c++ 中的函数重载

```c++
1.用相同的函数名定义不同的功能称为函数重载。
2.重载的函数根据参数的个数和类型进行区分。
3.不能根据返回类型进行区分：
```

### c++ 函数重载的原理

```c++
1.c++ 编译器在编译的时候会 《自动检查》，用户编写的函数， 《参数列表》 根据参数列表的不同对函数名进行别名化，来产生多个名称不一样的函数.
    
2.根据用户传入的 《参数》 来自动推导类型，去确定要执行的函数。 

int pf(int a)   //1.编译器自动别名化    pf_int(int a); 
{
    cout << "打印一个整形数据"  << a << endl; 
    return 0;
}

int pf(char a) //1.编译器自动别名化   pf_char(char a) 
{
    cout << "打印一个字符数据" << a << endl; 
    return 0;
}

int main()
{
    //一个pf 函数拥有两种不同的功能      
pf(100); //2.根据传入的参数不同，自动推导调用的函数  100 ->int->pf_int(int a); 
pf('A');//2.根据传入的参数不同，自动推导调用的函数'A'->char->pf_char(char a) ; 
}
//都是c++ 编译器自动去完成的！！不需要用户干预！！ 
```

### 函数重载注意事项

```c++
1.函数重载时函数名 必须一样 
2.函数重载的依据  <参数个数>  <参数类型>  不一样！ 
3.返回值类型不能作为重载的依据！！ 
4.调用重载的函数时要防止 《歧义》 的产生    
```

![image-20210623163055151](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210623163055151.png)

### 函数的默认参数

默认参数： 在c++ 中定义函数的时候，可以使用默认参数进行形参的赋值。 

```c++
例子：
int pf(int a=100)
{
    cout << a << endl;
} //为形参a添加一个默认参数为 100  
```

默认参数作用： 简化函数的调用！！ 

### 默认参数的填写顺序

![image-20210623163709270](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210623163709270.png)

提示：调用函数的时候参数传递的顺序是 从 左 到 右  

```c++
pf(10,20);  -> 10 传递给  a | 20 传递给  b 
```

-------------------

### 使用默认参数简化函数的调用例子

```c++
#include <iostream>
using  namespace std;

extern "C"
{
    #include <sys/mman.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
}

//映射一个设备 , 利用默认参数封装mmap 是他的调用更加简单 
void *my_mmap(int fd,size_t length,int prot=PROT_READ|PROT_WRITE,int flags=MAP_SHARED,void *addr=NULL,off_t offset=0)
{
    return  mmap(addr,length,prot,flags,fd,offset);
}


int main()
{
      
    //打开一个文件 
    int  fd=open("1.txt",O_RDWR);
         if(fd < 0)
         {
             cerr << "打开文件失败" << endl;
             return 0;
         }
   
    //映射文件 
    void *p=my_mmap(fd,1024);  //现在调用mmap就简单了很多！！  

    void *p1=my_mmap(fd,1024,PROT_READ);  //只读权限  

    void *p2=my_mmap(fd,1024,PROT_READ,MAP_SHARED_VALIDATE);

        //调用映射函数的方法就丰富了很多！！ 
}
```

## 04

### c++ 中的面向对象编程

面向对象 与 面向过程 是两种编写代码的思维！  

假设需要制作一个电子相册的项目

面向过程： 

```c++
1.打开LCD 设备 
2.对LCD 设备进行映射 
3.打开图片文件 
4.读取图片文件数据
5.把图片文件的数据放到映射地址中  
6.打开触摸屏设备 
7.获取触摸屏的坐标点 
8.判断坐标点来实现图片的切换  
    
面向过程的设计思维 ： 数据 + 算法  = 程序。 
思考项目的实现时，是一步一步的思考的。 
```



面向对象： 

```c++
电子相册 -》功能： 图片显示   触摸屏控制 
    

把图片显示抽象为一个     图片管理器对象  
把触摸屏控制抽象为一个   触摸屏管理器对象

分析每个对象中应该有什么功能 
图片管理器对象 应该要有  
1.LCD 的初始化接口  
2.图片显示的接口  
3.图片资源的释放接口 
    
触摸屏管理器对象 应该要有  
1.触摸屏的初始化
2.触摸屏位置获取接口
3.触摸屏位置判断接口
4.触摸屏文件关闭接口
    
思考完这些接口后，就开始编写这个对象，当对象编写完毕后我们的程序就完成了。     
    
面向对象 ：  对象+消息+对象  = 程序 
           
            消息（两个对象之间的数据交互接口）
  
```

**面向对象简单的理解就是把 程序代码写入到对象中 （类）！**  

之前面向过程写程序 ，add.c, show.c...... 不断的设计过程的c 文件  

现在面向对象的方式去写程序，class  add 类， class show 类型 ,把代码写入到一个类中



### c++ 中的类

### 类的三大特性 （封装，继承，多态）

​        封装： 1.把功能函数接口封装到类里面   

​					 2.把数据成员封装到类里面    

​						 《简单的理解，把所有代码都写入到类中》 

------------------------

​	继承：儿子从爸爸里面继承一些东西过来。 （子类继承父类的函数接口或数据） 

​	优点：子类直接继承父类的接口函数，不需要重新开发这些接口，提高代码的复用性，有利于软件版本的升级。 

------------

多态： 一个对象作用于不同的事物，所得到的结果（功能）不一样！！   

多态的优点： 提高代码的复用性  

面向对象的编写优点： 

1.代码容易修改与维护  （因为每个对象都是独立的，需要修改对象的内容即可）

2.提高代码的复用性      （继承，多态，函数重载，默认参数 ）->ps 少写一些代码

3.能够更好的设计复杂的程序  （因为很多的一些第三方开源库，都是利用c++ 去设计的，假设我们想要用这些开发库，那么必须掌握c++语言。 ）

### c++ 中类的定义

回顾C 语言中的结构体： 

```c++
struct  结构体名称
{
    成员列表;
}
```

c++ 中类的定义： 

```c++
class 类名
{
    成员列表;
}

这种是最简单的定义方式，但是这样定义出来的类，是没有任何意义的，因为类中的所有成员都是私有成员，外界是无法访问的！ 
```

### 一般类的定义方式

```c++
class 类名 
{
   public:   //共有成员，外界可以访问  
    
   protected:  //保护成员，只有儿子可以访问
    
   private: //私有成员，只有当前类内部可以访问
        
};

//定义一个类的例子： 
class base
{
    public:
        int a; //外界可以访问，因为是共有成员 
    protected: 
         int b;  //子类可以访问，因为保护成员 
    private: 
         int c;  //只有类的内部可以访问 ,因为是私有成员
};
```

### c++ 类中的构造函数

```c++
构造函数： 1.函数名与类名相同，
         2.函数没有返回值， 
         3.函数不需要用户调用，在创建对象的时候自动调用
```

构造函数作用： 用于在定义对象的时候，初始化对象中的数据成员。 

构造函数的语法： 

```c++
class  类名
{
     public:
  	类名()   //构造函数
    {
        
    }   
}
例子： 
    class base
    {
        public: 
         base()
         {
             cout << "调用构造函数" << endl;
         }
    }
```

**注意： 构造函数必须要写在公共区**，因为在创建对象的时候会自动该函数，假设不是功能区的函数，则无法掉，导致对象的创建失败 。

**注意：假设用户没有写任何的构造函数**，则系统会自动生成一个无参构造函数。 

-------------

**提示：1.构造函数也支持函数重载**

​			**2.构造函数也支持默认参数**

-------------------------------

### this 指针

this 指针的作用：用来区分类的内部与外部成员。 

每当用户创建一个类时，这个类就会自动生成一个 this 指针，指向当前类的首地址！！ 

```c++
   base(int a,int b,int c)
     {
         //this->a  当前类-》a 成员
          this->a=a;
          this->b=b;
          this->c=c;
     }
//不使用  this 指针那么  a ,b ,c 变量的名字要重新修改！！ 
```

### malloc 与  new  的区别

```c++
class  base
{
public: 
     base(int a){
         cout << "调用based的构造函数" << endl;
         this->a = a;
     }
    void show_base()
    {
        cout << a << endl; 
    }
private: 
int a;
};

int main()
{
   
      //利用malloc 分配base 的堆空间 
    base *p = (base *)malloc(sizeof(base));   //不会调用base 的构造函数的
                                             //导致类中的数据成员无法初始化 

    p->show_base();  
    base *q =  new  base(10086); //可以调用构造函数去初始化类中的成员  
     //提示：假设对象是一个指针  则用  -> 
     q->show_base(); 

}
```

malloc函数分配类的堆空间，不会调用类的构造函数，会导致一些初始化错误

### 析构函数

```c++
析构函数：1.函数名与类名相同在函数名前面添加~， 
        2.析构函数没有返回值，《没有参数》
        3.当对象销毁的时候系统自动调用（析构函数可以释放成员空间）
```

析构函数的作用： 用于释放构造函数中初始化的数据成员。 

**注意：析构函数是不可以重载的**，因为重载的依据是参数！

​		   **析构函数也需要编写到公共区中**，因为对象销毁时自动调用。 

析构函数应用原理图！！ 

![image-20210624164833658](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210624164833658.png)

------

交叉编译  ！！ 

arm-linux-g++ myopen.cpp   -o main   

 （在虚拟机中对编写好的代码进行编译，下载到开发板中运行即可）

## 05

### 类中的大小计算

字节对齐原则： 

![image-20210625104556601](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210625104556601.png)

回顾结构体的大小计算

```c++
struct  node 
{
    char a;
    int  b;
    short c;
    double d;    
}   //在64位的操作系统中计算该结构体的大小   -》 24

总结：结构体的空间大小是根据字节对齐原则的，在32位与64位系统中对齐原则是不一样的。 具体的对齐原则请看上述表格。  
```

### 类中的空间大小分配与结构体一样

```c++
//当前类中 最大的字节是 int  所以按照4字节对齐原则 
class  base
{
     char  a;  //分配4个 char使用 1个剩下 3 个
     short b;  //剩下的3个可以提供2个给 short  去使用 所以剩下1 个
     int   c;  //重新分配 4 个空间
}; //->8  

class  base1
{
    char  a; //分配4个 
    int   c; //分配4个
    short b; //分配4个
}; //根据 4 自己对齐原则  -》 12 
```

结论： **在设计类的数据成员时，应该把数据类型，从小到大排序的去定义，这样定义出来的类，所占用的内存空间最小。**  

### 类中的大小与成员属性关系

![image-20210625110649686](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210625110649686.png)

### 类中的大小与成员函数的关系

```c++
class  base2
{
public:
     void func() //在没有调用 func 的时候，b,c 的空间是不会分配
     {           //b 和 c 根本都不属于 base2类的空间中
           int  b;//func 里面的局部变量 ，局部变量是临时存在的
           int  c;
     }
int a;
};  //12 

```

**结论：类中的空间大小，只于类中的数据成员有关，与类中的成员函数无关。** 

**提示： 空类的大小为1** 

### 构造函数的参数列表初始化

作用： 在构造函数中一种特殊的初始化方式，用于初始化类中的数据成员。

![image-20210625141802374](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210625141802374.png)

**提示：这种初始化方式并不是万能的**，如果数据类型不支持 =号赋值就不能用该方法，例如：数组

### 拷贝构造函数 （重点，难点）

### 系统自动生成的浅拷贝方法：

```c++
#include  <iostream> 
using namespace std; 
class  base
{
public: 
   //设计一个构造函数 
   base(int a,int b):a(a),b(b){}
void show()
{
     cout << a << endl;
     cout << b << endl;
}
private:
int a; 
int b;
};
int main()
{
         base  a(10,20);
         a.show();

         //通过一个对象去初始化另外一个人对象 
         base b=a;  //系统会自动生成一个浅拷贝构造函数，把a对象的数据赋值给b对象
         b.show(); 

}
```

**浅拷贝 -》 直接赋值** 

![image-20210625150924458](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210625150924458.png)

### 重写系统的拷贝构造函数

当在构造函数中传递的参数是类的引用时，那么这个构造函数就是重写后的拷贝构造函数 

语法： 

```c++
class  类名 
{
  public:  
    类名(类名 &a)   //重写后的拷贝构造函数 ，
    {
        
    }    
}
提示：当用户重写拷贝构造函数后，系统就不会自动生成一个浅拷贝构造方法 
--------------------------------------------------------------
 例子： 
class  base
{
    public: 
    base(base &a)
    {
        cout <<  "重写后的拷贝构造函数" << endl; 
    }
} 
```

![image-20210625152002028](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210625152002028.png)

### 深拷贝

###  为什么需要深拷贝？？

![image-20210625155034146](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210625155034146.png)

### 重写拷贝构造函数，实现深拷贝

自己在课下尝试去解决这种 “三角恋“ ！！！

```c++
class  base
{
public:
base(const char *str)
{
        //分配p所指向的堆空间 
        p  =  new  char[1024]; 
        //把str数据赋值到堆空间中 
        strcpy(p,str);  
}

//重写拷贝构造函数,实现深拷贝！！！！！
base(base &a)
{
    cout << "调用重写后的拷贝构造函数，实现深拷贝" << endl; 
     //分配p所指向的堆空间  
     p= new  char[1024];  
     //把a空间中的数据拷贝过来  
     strcpy(p,a.p);
}

 void  show()
 {
     cout << "堆空间的地址" << (void *)p << "内容" << p << endl; 
 }
char *p;
};
```



### 类外定义类中的成员函数

语法： 

```c++
函数的返回值   类名::函数的名称(参数列表)
{
    
}
-------------------------------------------
例子： 
class base
{
   public: 
    void show(); //声明 
}; 

//类外定义show 接口
void   base::show()
{
    cout << "show base" << endl; 
}
```

练习： 类外编写下列接口   

```c++
struct  node 
{
    int date; 
    struct  node  *next;
}

class  base
{
    public: 
    base(int size,const char *str);
    base(base &a); //深拷贝函数 
    ~base();
    
    void show();  
    
private: 
    int size; 
    char *p; //指向一块堆空间
    struct  node *list;  //指向一个头节点 
}


```



## 06

### 类的继承

作用： 1.提高代码的复用性    2.有利于软件版本的升级

什么是继承？？ 

继承：从父类中获取一些功能接口或 数据成员，如果该成员是共有或保护成员则子类可以直接访问，提高代码的复用性。 

![image-20240503230626915](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240503230626915.png)

-------------------

继承不能随便继承，一定要符合事物的逻辑。  

### 继承的语法

```c++
class  类名: 继承方式  基类名（父类名）
{
    //填写派生类的成员 （子类的成员） 
}

//定义一个 person基类 
class  person
{  
 private: 
 char  name[1024]; 
 int  age;  
 int  height;
}; 

//通过基类派生出一个警察类 
class JC:public person
{
  
    //新增警察的信息 
private: 
    int  power; //警察力量 
    int  level; //级别
};
//当前这个警察就拥有所有 人的基本 信息 和自己的新增信息了 。
```



### 类继承成员属性的访问权限

![image-20210628142602611](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210628142602611.png)

```c++
class  base
{
public:
int a; 
void set_base(int a,int b,int c) //没有问题，内部可以访问一切成员
{
    this->a = a;
    this->b = b;
    this->c = c;
}
protected:
int b;
private:
int c;
};


class  new_base :public base
{

public: 
void  set_new_base(int a,int b,int c)
{
     this->a = a;
     this->b = b;
   //  this->c = c;  错误的，私有成员只能内部访问 
}
};

void set_base(int a,int b,int c)
{
        base  tmp; 
       tmp.a = a;
     //  tmp.b = b;  错误的，保护成员只能 子类 或 自身访问 
     //  tmp.c = c;  错误的, 私有成员只能 自己访问。 
}
```

### 总结：

```c++
假设想要在派生类中，直接访问基类的数据成员，那么基类的数据成员只能 设置为共有权限  或 保护权限。 

假设想要在派生类中，访问基类的私有成员，只能在基类中设计接口，让派生类间接访问。  
```



### 利用参数列表，初始化父类的私有成员

![image-20210628151759449](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210628151759449.png)



### 继承中的构造函数与析构函数

```c++
基类和派生类的构造函数都会执行： 
   构造函数的执行顺序： 先调用基类的构造函数，再调用派生类的构造函数  
   
基类和派生类的析构函数都会执行:
   析构函数的执行顺序: 先调派生类的析构函数，再调用基类的析构函数. 
       
总结： 在类的继承中，一定要处理好这些 基类 与派生类的构造函数 与析构函数。   
      让派生类可以调用到 自己的构造 与 基类的构造。否则无法创建对象！ 
```

### 总结共继承的权限问题

![image-20210628171538282](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210628171538282.png)

```c++
1.公共继承中，派生类可以访问   父类中的保护和共有成员  
2.公共继承中，类外可以访问， 父类中的共有成员，子类中的共有成员。 
```

## 07

### 不同的继承方式权限问题

 继承方式：  public （共有继承）  protected (保护继承)   private（私有继承）



### 不同的继承方式规律

```c++
1.不同继承方式不会影响到子类对父类的访问权限。     子类 可以访问父类的   共有  和  保护。 

2.不同的继承方式，只会影响到类外的访问权限。       类外  只能访问基类中的《共有继承》的《共有成员》。
    
3.不同的继承方式就相等于把基类放到派生类那个区。   
```

![image-20240503230759033](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240503230759033.png)

### 继承方式的总结：

```c++
1.假设用户想类外访问，基类的共有成员，那么就是用  《共有继承》
2.假设在多级继承中，想要子类的子类访问，基类的保护 或 共有成员，则使用  《保护继承》  
3.假设在多级继承中，不想子类的子类访问，基类的数据成员， 则使用  《私有继承》
```

![image-20210629111737558](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210629111737558.png)

在日常开发工作中：一般都是采用  共有继承，因为访问权限最高！！ 

---------------------------------------------

### 类中的隐藏问题

隐藏： 1.在继承中，如果子类与父类出现同名函数，则子类会把父类的功能函数给隐藏掉。

​		     2.假设想要在子类中是用父类被隐藏掉的接口，  是用  域操作符 指定是用父类接口 

​                  a.base::show();  

​             3.派生类中，只要编写了一个与父类同名的函数就会把父类的方法给隐藏了，《不支持 重载》

​					就是不支持跨类重载。

​             4.通过父类引用  派生类  也可以调用父类的方法。 base &=new_base   //通过父类引用子类

```c++
class  base
{
 public: 
   void show()
   {
         cout <<  "show base" << endl; 
   }
};
//基类 和 派生类出现了同名函数成员。
class  new_base :public base
{
 public:  
  void  show(int a,int b)  //对父类的show 方法进行重载 
  {    
         cout << a << endl; 
         cout << b << endl; 
  }
};
int main()
{
     new_base  a; 
     a.show(); //调用父类的 show 方法 ,无效的调用。因为父类的方法已经被隐藏了
     a.show(10,20); //调用自己的 show 方法 
     //利用域操作符 ，声明是用父类的方法  
     a.base::show(); 

}
```



### 类中的多继承

一个派生类可以继承多个基类， 获取多个基类的功能接口和数据成员，提高代码的复用性。 

语法： 

```c++
class 派生类 :继承方式 基类 ,继承方式 基类2  ........
{
    
}
例子： 
class base : public  base1 ,public  base2 
 			
 构造函数的执行顺序： base1 -> base2 -> base 
 析构函数的执行顺序:  base -> base2 -> base1 
    
//提示： 哪一个先继承，那么就先执行他的构造 ，从左 -》 右
```

多继承的参数列表初始化： 

```c++
class base_a
{
public:
base_a(int a):a(a){}
int a;
};

class base_b
{
public:
base_b(int b):b(b){}
int b;
};

class base_all:public base_a ,public  base_b
{
public:
   base_all(int a,int b,int c):base_a(a),base_b(b),c(c){}
int c;

  void show()
  {
      cout << a << endl;
      cout << b << endl; 
      cout << c << endl;
  }
};
```



### 类中多级继承

语法： 

```c++
class 基类名  
class 派生类 :继承方式 基类名 
class 派派生类 : 继承方式  派生类 

例子： 
class  base 
class  base_a :public base 
class  base_b :public base_a

构造函数的执行顺序：  base  -> base_a  ->  base_b 
析构函数的执行顺序:  base_b -> base_a ->   base  
    
    
```

多级继承的参数列表初始化： 

![image-20210629160846820](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210629160846820.png)





两种继承方式的框架图： 

![image-20210629154116692](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210629154116692.png)

### 菱形继承

![image-20210629165429343](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210629165429343.png)

菱形继承会出现一个二义性问题,导致派生类无法调用，基类的所有功能函数！！ 



### 菱形继承的二义性解决方式：

```c++
1.利用 域操作符，指定使用哪一个基类中的函数方法 
      a.base_a::show(); 
      a.base_b::show(); 
2.利用 基类引用派生类，再调用出现二义性的方法  
       base_a &q=a; 
	   base_b &q=a; 

3.在派生类中重写出现二义性的方法，把之前的隐藏掉。  
    
4.最强的处理方法： 利用虚继承，让base 的空间存放在虚表中，不构造两次！！ 
base: 
base_a :virtual  public  base     //-> base_a 虚继承base -》 系统就会把 base 放到虚表中
base_b :virtual  public  base    //->base_b 虚继承base -> base_b 发现虚表已经存在base了就直接使用不再分配。 
```

![image-20240503230829967](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240503230829967.png)



## 08

### 虚函数

```c++
语法： 
virtual 函数返回类型 函数名（参数表） {函数体}；
    
例子：定义虚函数 
virtual  void func()
{
    
    
}
//定义了一个虚函数，系统就会产生一个虚表。  
```

结论： 

```c++
1.当类中含有一个虚函数时，系统就会自动分配一个虚表指针（*vptr），指向系统的虚表
2.用户定义的所有虚函数都在该虚表中。 
3.虚表的地址，永远都在对象空间的最前面。
    
4.重点，重点，重点！！ 《子类会把父类的虚表也继承下来，子类与父类公用一个虚表》   （实现动态多态的条件！！）
```



### c++ 中的覆盖

回顾隐藏： 子类 与 父类拥有一个同名函数，子类就会把父类的功能接口给隐藏掉。 

​					假设要是用  父类接口 

```
  new_base  a; 
   base &q=a;    //通过对父类进行引用，再调用他的接口。 
   q.func();  //show_base    
```



**当基类拥有一个虚函数，并在派生类中，对该虚函数进行了重写。 这种就是覆盖！！**

覆盖的代码例子： 

```c++
#include <iostream>
using namespace std; 

class  base
{
public: 
int a; 
virtual void func()   //声明了一个虚函数 
{
    cout << "show_base" << endl; 
}
};

class  new_base :public  base
{
public: 
void func()
{
    cout << "show_new_base" << endl; 
}
};

int main()
{
   //cout  << sizeof(new_base) << endl;  //16  证明子类把父类的虚表也继承下来了 
    new_base  a; 
    a.show();  //show_new_base 

   //通过基类把 派生隐藏的接口显示出来 
     base &q=a; 
     q.show();  //show_base  
}
```

为什么可以覆盖？？ 

![image-20210630112022152](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210630112022152.png)



覆盖的条件： 

```c++
1.基类必须要有虚函数 
2.派生类必须要重写基类的虚函数 
3.通过基类 的指针  或 引用，指向派生类，并调用重写的方法。     
    
只有满足上述三个条件才会出现这种覆盖现象。 
```



### 多态

什么是多态？？  

​     一个对象，作用于不同的事物，所以得到的结果不一样。  （得到状态不一样）

​          《 一个函数可以实现多种不同的功能！！！》

作用：  提高代码的复用性。  

--------------------

**静态多态** : 在程序 《编译》的时候，已经确定将要执行的状态。   -》函数重载 

**动态多态**：在程序 《运行》的时候，才能确定执行的状态。 根据用户传递不同的对象，执行不同的状态。 



### 动态多态的实现条件：

```c++
1.基类要有虚函数
2.继承
3.派生类重写基类的虚函数 
4.把派生类的对象，赋值给基类的  指针  或 引用  ，通过基类调用被重写的接口. 
```

编写动态多态的案例： 

```c++
//定义一个人  
class person
{
public: 
  virtual void work()  //设置为 虚拟的工作方式,不明确，所以是虚拟的 
  {
      cout << "这个人我们不知道它能干嘛" << endl; 
  }
};


//把这些人的工作内容实例化 
class JC:public person
{
 public: 
     void work()
     {
         cout <<  "去抓小偷"  << endl; 
     }
};

class  HS:public person
{
    public: 
    void work()
    {
        cout << "去做核酸检测" << endl;
    }
};

class  CS:public person
{
public: 
    void work()
    {
        cout << "上秋名山!!" << endl;
    }

};

//设计一个工作的接口 
void  do_work(person *q)
{
     //这个人去工作了 
     q->work();
}




//一个 do_work 的接口 -》作用不同的事物 -> 得到的结果不一样。 

int main()
{

     //调用工作的函数  
    do_work(new person);
    do_work(new JC);
    do_work(new HS);
    do_work(new CS);
   
}
```

### 虚析构

![image-20210630151949760](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210630151949760.png)

因为通过基类指针去释放派生类的堆空间，系统是无法调用派生类的析构函数的。 

所以就有可能造成派生类构造函数中初始化的一些数据成员未被释放。造成资源的浪费！！ 

虚析构的语法： 

```c++
virtual ~析构函数{}  

例子： 
 virtual ~new_base(){} 
```

使用例子： 

```c++
#include <iostream>

using namespace std; 
class  base
{
public: 
  base(){cout << "执行base的构造函数" << endl;}
  virtual ~base(){cout << "执行base的析构函数" << endl;}
};

class  new_base:public  base
{
   public: 
  new_base(){cout << "执行new_base的构造函数" << endl;
    p  = new char[1024]; 
    cout << "分配一块1024的堆空间"  << (void *)p << endl;
  
  }
 virtual ~new_base(){cout << "执行new_base的析构函数" << endl;
   cout << "释放分配的堆空间"  << (void *)p << endl;
   delete p;
  } 
  private: 
  char *p;
};

int main()
{
      //通过基类指针，指向派生类的对象 
      base *p = new new_base; 
     //通过基类的指针释放派生类的对象空间 
     delete p; 
}
```

总结： 析构函数不管是否应用到多态技术，最好都把他设置为虚析构。 万无一失！



### 纯虚函数 与 抽象类

```c++
纯虚函数的定义： 
virtual 函数返回类型 函数名（参数表） =0；
例子： 
virtual  void  func()=0;     //纯虚函数 
 
抽象类：      如果一个类中的有纯虚函数那么这个类就是抽象类
抽象类的特点： 抽象类不能实例化 （定义对象）
```

![image-20210630155250017](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210630155250017.png)

提示： 假设派生类，没有对纯虚函数进行实例化，那么这个类还是抽象类。 



抽象类的作用： 

```c++
设计代码的预留框架接口，让派生类去实现。 
```



抽象类的应用案例 ： 

假设我们想要开一家饮品店,  饮品店制作各种各样饮品 .  但是需要制作 什么饮料还不 知道，但是制作的过程大概知道。  把整个制作的过程给抽象出来。 

1.加水  -> 2.加辅料  ->3.搅拌   -> 4.打包售卖    ,这些过程先抽象出来。 

进行实例化： 

假设制作咖啡 ：  1.加入热水 -> 2.加入咖啡豆  -> 3. 咖啡机进行搅拌  -> 4.装杯卖 18块钱 。 

假设制珍珠奶茶 ：  1.加入牛奶 -> 2.加入珍珠  -> 3. 手摇  -> 4.装杯卖 8块钱 。 ****



## 09

### c++ 中的友元

回顾c++ 中类的访问权限： 

```c++
class  base
{
public:   //共有成员，类内，子类，类外，都可以访问
int a;
protected:  //保护成员,类内，子类可以访问 
int b; 
private: //私有成员，类内可以访问
int c;
};
```



### 友元

作用： 用于访问类中的所有数据成员。  

缺点： 破坏类的封装性，所以万得已，不要随便是用友元。 



### 友元函数

声明友元函数的语法： 

```c++
friend 函数的返回值类型  函数名(参数列表)
    
例子： 
friend  void  show()  //该函数就可以访问声明他的类中的所有成员 
{
    
}   
```

1.当一个函数被声明为该类的友元函数时，该函数就不属于类中的成员函数！！ 

2.友元函数必须要在类内，声明！ 

3.友元函数可以在类中的任意地方声明， 与成员权限无关。 

![image-20210701101248837](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210701101248837.png)

友元实现的例子： 

```c++
class  base{
public: 
int a;
protected: 
int b; 
private: 
int c;
 //声明 show 函数是该类的一个友元函数 
friend void show();  //属于base 中的成员函数吗？？不属于 
};

//base 类的一个友元函数
void show(){
    base a; 
    a.a = 100;  //只能访问共有成员 
    a.b = 200; 
    a.c = 300;
    cout << a.a << endl; 
    cout << a.b << endl; 
    cout << a.c << endl; 
}
```



### 友元函数可以继承吗？

```c++
class  base
{
private: 
int a;
//声明一个 set 友元函数
friend void set();
};

class  new_base:public base
{
private:
int b;
    //声明一个 set 友元函数
friend void set();
};

void set()
{
      base a; 
      a.a = 1000;   //可以访问私有 成员
      cout << a.a << endl;

      new_base  b;
      b.b = 2000;   //不可以访问 new_base 的私有成员。 
}


```

 1.友元函数是不可以继承的。 ！！
 2.假设需要友元函数可以访问，子类的私有成员，则需要在子类中再次声明该函数为友元函数

多个类可以对应一个友元函数吗？？   可以的！！ 

一个类可以对应多个友元函数吗？？  可以的！！

------------

### 友元类

作用： 当一个类为 另外一个类的友类，则该类可以访问对方的一切数据成员。 

```c++
语法: 

friend  class 类名 
    
例子： 
friend  class base; 
```

![image-20210701110307646](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210701110307646.png)

练习： 让两个类互为友元。 ！！ 

```c++
class test{
public: 
  //单纯声明一个接口
 void set_base();
private: 
int c;
//声明 base  是 test 的友元 
friend  class base;
};

class  base{
public: 
//访问 test 中的私有成员
void set_test(){
    test  a; 
    a.c = 100;
}
private: 
int c;
//声明test 是base 的友元 
friend class  test;
};

//重点！！重点！！在base 定义后 才实现  set_base 接口 
void test::set_base()
{
      base  a; 
      a.c = 200;
}
```



### 运算符重载

作用： 给已知的运算符赋予新的功能

以往所学习的运算符只能进行基本的数据类型运算符，无法实现  两个字符串的相加 ， 两个类的相加，两个结构体的相加。 这时候我们就可以利用 c++ 新增的运算符重载的方法赋予运算符新的功能实现这些数据的运算。



运算符重载的语法： 

```c++
返回类型说明符 operator 运算符符号(<参数表>)
    
    
例如：重载两个 base 类相加的运算符   
    base operator+(base a)
   {
    
    
   }
    
    
```



### 重置base的加法运算符 demo ：

![image-20210701142027632](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210701142027632.png)



### 可重载运算符：

```c++
1，那些运算能重载
双目运算符  （+，-，*，/， %）     operator+ 
关系运算符 （==， !=, <,  >, <=, >=）
逻辑运算符 (||,   &&,  !)
单目运算符 (*， &， ++， --)
位运算符   （|，  &，  ~， ^,  <<, >>）
赋值运算符 (=, +=, -=,   .....)
空间申请运算符 (new , delete)
其他运算符 ((),  ->,  [])
    
2，那些运算符不能重载
.(成员访问运算符)
.*(成员指针访问运算符)
::(域运算符)
sizeof(数据类型长度运算符)
?:(条件运算符， 三目运算符)

```

### 运算符重载的两种方式

```c++
类内重载方式：  
    base  operator+(参数列表)  
调用规律： 
   base c = a+b;  -> a.operator+(b)   等价于这种调用方式。 
   特点： a是调用者，  b是参数。 因为是在类的内部重载所以有 this 指针 
       
       
类外重载方式：  
       base  operator+(base a,base b) 
       调用规律： 
       base c=a+b;  ->   operator+(a,b)  等价于这种调用方式。单纯的函数调用
        特点： a和 b 都是 operator+ 函数里面的参数，所以不可以使用 this 
```

**总结： 这两种重载运算符的方式都是一样的，选择哪一种重载方式，根据用户的需要选择即可。** 



### 不同运算符重载的方式

###   关系运算符  

```c++
class base
{
public: 
base(int a):a(a){}
private: 
int a;
friend bool   operator>(base a,base b);
};

//类外重载
bool   operator>(base a,base b)
{
    if(a.a > b.a)
    {
        return true;
    }else{
        return  false;
    }
}

int main()
{

   base a(100); 
   base b(20); 

   if(a > b)
   {
       cout << "a > b" << endl;
   }else{
       cout << "a<b"  << endl;
   }
}
 
//练习： 重载  <   == 运算符  
```

### 逻辑运算符

```c++
class base
{
public: 
base(int a):a(a){}

bool  operator&&(base b)
{
    if(this->a && b.a)
    {
        return true;
    }else
    {
        return false;
    } 
}

private: 
int a;
};
```

### 单目运算符

```c++
class base
{
public:
int a;
base(int a):a(a){}

//++a  先自加，再用值
base operator++()  
{
    cout << "调用++a"  << endl;
    this->a++;  //先自加 
    return *this; //再返回值 
}
//a++  先用值，再自加
base  operator++(int)
{
    cout << "调用a++"  << endl;
    base tmp=*this; //保存原来的值 
    this->a++;

    return tmp;  //先返回值 
}
};
int main()
{
     base a(0);  
     base b=a++;  //先用值，再自加

        cout << b.a << endl; 
        cout << a.a << endl; 
}
```



### 利用位运算符 << ， >> 实现输入输出的重载



### 输出运算符的重载

![image-20210701162315033](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210701162315033.png)



完美重载输出运算符的 demo  

```c++
class  base
{
public: 
base(int a):a(a){}
private:
int a;
friend ostream &operator<<(ostream &out,base a);
};
//类外重载方式
ostream &operator<<(ostream &out,base a)
{
    cout << a.a;

    return out;
}
int main()
{
  
      base a(10086); 
      base b(10010); 
      cout  << a << b << endl;
}
```

### 输入运算符的重载

```c++
class  base{
public:  
base(){}
base(int a):a(a){}
int a;
};
//类外重载输入运算符 
istream &  operator>>(istream &in,base &a)
{
     cin >> a.a;
     return in;
}

int main()
{

     base  a;
     base  b;

     cin  >> a >> b; 

     cout << a.a << endl;
     cout << b.a << endl;

}
```



###  字符串类的使用

![image-20210701165246431](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210701165246431.png)

所有字符串的操作都可以使用string 类去处理。 

-------------

### 构造函数

```c++
  string();
  string( size_type length, char ch );  //以length为长度的ch的拷贝（即length个ch）
  string( const char *str );//以str为初值 (长度任意), 
  string( const char *str, size_type length );//把str 中的 length 个字符串赋值到该类中
  string( string &str, size_type index, size_type length );//以index为索引开始的子串，长度为length
```



string 重载后的运算符： 

![image-20210701170022124](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210701170022124.png)



### 其他接口说明：

```c++
data 
语法: 
  const char *data();    
data()函数返回指向自己的第一个字符的指针.  
    //例如调用c 的 write 接口  
    
//删除字符串
erase( size_type index = 0, size_type num = npos );    
   // 从index 的位置开始 删除 num 个字符串
        
        
//字符串查找 
size_type find( const char *str, size_type index );
  //从index位置开始查找 str 字符串，返回找到的位置
        
//插入字符串 
 basic_string &insert( size_type index, const char *str );
 //从index 的位置 插入str 字符串 


长度(length)
语法: 
  size_type length();
length()函数返回字符串的长度. 这个数字应该和size()返回的数字相同


//字符串替换 
basic_string &replace( size_type index, size_type num, const basic_string &str );
//从index 位置 替换为 str 替换  num
    
```



作业：自己设计一个 mystring 类，实现与 string 类相同的功能

```c++
#include  <iostream>
#include  <string.h>
#include  <stdio.h>

using namespace std;  
class mystring
{
 public:   
   mystring(){} 
   mystring(mystring &s)
   {
       
   }

   mystring(const char *str)
   {
      
   }
   

//开始重载运算符  
mystring operator+(mystring &str) 
{
   
}


//重新赋值运算符，实现深拷贝 
mystring operator=(mystring &str) 
{

   
}

char  operator[](int a)
{
   

}

  //设计长度的接口 
   int length()
   {
       
   }

   ~mystring(){}

//重载输出接口 
friend ostream & operator <<(ostream &out,mystring &a);
private:
char *str; 
};

ostream & operator <<(ostream &out,mystring &a)
{

}

int main()
{
    mystring  a("123456"); 
    mystring  b("qwerty");  

}

//要求实现：3个以上的运算符重载 ，3个以上的功能函数。 
```

## 10

### 什么是模板

​      模板就是做好的一个样式，用户直接去套用就可以快速实现功能。 

​      模板是不能够直接使用，必须要实例化才能用。

![image-20240503231229756](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240503231229756.png)

-----------------

### c++ 中的模板

函数模板，模板类 ： 作用   提高代码的复用性！！ 



例如：现在要求同学们编写一个  jiaohuan 交换函数， 实现 （字符型，整形，浮点型，字符串类型，的数据交换）  实现上述功能函数 。 应用函数重载的技术，自己编写 4 个重载函数 ， 

   开发人员就发现，这个函数的功能和参数个数，都是一样的。只是类不一样。那么能否设计一个通用类型出来？？  -》  函数模板！！ 



函数模板： 拥有一个通用类型的函数。 

通用类型的定义语法： 

```c++
template<typename 通用类型> 或 template<class 通用类型>
    
//例子：声明一个带有通用类型的函数  
template<class T>   
void  show(T a)
{
    
}  //声明了一个模板函数，带有一个通用类型T 
    
T  的类型，系统会自动根据用户传入的参数来推导出他的类型。 
```



模板函数的设计案例： 

```c++
template <class T>
void jiaohuan(T &a,T &b)
{
    T c = a; 
      a = b; 
      b = c;
}

int main()
{

   int a=10,b=20; 
   jiaohuan(a,b);
   cout << a << ":"  << b << endl;

   float a1=3.14,b1=4.44; 
   jiaohuan(a1,b1);
   cout << a1 << ":"  << b1 << endl;

   string  a2="hello",b2 ="world"; 
    jiaohuan(a2,b2);
   cout << a2 << ":"  << b2 << endl;
}
```

**总结：模板最重要的特点就是会自动推导数据的类型！！！**



### 模板函数与普通函数区别

 *普通函数调用，可以发生自动类型转换 

​                            自动类型转换    从精度 底的数据 往  精度高的数据进行转换  

​													 char  -> short ->  int  -> float  -> double  

*模板函数调用，没有**自动类型转换**，只会发生**自动类型推导**。 

```c++
template <class  T>  //定义了一个通用类型T  
T add(T  a,T b)
{
    return a+b;
}

 int main()
 {
     int a=10;
     short b=20; 
     cout << add(a,b) << endl;
     // add(a,b)  发生自动类型推导  -》 第一次推导，T=int  ，第二推导  T=short 
     // 无法确定 通用类型  T 是哪一种类型，所以就无调用该模板。 
 }

```

解决方式：   

```c++
1. 限定模板的T 的数据类型。
      add<int>(a,b)   -》 把通用类型T 设置为 int ,系统就不需进行自动推导
    
2. 再定义一个通用类型，让函数推导成功  
    //定义一个模板函数，拥有两个通用类型 
template <class  T,class T1>
T add(T  a,T1 b)
{
    return a+b;
}
    
//成功发生推导    add(T,T1)  ->  add(int,short)
```

练习： 定义一个函数模板实现三个不同数据类型的相加。 int  ,short ,float 



### 模板函数与普通函数的调用规则

1.当模板函数 与 普通函数 实现的功能相同时，优先调用普通函数。  

2.假设用户不想调用普通函数，那么怎么做？？ 利用 <>  指定是用模板。 

3.当模板函数比普通函数，更好匹配参数时，那么编译器，就会优先调用模板函数。

​    （c++的编译器是很智能的！！）

4.模板函数也支持重载。 



### 模板函数的局限性

  对于用户自定义的数据类型，模板函数是无法对数据进行操作的。  

如果模板函数出现了局限性，那么就特殊情况特殊处理！！

```c++
#include <iostream>

using namespace std; 

class  base
{
public:  
     base(int a):a(a){}
private:
int a;
//friend  bool   big(base a,base b);
friend  bool   operator>(base a,base b);
};

//重载 base 的比较运算符 
bool operator>(base a,base b)
{
   if(a.a > b.a)
    {
        return true;
    }else
    {
        return false;
    }
}

//设计一个比较两个数据大小的模板 
template <class T>
bool   big(T a,T b)
{
    if(a > b)
    {
        return true;
    }else
    {
        return false;
    }
}

/*
//特殊数据进行特殊处理 
bool   big(base a,base b) 
{

    if(a.a > b.a)
    {
        return true;
    }else
    {
        return false;
    }
}
*/

int main()
{

    base a=100,b=20;
    if(big(a,b))
    {
        cout  << "a > b"  << endl;
    }else
    {
        cout << " a <= b"  << endl;
    }
}

练习：设计一个模板函数，可以返回三个数据中的最大一个。 对于自定义数据类型也能处理。 
```



### 模板类

 当一个类中拥有一个通用的数据类型，那么这个类就是一个模板类，模板类在没实例化前，不能定义对象。 

语法： 

```c++
template <class 通用类型>
class  类名 
{
    通用类型 变量名
}; 
-------------------------------------------
例子：  
template <class T>
class  base
{
    T a;
}; //-> 这就是一个模板类
```

**记住模板类！！没有自动类型推导功能！**必须要用户手动实例化！！

例子： 

```c++
//设计一个模板类
template <class T>
class  base
{
public: 
base(T  a):a(a){}  
private: 
T a;
};

int main()
{
      int date=10086;
      base<int> a(date);  //实例化模板类型！！！！ 
}

//练习： 设计一个模板类，里面拥有两个通用类型 T   和  T1 。  在定义该模板类的对象。 

```



### 模板函数与模板类的区别

1.模板类没有 自动类型推导功能，模板函数有  

 2.模板类可以使用默认类型  



模板的默认类型使用： 

```c++
template <class T=int>
class  base
{
public: 
    base(T a):a(a){}
    void show()
    {
        cout << a << endl;
    }
private:
T a;
};

int main()
{
    base<>  a(3.1415126); //不写类型，则使用上面的默认类型 ,就算添加了默认类型 <> 也是需要填写了
                            //区分该类是一个模板类 
    a.show();
    base<double>  b(3.1415126);  //使用用户指定的模板参数 
    b.show();
    
}
```



### 模板类作为函数的参数传递

   注意： 当一个模板类，作为函数的参数时，无法直接通过类名作为函数的参数传递！！  



 解决方法： 

```c++
1.在函数的参数列表中，指定模板的类型。   
      void show_base(base<int> a)  
    
2.继续把类 参数类型模板化  
template <class T>
void show_base1(base<T> a)
    
3.直接把该函数设计为一个 纯模板函数  
   template <class T>
void show_base2(T a) 
```

  设计案例： 

```c++
#include <iostream>
using  namespace std;

//这是一个模板类 
template <class T>
class  base{
public: 
base(T a):a(a){}
T a; 
};

class  base1
{
public: 
base1(int a):a(a){}
int a; 
};


//1.指定模板类的参数列表，进行传递
void show_base(base<int> a)
{
    cout <<   a.a << endl;
}

//2.继续把类型模板化 
template <class T>
void show_base1(base<T> a)    //模板函数-》 自动类型推导功能
{
    cout <<   a.a << endl;
}

//3.把该函数设计为模板函数
template <class T>
void show_base2(T a) 
{
     cout << a.a << endl;
}

int main()
{

     base<int>  a(10086); 
      //调用函数 
      show_base(a); 
      show_base1(a);
      show_base2(a);
}
```

总结： 推荐使用 第一种方法！！ 



### 模板类的成员函数类外编写

```c++
#include <iostream>

using  namespace std; 

//定义一个模板类 
template <class T>
class base
{
   public:
    //单纯的声明接口
    base(T a); 
   ~base(); 
   void show(); 

private: 
T a;
};

//类外实现这些接口 
template <class T>
base<T>::base(T a)
{
    this->a = a;
}

template <class T>
base<T>::~base()
{
   cout << " base析构函数" << endl;
}

template <class T>
void base<T>::show()
{
    cout << this->a << endl;
}

int main()
{

   base<int>  a(10086); 
   a.show();
}
```

练习： 设计一个模板类  person  里面有两个通用类型  T 姓名  ，T1 年龄，  在类外实现 ，set_person接口  

show_person 接口，  构造函数 与 析构函数。

### 模板类的继承

### 模板类不能直接被继承 

解决方法： 

1. 指定基类的模板类型  

   ![image-20210705101037661](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210705101037661.png)

2.继续把派生类模板化  

 ![image-20210705101657571](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210705101657571.png)



练习： 

```
练习：设计一个模板类，person,里面有  T (姓名),T1（年龄）,根据person 派送出，一个教师类， 

 在教师类中初始化，person 的成员，并输出。
```





### 作业：

设计一个通用数组，可以存储不同的数据类型 要求如下： 

![img](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/1046757987.bmp)

```c++
类的设计： 
#include <iostream>
using namespace std;
template<class T>
class MyArray
{
public:
	//构造函数
	MyArray(int capacity)
	{
	
	}
	//拷贝构造
	MyArray(const MyArray & arr)
	{
	
	}
	//重载= 操作符  防止浅拷贝问题
	MyArray& operator=(const MyArray& myarray) {
	}

	//重载[] 操作符  arr[0]
	T& operator [](int index)
	{
		
	}

	//尾插法
	void Push_back(const T & val)
	{
		
	}

	//尾删法
	void Pop_back()
	{
		
	}

	//获取数组容量
	int getCapacity()
	{
		
	}

	//获取数组大小
	int	getSize()
	{
	
	}

	//析构
	~MyArray()
	{
	
	}

private:
	T * pAddress;  //指向一个堆空间，这个空间存储真正的数据
	int m_Capacity; //容量
	int m_Size;   // 大小
};
```

## C++标准函数库STL

### C++ 标准模板库(STL)

C++ STL (Standard Template Library标准模板库) 是通用类模板和算法的集合，它提供给程序员一些标准的数据结构的实现如 [queues](cppqueue.html)(队列), [lists](cpplist.html)(链表), 和 [stacks](cppstack.html)(栈)等.

### Vectors  向量容器

Vectors 包含着一系列连续存储的元素,其行为和数组类似。

构造函数

```c++
  vector();
  vector( size_type num, const TYPE &val ); //把 num 个 val 的值放到该容器中 
  vector( const vector &from );//拷贝构造函数 
  vector( input_iterator start, input_iterator end );//利用迭代器进行区间赋值
```

支持的运算符：

![image-20210705110238302](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210705110238302.png)



### vector 函数接口的使用：

```c++
push_back 函数 
语法: 
  void push_back( const TYPE &val );
push_back()添加值为val的元素到当前vector末尾
   
    
    
size 函数 
语法: 
  size_type size();
size() 函数返回当前vector所容纳元素的数目 

   
void pop_back();
pop_back()函数删除当前vector最末的一个元素,例如: 
```



### stl 库中的迭代器

迭代器就是 stl 库中的 一个特殊指针，功能与指针类似



官方的迭代器使用 demo: 

```c++
begin 函数 
语法: 
  iterator begin();

 

begin()函数返回一个指向当前vector起始元素的迭代器.例如,下面这段使用了一个迭代器来显示出vector中的所有元素:

vector<int> v1( 5, 789 );
vector<int>::iterator it;
for( it = v1.begin(); it != v1.end(); it++ )
  cout << *it << endl;

相关内容: end(). 
    
    
end 函数 
语法: 
  iterator end();
end() 函数返回一个指向当前vector末尾元素的下一位置的迭代器.注意,如果你要访问末尾元素,需要先将此迭代器自减1.

相关内容: begin() 
    
    
```

### vector 迭代的定义： 

每个stl 模板接口都有一个专用的迭代器。

```c++
vector<int>::iterator it;   
```

![image-20210705141735874](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210705141735874.png)

### vector 删除接口的使用

```c++
  iterator erase( iterator loc );  //删除迭代器所指向的值 
  							   	   //返回值：一个新的迭代器 
  iterator erase( iterator start, iterator end );
  //删除 start 迭代器  -》 end 迭代器区间的值 

```

### vector 容器的插入接口的使用

```c++
iterator insert( iterator loc, const TYPE &val ); //在 loc 位置插入 val  
void insert( iterator loc, size_type num, const TYPE &val );//在 loc 位置 插入 num个val 
void insert( iterator loc, input_iterator start, input_iterator end); 
//loc 位置上插入 区间 start -> end 
```



### C++ Double Ended Queues(双向队列)

双向队列和[向量](cppvector.html)很相似，但是它允许在容器头部快速插入和删除（就像在尾部一样）。



特点可以操作头部数据： 

```c++
pop_front 
语法: 
  void pop_front();
pop_front()删除双向队列头部的元素
    
push_front 
语法: 
  void push_front( const TYPE &val );
push_front()函数在双向队列的头部加入一个值为val的元素。
```



### C++ Lists（链表）

Lists将元素按顺序储存在链表中. 与 [向量(vectors](cppvector.html))相比,  它允许快速的插入和删除，但是随机访问却比较慢. 



构造函数： 

```c++
list<int> first;                                // 定义一个空链表
list<int> second (4,100);                       // 往链表中插入4个100 
list<int> third (second.begin(),second.end());  // 把一个区间的值赋值给链表
list<int> fourth (third);                       // 拷贝构造函数
```



接口说明： 

```c++
merge 
语法: 
  void merge( list &lst );
  void merge( list &lst, Comp compfunction );
merge()函数把自己和lst链表连接在一起，产生一个整齐排列的组合链表。如果指定compfunction，则将指定函数作为比较的依据

    
排序(sort) 
语法: 
  void sort();
  void sort( Comp compfunction );
sort()函数为链表排序，默认是升序。如果指定compfunction的话，就采用指定函数来判定两个元素的大小。

    
remove 
语法: 
  void remove( const TYPE &val );
remove()函数删除链表中所有值为val的元素。例如 

  
reverse 
语法: 
  void reverse();
reverse()函数把list所有元素倒转

unique 
语法: 
  void unique();  //删除重复的元素  
```

使用例子：

```c++
// list::merge
#include <iostream>
#include <list>
using namespace std;

// this compares equal two doubles if
//  their interger equivalents are equal
bool mycomparison (double first, double second)
{ return ( int(first)<int(second) ); }

int main ()
{
    //定义两条链表
  list<double> first, second;
 //往第一条插入数据
  first.push_back (3.1);
  first.push_back (2.2);
  first.push_back (2.9);
 //往第二条插入数据
  second.push_back (3.7);
  second.push_back (7.1);
  second.push_back (1.4);

  //进行链表排序 
  first.sort();
  second.sort();
   
  //合并两条链表
  first.merge(second);

  second.push_back (2.1);

   //再次合并  并指定合并的排序方式 
  first.merge(second,mycomparison);

  cout << "first contains:";
  for (list<double>::iterator it=first.begin(); it!=first.end(); ++it)
    cout << " " << *it;
  cout << endl;

  return 0;
} 

```



### **C++ Sets** 二叉树

集合(Set)是一种包含已排序对象的关联容器 （相等于二叉树）

![image-20210705162637374](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210705162637374.png)

构造函数  

```c++
// constructing sets
#include <iostream>
#include <set>
using namespace std;
struct classcomp {
  bool operator() (const int& lhs, const int& rhs) const
  {return lhs<rhs;}
};

int main ()
{
  set<int> first;                           //定义空的set容器

  int myints[]= {10,20,30,40,50};
  set<int> second (myints,myints+5);        //往set容器中插入5个数据 

  set<int> third (second);                  //拷贝构造函数 

  set<int> fourth (second.begin(), second.end());  //迭代器的方式赋值

  set<int,classcomp> fifth;                 // 指定插入的比较方法

  return 0;
}
```

插入数据: 

```c++
 

iterator insert( iterator i, const TYPE &val );

void insert( input_iterator start, input_iterator end );

pair insert( const TYPE &val );
 
```

### set 插入自定义的数据类型

1.重载 比较运算符  ,提示重载参数：需要添加const  

```c++
#include <iostream>
using namespace std; 
#include <set> 
 //练习:利用 set 容器，插入自定义的 person 数据 ,姓名，年龄，根据年龄插入。 
class  person
{
public: 
   person(string n,int a):name(n),age(a){}
string  name; 
int age;

friend bool operator<(person &a,person &b);
};


//重载比较运算符
bool operator<(const person &a,const person &b)
{
    return  a.age <  b.age;
}
int main()
{
    //定义一个 set 容器 
    set<person>  s;

    person a("小明",10);
    person a1("小花",19);
    person a2("小东",7);

    //插入数据 
    s.insert(a);
    s.insert(a1);
    s.insert(a2);

    for(auto it=s.begin();it!=s.end();it++)
   {
       cout  << it->name << endl;
       cout  << it->age << endl;
   }
    
}
```

2.在定义set 容器的时候说明比较方法  

```c++
//重新定义比较的方法 
struct classcomp {
  bool operator() (const person& lhs, const person& rhs) const
  {return lhs.age>rhs.age;}
};

int main()
{
    
    //定义一个 set 容器 
    set<person,classcomp>  s;
    person a("小明",10);
    person a1("小花",19);
    person a2("小东",7);
    //插入数据 
    s.insert(a);
    s.insert(a1);
    s.insert(a2);
    for(auto it=s.begin();it!=s.end();it++)
   {
       cout  << it->name << endl;
       cout  << it->age << endl;
   } 
}
```



### map 容器的使用 （重点）

C++ Maps是一种关联式容器，包含“关键字/值”对 

​															KEY/value     每一个key 对应一个value 

在map 容器中，所有的数据都是成对存在的。  -》 pair   对组  



### pair 对组的使用： 

![image-20210705170831036](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210705170831036.png)



### map 容器的构造函数

```c++
// constructing maps
#include <iostream>
#include <map>
using namespace std;

struct classcomp {
  bool operator() (const char& lhs, const char& rhs) const
  {return lhs<rhs;}
};

int main ()
{
  map<char,int> first; //定义一个空的 map 容器 
    
 //往map容器中插入数据
  first['a']=10;
  first['b']=30;
  first['c']=50;
  first['d']=70;

  map<char,int> second (first.begin(),first.end()); //赋值一个区间 

  map<char,int> third (second);//拷贝构造函数

  map<char,int,classcomp> fourth;        //设置map 容器的排序方法 

  return 0;
}
```



### map插入数据的方法

```c++
 //在pos 的位置插入 pair 
iterator insert( iterator pos, const pair<KEY_TYPE,VALUE_TYPE> &val );
//插入 start -》 end 的区间值 
  void insert( input_iterator start, input_iterator end );

//直接插入  pair 
  pair<iterator, bool> insert( const pair<KEY_TYPE,VALUE_TYPE> &val );

```



重载下标后的插入方法： 



```c++
// accessing mapped values
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main ()
{
  map<char,string> mymap;
  map<char,string>::iterator it;
	
  //重载后的下标插入方法  
  mymap['a']="an element";
  mymap['b']="another element";
  mymap['c']=mymap['b'];

     //重载后的下标 取出value的方法
  cout << "mymap['a'] is " << mymap['a'] << endl;
  cout << "mymap['b'] is " << mymap['b'] << endl;
  cout << "mymap['c'] is " << mymap['c'] << endl;
  cout << "mymap['d'] is " << mymap['d'] << endl;

  cout << "mymap now contains " << (int) mymap.size() << " elements." << endl;

  return 0;
}

//语法说明： 
对象名[key] = value;    //赋值  

 变量 = 对象名[key]     //取值 
```





### map 的查找方法 （使用最多）

```c++
find 
语法: 
  iterator find( const KEY_TYPE &key );

 

find()函数返回一个迭代器指向键值为key的元素，如果没找到就返回指向map尾部的迭代器。

//通过 key 找到 value  
    
```



## C++异常处理（try catch throw）

为什么需要异常处理？ 

- 用 new 运算符动态分配空间时，空间不够导致无法分配；

- 访问数组元素时，下标越界；打开文件读取时，文件不存在。

- 访问了野指，出现内存错误等等 ......  

  -------------------

  在c 语言 中异常处理的方法？？  

  ​		利用 if 语句判断操作是否正确。  

  在c++ 中异常处理的方法？？

     利用try （测试）   throw（抛出异常） catch（处理异常）

  c/c++ 中异常处理的区别： 

​      	c++ 中的处理能力更强，逻辑性更严谨，且系统中某些函数已经预定义了异常的抛出。如at,new 等等..



--------------------

语法： 

```c++
try {
    用户需要执行的代码
}
catch(异常类型) {
    异常处理代码
}
...
catch(异常类型) {
    异常处理代码
}
```

--------------------------------

例子： 

```c++
#include <iostream>
using namespace std;

int main()
{
    try{
       int *p =  new int[0x0fffffffffffffff];  //系统自动抛出异常
    }
    catch(...)  //接收异常
    {
            cout  << "程序出现异常"  << endl;
    }
}

```



### 异常的抛出 

------------

当系统不会自动抛出异常时，用户就要手动抛出异常。

```c++
 string a="hello"; 
    try{
     cout << a.at(1000000)  << endl;  //带有自动抛出异常的功能
    }catch(...)
    {
         cout << "代码出现异常" << endl;
    }

    try{

        cout << a[1000000] << endl;  //不具有自动抛出异常
    }catch(...){
        cout << "代码异常2" << endl;
    }
```



抛出异常语法： 

```c++
throw  表达式;
```

例子： 

```c++
#include <iostream>
using namespace std;

int main()
{
    string a="hello"; 
    try{
     cout << a.at(1000000)  << endl;  //带有自动抛出异常的功能
    }catch(...)
    {
         cout << "代码出现异常" << endl;
    }

    try{
        int size=1000000;
        if(size >= 5)  //手动  抛出异常
        {
                throw "数组越界";
        }
        cout << a[size] << endl;  //不具有自动抛出异常
        
    }catch(...){
        cout << "代码异常2" << endl;
    }
}
```

### 异常的类型捕捉

  catch(...) : 可以捕捉任何的异常类型，拿不到异常的抛出数据 

```c++
#include <iostream>
using namespace std;

class base
{
    
};

int main()
{
    base a;

    try{
            //直接抛出异常 
            throw  a;
    }
    catch(int a)  //捕捉  抛出的整形的异常
    {
        cout <<  "int"<<a << endl;
    }
    catch(double a)//捕捉  抛出的浮点型的异常
    {
        cout <<"double"<< a << endl;
    }
    catch(const char *a)//捕捉  抛出的字符串类型异常
    {
        cout << "char *"<<a << endl;
    }
    catch(...)
    {
        cout << "其他异常" << endl;
    }

}
```

### 系统预定义的异常类型

![image-20210429102411957](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20210429102411957.png)

```
 catch(exception &e)  //利预定义异常类型可以，告诉用户异常原因
 {
 cout << "其他异常"  << e.what() << endl;
 }
```

### 异常的再抛出

当一个函数出现异常的时候，抛出异常并未处理的的话，这个异常会继续往上抛出，直到处理为之！！

```c++
#include <iostream>

using namespace std;

//test 自己抛出自己处理
void test()
{
    try{
          throw "抛出异常";
    }
    catch(const char *a){   //在这里已经把异常处理掉了 
            cout << "输出异常:"  << a << endl;
    }
}

void test0()  //出现了异常，未处理 
{
    throw "抛出异常";  //只在当前函数中抛出不处理
}

void test1() //把异常抛出到 test1中  ，未处理
{
      cout << "test1" << endl; 
      test0();   
      cout <<  "test endl"  << endl;
}

int main() //继续把异常抛出到 main 中，catch已经处理
{
        try{
           // test(); //执行test 函数 
            test1();
        }
        catch(...){
            cout << "出现异常并未处理" << endl;
        }
}
```

## C++中的数据成员属性

### 静态属性：

​    回顾C语言的静态变量特点： 

```c++
1.静态全局变量，只能在当前文件中使用
2.修饰局部变量的时候，局部变量只能被初始化一次
3.修改函数,只能在当前文件中使用 
4.静态变量会改变数据的生命周期   （把栈空间的数据改为数据段）
```



### 类中的静态成员：

```c++
1.类中的静态成员只能在类外初始化
         int base::a=100;  //类外初始化 
2.类中的静态成员，不包含在对象空间中，因为静态成员是存储在数据段中的。 
       例如： class base{
                        public:
                     static  int a;}   ->大小为 1 。a不在base 的空间中
3.类中的静态成员，可以直接通过 《类名::变量名》 直接调用。 （一定要是公共成员）
4.类中的所有对象，共用静态成员。
```



### 类中的静态函数：

```c++
1.类中的静态函数，不能使用this 指针， (不是对象空间中的函数)
2.类中的静态函数，不能访问类中的非静态成员数据。 
（因为非静态成员数据，要定义对象后才产生空间，因为静态成员函数是先于对象存在的，静态成员函数，就无法访问）
3.静态成员函数是先于对象存在的，所以我们可以 《直接调用共有的静态成员函数》不需要创建对象！ 
    
//总结：静态成员函数的优点：1.方便用户的调用  2.不需要创建对象直接调用，节省内存空间
```



设计如下一个文件管理类： 

```c++
class  file 
{
  //构造函数  
    
    
//静态读取文件的内容接口
  
//文件的路径名    
}
//可以实现在不创建 file 对象的情况下，直接读取文件中的内容。 
```



### 类中的const成员

回顾c语言中的const 变量：

```c++
const int *p; //不能修改，指向的内容 

int const *p;//不能修改，指向的内容

int *const p;//不能修改指向的地址

const int *const p;//不能修改指向的内容与地址 ·


找规律： 看星星 ⭐
    如果*和p 一起的，就是内容不可变 
    如果是分开的，就地址不可变.
```



### 常量成员的作用

​        作用：提高代码的稳定性与安全性。 

const int  a=100; 



### 类中的常量成员

```c++
1.类中的常量成员，必须要初始化，否则无法定义对象。 （构造函数中的参数列表初始化，默认值）
2.常量被初始化后无法再次修改     
```



### 类中的常量函数：

```c++
1.类中的常量函数的定义     const 需要添加在函数的后面 
     void show() const  
2.类中的常量函数不能《修改》，类中的《所有》数据成员。  (保护了类中的数据成员，更加安全)

3.假设用户想要数据被常量函数修改，那么就在数据前添加   mutable 关键字即可
    
```



### 常量对象：

```c++
1.利用const 修饰的对象就是常量对象     
2.常量对象，无法修改类中的公共成员 
3.常量对象，假设想要修改类中的公共成员，那么必须使用  mutable 说明
4.常量对象，只能调用常量函数。无法调用普通函数
```





 













​       
