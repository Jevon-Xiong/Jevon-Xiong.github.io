---
layout: post
title: 复习-01C语言基础
author: jevon xiong
tags:
- blog
- 复习
- C
date: 2024-05-02 13:00 +0800
toc: true
---


# C语言基础

## Linux命令入门

![image-20240429205917230](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240429205917230.png)

pwd 打印当前的工作路径

```
~  就是 当前用户的家目录的缩写  （ /home/ubuntu ）
.   当前目录
..  上一级目录 
/    根目录
```

cd 切换工作路径

```
cd    /    // 切换路径到根目录
cd         // 直接切换到当前用户的家目录中
cd   ~     // 同上 切换到当前用户的家目录中
cd  ..     // 却换到上一级目录
cd  ../../Even/pic  //  返回上一级的上一级的Even里面的pic (相对路径) 
cd   /home/Even/pic  // 切换路径到 /home/Even/pic (绝对路径)
cd   -      // 返回上一次所在的路径
```

ls 列举当前目录下的内容

```
ls   -l   // 列举当前目录下的详细内容
ls   -a   // 列举当前目录下的所有内容（包括隐藏文件.Filename）
```

![image-20240429210048640](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240429210048640.png)

find   查找

```
finde  -name   Even   // 在当前目录开始以名字查找 Even 文件
locate   Even      // 所有所有包含 Even字串的文件名
```

clear 命令用于清除终端窗口

快捷方式：  Ctrl  + L 

cat  打印输出文件的内容

head 查看某个文件的头部

```
head   stdio.h   // 查看stdio.h 文件的前10行（默认）
head  -20 stdio.h   // 查看stdio.h 文件的前20行(行数可以自行指定)
```

tail 查看某个文件的尾部

```
tail   stdio.h // 查看stdio.h 文件的末尾10行（默认）
tail  -20  stdio.h // 查看stdio.h 文件的末尾20行(行数可以自行指定)
```

grep 在文件中查找指定的内容

```
grep   printf   stdio.h  -n    //在 stdio.h 查找指定内容 printf 并输出内容所出现的行号
```

chmod	修改文件的权限

```
chmod   367  Even  // 修改文件Even的权限为拥有者
               可写+可执行
               同组用户 可读 + 可写
               其它用户  可读+可写+可执行
```

cp  复制文件

```
cp  Even  Jacy  // 把普通文件Even 复制成Jacy 
cp  abc/   123   // 把目录文件 abc 复制成  123   -r  为递归选项
```

mv  移动文件  /  重命名

```
mv  Even  abc    // 把文件  Even 移动到 目录abc 中 
mv  987   Jacy   // 把文件 987 重命名为  Jacy
```

注意：

mv 具体是移动还是重命名的功能取决于**第三个参数是否存在**， 如果第三个参数是一个**不存在**的文件名 则是重命名， 如果第三个参数**存在并且是一个目录文件**则是移动文件

mkdir 创建目录文件

```
mkdir    lkkl   // 创建一个目录文件名字为 lkkl 
```

touch   创建一个普通文件

```
touch  abc.c   // 创建一个普通文件名字为  abc.c 
```

rm  删除文件

```
rm    abc.c  // 删除普通文件 abc.c 
rm    Even -r  // 递归删除目录文件 Even 
```

sudo    临时使用超级用户的权限做某事

```
sudo   touch  abc.c  //  临时使用超级用户的权限 创建一个普通文件 【推荐使用】
sudo   -s  //  临时切换为超级用户
   输入 exit  可以退出 
```

man 手册

```
man   man   //查看一下man 手册是什么
man  -f  mkfifo   //  查看一下 mkfifo 出现在哪一本手册中
man  1  mkfifo   // 在第一本手册中查看  mkfifo 的解析(命令)
man  3  mkfifo  // 在第三本手册中查看  mkfifo 的解析(函数)
```

## 程序入门

基础知识：

**标准输入   stdin**      对应的是键盘文件 

**标准输出   stdout**   对应的是终端《带缓冲区》（屏幕）

**标准出错   stderr**   对应的是终端《无缓冲区》（屏幕）

```
printf("Hello Even\n");
以上语句中 \n  是一个换行符 ，说明是一行的结束
标准输出文件中默认使用缓冲 ，也就是当遇到 \n 的时候会进行刷新缓冲区（把数据输出）
当打印语句后面没有换行符时 ， 需要等待缓冲区被装满或者被别的语句刷新或则程序正常退出
```

调试技巧：

```
printf("%s--%s--%d\n" , __FILE__ , __FUNCTION__ , __LINE__ );
__FILE__        文件名
__FUNCTION__    函数名
__LINE__        行号
```

GCC 编译器：

```
$ gcc Hello.c   // 使用gcc 编译  Hello.c 并且默认生成一个名为 a.out的可执行文件
$ gcc Hello.c -o TieZhu // 使用gcc 编译
                        //  Hello.c 并且指定生成名字为TieZhu 的可执行文件
$ gcc Hello.c -o TieZhu -v // -v 输出百编译的信息， 包括头文件寻找的路径
$ gcc Hello.c -o TieZhu  -I/mnt/d/ -v  // -I 指定头文件寻找的路径（在原本默认的基础上添加）
$ gcc Hello.c  -Wall  // 输出所有的警告
```

VIM 编辑器：

有三种模式            	命令模式 				编辑模式 				尾行模式

命令模式 	：

默认情况下使用vim 打开一个文件会处于命令模式下：

按下冒号‘：’ 则可以进入 尾行模式 

按下  i o a I O A   则可以 进入 编辑模式

尾行模式：

```
w    --> 保存文件（写入到磁盘）
q    --> 退出
!    --> 强制

:q!   --> 不保存退出
:wq   --> 保存并退出
:w Even.c --> 把当前文件另存为 Even.c 
```

尾行模式下按下  ESC   则可以退出尾行模式回到 命令模式 

编辑模式 ：

i  :  在光标的前面进行插入（编辑）

I :   光标跳到当前行的行首进行插入

o:   在当前光标的下一行新建一行进行插入

O:  在当前光标的上一行新建一行进行插入

a:   在光标的后面进行插入（编辑）

A:   光标跳到当前行的行尾进行插入

编辑模式下按下  ESC   则可以退出编辑模式回到 命令模式 

![image-20240429211221505](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240429211221505.png)

**标准输出（格式化输出）：**

概念：屏幕（终端）对应的就是标准输出的设备文件，如果往该文件中输出内容则可以成为标准输出。

```
printf();
```

注意语法点：

- %  必须有的，格式化的开头标记
- \-    对齐的方式， 向左对齐（空格在右） ，如果没有则是向右对齐（空格在左）
- m.n   m指的域宽（需要的字符数）， n 指的是精度（默认精度为6）
- - - m 的值如果比实际数据小则按实际输出， 反之则用空格来填补

- l    指的是 long 表示长整型
- h   指的是短整型 

格式控制符：

- 十进制的整型： %d   %md    %ld      %u （无符号）   %lu
- 八进制： %o  %#o     # --> 输出进制的符号
- 十六进制： %x  %#x   %#X
- 字符：  %c
- 字符串： %s
- 单精度浮点： %f    %.nf  --> n 表示精度
- 双精度：  %lf
- 长双精度 ： %Lf 
- 地址： %p  

## 数据类型-1

### **整型**

概念： 表示整数类型的数据

`                int   a   = 123 ;              `

![image-20240429211611555](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240429211611555.png)

注意：

- 整型在 32位系统以及64位系统中都占用 4字节
- 取值范围 

```
$ getconf INT_MAX
2147483647
$ getconf INT_MIN
-2147483648
```

整型的修饰符：

- short     短整型，用于修饰整型的尺寸变为原本的一半，减少内存的开支，缩小取值范围

- long      长整型 ， 用于修饰整型的尺寸使其尺寸变大（取决与系统）， 增加内存开支， 扩大取值范围

- long long   长长整型 ， 用于修饰整型的尺寸使其尺寸变大（取决与系统）， 增加内存开支， 扩大取值范围 （在64位系统中 long 与 long long的大小一致）

- unsigned 无符号整型  ， 用来修饰整型并去掉符号位，使得整型数据没有负数，可以提正整数的取值范围 （0 - 4294967295）

- - 整型数据在二进制存储时最高位（第31位）表示符号位，如果为1 则表示负数反之则表示正数

整数的存储方式：

原码： 正整数是直接使用原码进行存储的，比如100这个正整数，则直接把100 转换成二进制直接存储。

100  -->  0000 0000   0000 0000  0000 0000   0110   0100

补码：**负数则是使用补码来存储， 补码 = 原码的绝对值 取反+ 1**

**取反加1时符号位不变** 

比如 -100 ：

100  -->  1000 0000   0000 0000  0000 0000   0110   0100

取反->  1111 1111   1111 1111  1111 1111  1001   1011

 加1 -->  1111 1111   1111 1111  1111 1111  1001   1100

溢出：

当超过取值范围时则会编程相邻的最小值/最大值



sizeof运算符，用于计算 变量/类型 的大小。

### **浮点型（实型）：**

概念：用来表达一个实数的数据类型

分类：

- 单精度浮点型  float , 典型尺寸  4 字节 
- 双精度浮点型  double , 典型尺寸  8 字节
- 长双精度 long   double ， 典型尺寸  16  字节 

占用的内存越多则精度越高

浮点数的存储：

IEEE 浮点标准采用如下形式来表示一个浮点数

![image-20240429211853914](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240429211853914.png)

![image-20240429211900643](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240429211900643.png)

注意：

```C
float f = 3.14;  // 浮点数3.14 通过以上公式计算得到的二进制码被存放与内存f中
printf("f:%f\n" , f ); // 使用浮点的计算方法来解析内存f中的值(二进制)
printf("d:%d\n" , f );// 直接使用整型的计算方法来直接解析内存f 中的值 (二进制)
```

所有的数据都会被转换成二进制进行存储，如果想到的到正确的数据，必须使用正确的理解方式（类型），来解析二进制数据。

**字符类型：**

`                char  c = 'K' ;              `

1. 申请一片内存并且命名为 c 
2. 确定内存的大小为 char  （1字节）
3. 把字符‘K’的ASCII码值转换为二进制，并存储到该内存中

计算机中存储的所有数据都是以二进制的形式存在的， 因此字符必须映射某一个数字才能够被存放到计算机中，这个映射的表就成为 ASCII 表，可以使用man手册来查看：

`                man  ascii               `

注意：

**字符实质上是一个单字节的整型，因此支持所有整型的操作**

### **字符串：**

字符串的表现形式有两种：

形式一 数组（可读 ，可写）：（存储）

`                char  s1 [] = "Hello" ;   //使用一个数组来存放字符串 "Hello"              `

 以上语句其实是把一个字符串常量  "Hello" ， 复制到数组 s1 所代表的内存当中

![image-20240429212547807](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240429212547807.png)

形式二 指针 （只读）：（指向）

`                char *  s2   = "Even";  // 使用一个指针来指向常量字符串              `

![image-20240429212623137](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240429212623137.png)

### 布尔类型：

概念： 布尔类型用来表示真/假 （非零则真）

真： true

假： false 

注意在使用布尔类型是需要包含他的头文件：<stdbool.h>

一般布尔类型的变量，可以用于逻辑判断比如 if  / while  ， 或者用于函数的返回值。

 布尔类型的大小：

```
sizeof(true):4  
sizeof(false):4 
```

### 常量与变量：

概念： 不可以被改变的内存，被称为常量，可以被改变的内存则成为变量

常量类型：

- 100   ： 整型常量
- 100L :   长整型 long 
- 100LL : 长长整型 long long
- 100UL : 无符号的长整型  unsigned long 
- 3.14   : 编译器默认升级为双精度浮点型
- 3.14L : 长的双精度浮点型 
- 'a'  : 字符常量
- "Hello"  : 字符串常量（指针 char  * ）

**标准输入：**

概念： 	标准输入一般指的是键盘的设备文件， 从键盘获取数据就成为标准输入

```
scanf( ); // 扫描键盘 （格式化输入数据 --> 从键盘中获得指定类型的数据）
头文件：
    #include <stdio.h>
函数原型：
    int scanf(const char *format, ...);
参数分析：
    format --> 格式化
    ...   --> 省略号 ,  根据format 所写的格式控制符，对应一个内存地址
返回值：
    成功  返回具体获取到的项目数
    失败  返回0 
    
getchar( ) ; // 获取一个字符 （默认从标准输入文件中获取）
    
    函数原型：
        int getchar(void);
    参数：
        无
    返回值：
        成功 返回一个ASCII值， 代表获得的字符 （unsigned  char ）
        失败  返回 EOF  也就是 -1 
```

实例：

```
int main(int argc, char const *argv[])
{
    int num = 0;
    char c = '0';
    // & 取地址符号 ， 获得 内存 num 的地址
    int ret_val =  scanf("%d", &num );
    while(getchar() != '\n');  // 清空 由 scanf 所留在缓冲区的内容 
    //   如果不清空有可能会导致下一次使用标准输入缓冲区异常（有上一次的数据没有被读取）

    printf("返回值：%d , 获取的数据为：%d\n" , ret_val , num );
    
    ret_val = scanf("%c", &c );
    while(getchar() != '\n'); // 清空 由 scanf 所留在缓冲区的内容
    printf("返回值：%d , 获取的数据为：%c\n" , ret_val , c );

    printf("EOF:%d\n" , EOF ); //EOF 实际上是一个值为-1 的宏

    return 0;
}

```

注意：

 如果以后需要从标准输入中获取数据得到乱码或未知数据，则可以尝试使用getchar 进行清空再 获取。

## 数据类型-2

**类型的转换**

概念： 不同的数据类型但是可以兼容的类型之间，如果出现在同一表达式中则会发生类型的转换。

数据类型之间转换的模式有两种：

隐式转换（自动）：

若在表达式中用户没有手动进行转换，则系统会自动转为高精度的类型，

比如     float + double + int    --> 则系统会自动全部转为 double 

强制转换（手动）：

用户根据自己的需求进行强制的类型转换  (int )a  --> 强制性把a 转换为整型

低精度  ----------------------------------------------------------->    高精度

char   -->   short --> int --> long  --> float --> double  --> long double 

注意：

 不管是隐式转换还是强制转换， 准换的只是在运算的过程中 ，并不会影响到原本的数， 这是一个临时的转换。

数据类型的本质：

概念： 	各种不同的数据类型，从本质上是用户与系统之间的一个约定，这个约定用来如何正确的解析内存中的二进制编码。

推论：

类型转换： 实际上是在临时打破之前的约定。

理论上任何的数据都可以进行转换， 但是转换之后是否有意义。

整型的尺寸：

概念： 尺寸指的是某一个数据需要多少内存来存储（占用的内存空间）

在C语言中并没有规定某一个数据类型他的尺寸是多少，但是有个相对的大小约定

short  不可能比int 长

long  不可能比int 短

long  的长度等于系统的字长 （系统位数）

如何查看系统字长：

```
$ getconf  LONG_BIT 
```

典型尺寸：

- char   占用 1 个字节
- short   占用 2 个字节
- int   占用 4 个字节
- long    占用 4(32位系统) /  8（64位系统） 个字节

问题：

 相同的代码在不同（位数）的系统中，它所占用的尺寸会发生变化，有可能导致数据的精度出现问题， 严重的可能会导致程序无法运行。

因此，系统中会提供一些可移植类型。

可移植数据类型：

概念： 不管在什么系统中，数据的尺寸都是固定不不会发生变化的数据类型成为可移植数据类型。

关键字：  typedef 

```
typedef  int  TieZhu ;  // 相当于用typedef 给 int  取个别名 叫  TieZhu 
typedef  int  __int32_t ;
typedef  long __long_64_t ;
```

系统提供了一些预定义的可以直数据类型：

```C
/usr/include/x86_64-linux-gnu/bits/types.h

/* Convenience types.  */
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

/* Fixed-size types, underlying types depend on word size and compiler.  */
typedef signed char __int8_t;  // 有符号8位整型
typedef unsigned char __uint8_t; // 无符号8位整型
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
#if __WORDSIZE == 64    // ---> 判断系统的位数（字长） 如果是 64位
typedef signed long int __int64_t;  // 64位系统中  long int 就是  64位的有符号整型
typedef unsigned long int __uint64_t;// 64位系统中  long int 就是  64位的无符号整型
#else // ---> 判断系统的位数（字长） 如果不是 64位系统 则判断为 32 位系统 
__extension__ typedef signed long long int __int64_t; // 在32位系统中 long long  才占用 64位 
__extension__ typedef unsigned long long int __uint64_t;
#endif
```

## 运算符

算术运算符：

\+   			加法运算 ， 一目取正			

-			减法运算， 一目取负

*			乘法运算

/			除法运算

%			取模（求余）

++			自加 1 					a++    ,  ++a 

--  			自减 1 		

注意：

- 减号也是一个负号 表示取反  ， a = -100 ,   -a  -> 100
- **取模运算的左右两个操作数必须是整型的**
- 自加，自减既可以操作整型也可以**操作浮点， 也可以操作指针**
- **前缀 ： 先进行自加/自减的运算，然后再参与表达式的运算**
- **后缀：  先参与表达式的运算 ， 然后再进行自加/自减的运算**

关系运算符：

\> 			大于 			a> b   判断a 是否大于b   ，该表达式的值为布尔值

<			小于

\>=			大于等于			a >= b  判断a 是否大于或者等于b  , 该表达式的值为布尔值（表达式中只要a 是大于或者等于b 表达式都为真） 

<= 			小于等于

== 			等于 			a == b    判断是否相等

！=    		不等于   			a != b     判断是否不相等

注意：

-  判断两个数是否相等使用的==  , 是两个等号 ，而不是一个
-  关系运算符的表达式值为布尔值
-  在**数学中    100< a <200 , 在代码中需要拆开 ，   a  > 100  &&  a < 200**

逻辑运算符：

！			逻辑反 		!(x>9)   如果 x 确实大于 9 则整个表达式为 假 ，反之为真

&&			逻辑与		 （ a  > 100  &&  a < 200  ）  该表达式两边同时为真则为真， 如果其中一个为假则整个表达式为 假

||			逻辑或		（ a  > 100  ||  a < 200  ）  该表达式中其中一个为真则整个表达式为真

注意：

**在逻辑与的运算中，如果左边为假则直接判断为假，右边的表达式将不会执行**

**在逻辑或的运算中， 如果左边为真则表达式直接判断为真， 右边的表达式将不会执行**

**位运算符：**

~ 			位逻辑反	

&   			位逻辑与		有零得零  --> 清零操作

|		位逻辑或 		有一得一   --> 置1 操作

^ 		位逻辑异或	相同得0 ， 不同得1 

<<		左移  

\>>  	右移 

注意：

- 位运算符操作的是操作数的每一个二进制位

- 位逻辑反，实际上是对操作数的每一个二进制位进行取反，  0与1之间对调

- 异或运算，相同得 0  ， 不同得1 

- 位移， 移出去的丢弃， 空出来的补0 

- - 如果移动是一个有符号的数据，并右移运算时 ，移出去丢弃， 空出来补符号位

**特殊运算符：**

- 赋值运算符 =   （左值=右值）

- - 左值不能是常量  100 = a ；
  - 不能直接对数组赋值  
  - 可以使用连续赋值  a = b = c = d = 100 ;

- 复合运算符

但左右两边右相同的操作数时，可以使用符合运算符， 使得代码看起来更加简明，且可以在一定程度上提高效率。

只用一下十种复合运算符

```C
// 加减乘除
a += b ;//  相当于  a  =  a + b ;
a -= b ;
a *= b ;
a /= b ;

// 求余
a  %= b ;  // 相当于  a  =  a % b ; 

// 位运算
a  &= b ;  // 相当于  a  =  a & b ;
a  |= b ;
a  ^= b ;
a >>= b ;
a <<= b ; 
```

- 条件运算符  （三目运算符）

- - 唯一一个需要三个操作数的运算符（表达式）
  - 语法：  表达式1  ？  表达式2   ： 表达式3 
  - 如果表达式1的值位真， 则整个表达式的值为表达式2  ，冒号左边 
  - 如果表达式1的值位假， 则整个表达式的值为表达式3  ， 冒号右边

- sizeof 运算符

注意该运算符看起来很像一个函数， 不要忘记它实际只是一个运算符

用来计算指定的 **变量 或 变量类型**  从而得到他在内从中所需要占用的字节

**return 运算符：**

含义： 退出某一个函数（如果时在主函数遇到return 则退出程序进程结束， 如果不是主函数，则返回被调用的位置）

语法： 必须出现在函数体内部，可以携带对应类型的值，进行返回

优先级与结合性：

当一个表达式中同时出现了多个运算符时，根据优先级以及结合性进行运算，比如先乘除后加减。。。

优先级：

`                man operator              `

逗号表达式：

语法  ： 表达式1  =  （表达式2 ， 表达式3 ，表达式4 ， ...... , 表达式n ）；

注意：

逗号表达式中， 会从左往右依次运算每一一个表达式

整个表达式的值取决于 最后一个表达式的值 

## 控制流（分支结构）

**二路分支：**

逻辑： 程序中某一段代码需要满足一定的条件才会被执行

语法：

- if 语句： 表达一种 ， 如果条件满足 则 执行某个代码块 
- if-else 语句： 表达一种 ，如果 条将满足则执行某个代码块 否则执行另外一个代码块

注意：

if 语句可以单独使用， 但是else不可以单独只用， 必须在if后面配套使用

不管是if还是else ， 建议给他们配一对大括号 { } 。 否则需要注意只能识别if / esle 后面的第一个逻辑行的语句

**多路分支：**

逻辑： 	根据不同的条件来执行不同的代码块

语法：

```
switch  (表达式<判断的条件>)
{
    case <常量1> :
        // 代码块 1 
        break ;
        
    case <常量2> :
        // 代码块 2 
        break ;
    
    case <常量3> :
        // 代码块 3 
        break ;
    
    default :
        // 代码块 N   
}
```

注意：

- switch(num )语句中的num  , 它必须是一个整型的表达式，也就是所switch只能判断整型的数据
- case 语句中的 必须是整型常量，包括普通的字符。不包括被const修改的整型数据
- break 用来中断/跳出当前的循环。如果没有则会从条件满足的语句开始一条一条的往下执行，直到整个switch - case 结束或者遇到其它代码块中的break 
- default 并不是必须存在，它一般放在最后面，用来提示用户表示都不满足以上条件。由于在最后面可以不添加break 

**const ：**

用来修饰一个变量使之不可被修改

作用：

修饰变量： 使得变量不能被修改

修饰指针：使得指针的指向不能改变或者指针所指向的内容不得改变

**while 和  do...while循环**

逻辑： 	使得程序中某一端代码块重复循环执行。

语法：

```
while( 表达式 )
{
     // 代码块   
}
```

do.. while语法：

```
do 
{
    // 代码块
}while(表达式);
```

注意：

- while 循环 先进行判断而且条件为真，然后再执行代码块（有可能一次都不执行）
- do .. while  则是先执行一次代码块 ，然后再判断条件是否成立（最少会执行一次代码块）
- while(num);  --> 空循环  这个分号要慎重
- do.. while(num) ;   这个分号不能丢

**for循环：**

逻辑： 与while 类似， 都是让程序中某一段代码块重复运行，但是for相对与while来说更加紧凑。把所有的循环控制都集中到一行代码中

语法：

```
for(初始化语句 ;  判断语句  ; 表达式 (一般用于自加/自减))
{
    // 代码块
}
```

​                for (;;)   // 相当与 while(1)死循环              

注意：

- 初始化语句只会被执行一次
- 第三个表达式  ++i 再第一次循环的时候并没有被执行
- 第三个表达式中 **前缀/后缀 并不影响 i 再循环中取值的先后**
- for 循环语句中 ，三个表达式都可以省略，但是分号必须留下
- for 循环语句中 ， 三个表达式中间用**分号来隔开** ;
- 在for循环中直接定义并初始化只在C99的编译规则下可以这么干， 所以可以添加

**break 与 continue :**

break: 跳出循环结构 /  跳出当前层的循环

continue : 结束当前这一次循环，重新进入下一次的循环

**goto 语句：**

逻辑： 无条件跳转

语法

```
int main(int argc, char const *argv[])
{

标签：
    //代码块

    goto 标签;

    return 0;
}
```

注意：

标签后面有个冒号：

goto 语句是一个无条件跳转的语句， 不利于程序的可读性，一般不建议使用

**goto 语句一般出现在驱动比较多， 用来处理严重的错误，并退出**

## 数组初级

**基本概念：**

逻辑： 一次性定义多个相同类型的变量，并且给他分配一片连续的内存

语法：

`                int   arr  [5] ;               `

![image-20240430104735435](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430104735435.png)

初始化：

只有在定义的时候赋值， 才可以称为初始化。数组只有在初始化的时候才可以统一赋值。

```
int arr [5]  = {1,2,3,4,5} ; // 定义并初始化数组

int arr [5]  = {1,2,3} ; //可以， 不完全初始化 
int arr [5]  = {1,2,3,4,5,6,7,8,9} ; // 错误（但是可以用） ， 越界初始化， 越界部分将会被编译器舍弃
int arr [ ]  = {1,2,3,4,5,6,7,8,9} ; // 可以， 用户没有直接给定数组大小，
            // 但是有初始化， 因此数组的大小会在初始化时确定， 大小为 9 
int arr [ ] ;  // 错误的， 没有给定大小也没有初始化， 因此数组的内存大小无法确定系统无法分配
```

注意：

数组在定义的时候必须确定他的大小。

说白了就是中括号中[] 必须有数组的大小，如果没有就必须初始化

数组元素引用：

存储模式：一片连续的内存，按照数据的类型进行分割成若干个大小相同的格子

元素的下标与偏移量：以数组开头为基础的偏移的量（数据类型大小

**字符数组：**

概念： 专门用来存放字符类型数据的数组， 称为字符数组

初始化+引用：

```
char ch1 [5] = {'H','e','l','l','o'} ; // 定义一个字符类型的数组并把'H','e','l','l','o' 一个一个存进去 
char ch2 [6] = {"Hello"} ; // 定义一个字符型的数组， 并把 "Hello" 字符串存放到数组中 ，因此该数组为字符串数组

char ch3 [6] = "Hello" ;  // 与ch2 一样， 大括号可以省略

ch3[1] = 'E' ; // 可以， 把数组中第二个元素‘e’修改为‘E’
ch3 = "Even" ; //  不可以， 只有在初始化的时候才能整体赋值

printf("%s\n" , ch1); // 在访问ch1的时候并没有发现结束符，因此很有可能会把ch2的内容一并输出
```

注意：

ch1 为字符数组， 它没有结束符，因此在打印输出的时候应该避免使用 %s 进行输出， 有可能会造成越界访问。

思考：

定义数组时没有初始化会怎么样？

结论： 没有初始化的情况看内存的能容是随机值（内存中原有的内容）

不完全初始化又会怎么样？

结论：不完全初始化 ，已经初始化部分是已知值 ， 其它则是0 

## 指针入门

**内存地址**

字节： 字节是内存容量的一个单位， byte ， 一个字节byte 有 8个位 bit 

地址： 系统位了方便区分每一个字节的数据， 而对内存进行了逐一编号， 而该编号就是内存地址。

**基地址**

单字节的数据： char 它所在**地址的编号**就是该数据的**地址**

多字节的数据：int    它拥有4个连续的地址的编号 ， 其中**地址值最小的称为该变量的地址**

**取地址符号**

每一个变量其实都对应了片内存， 因此都可以通过 & 取地址符号把其地址获得。

注意：

- 虽然不同的数据类型所占用的内存空间不同， 但是他们的地址所占用的内存空间（**地址的大小= 指针的大小）是恒定的**， 由系统的位数来决定 32位 / 64位
- 不同的地址他从表面上看似乎没有什么差别，但是由他们所代表的内存的尺寸是不一样的（由内存中所存放的数据类型相关），因此我们在访问这些地址的时候需要严格区分它们的逻辑关系。

**指针的基础**

指针的概念：

&a  就是a的地址 ， 实质上也可以理解为他是一个指针 指向 a的地址。

专门用来存放地址的一个变量，因此指针的大小是恒定的 ，由系统的位数来决定。

指针的定义语法：

```
int a ;   // 定义一片内存名字叫 a  ， 约定好该内存用来存放 整型数据
int  * p ; // 定义一片内存名字叫 p ， 约定好该内存用来存放 整型数据的地址
char * p1 ; // 定义一片内存名字叫 p1 ， 约定好该内存用来存放 字符数据的地址
double * p2 ; // 定义一片内存名字叫 p2 ， 约定好该内存用来存放 双精度数据的地址
```

注意：

指针的类型，并不是用来决定该指针的大小,而是用来告诉编译器如果我们通过来指针来访问内存时需要访问的内存的大小尺寸。

指针的赋值以及初始化：

```
int  a = 100 ;
int * p = &a ; // 定义并初始化

double d = 1024.1234 ;
double * p1 = &d ;// 定义并初始化

float f ;
float * p2 ;// 定义并没有初始化

p2 = &f ;  // 给指针赋值
```

注意：

不同类型的指针，应该用来指向与其相对应的类型的变量的地址。

指针的索引：

通过指针获得它所指向的数据（**解引用/取目标**）

```
int  a = 100 ;
int * p = &a ;

*p = 250 ;  //   *p <==>  a 
```

**野指针：**

概念： 指向一块未知内存的指针， 被称为野指针。

危害：

- 引用野指针的时候，很大概率我们会访问到一个非法内存，通常会出现**段错误（Segmentation fault (core dumped)）并导致程序崩溃**。
- 更加严重的后果，如果访问的时系统关键的数据，则有可能造成系统崩溃

产生原因：

- 定义时没有对他进行初始化
- 指向的内存被释放，系统已经回收， 后该指针并没有重新初始化
- 指针越界

如何防止：

- 定义时记得对他进行初始化
- 绝对不去访问被回收的内存地址， 当我们释放之后应该重新初始化该指针。
- 确认所申请的内存的大小，谨防越界

**空指针**

在很多的情况下我们一开始还不确定一个指针需要指向哪里，因此可以让该指针先指向一个不会破坏系统关键数据的位置， 而这个位置一般就是NULL （空）。因此指向该地址的指针都称之为空指针。

![image-20240430105604606](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430105604606.png)

概念：

空指针就是保存了地址值为零的一个地址， 也就零地址NULL

```
 int * p1 = NULL ; // 定义一个指针， 并初始化为空指针（ 指向 NULL ）
 
*p1 = 250 ; // 段错误 ， 该地址不允许写入任何东西

```

**指针运算**

指针的加法：意味着地址向上移动若干个目标 （指针的类型）

指针的减法：意味着地址向下移动若干个目标 （指针的类型）

注意：

指针在加减运算的过程中， 加/减的大小取决于该指针他自己的类型，与它所执行的数据实际的类型没有关系。

## 数组与指针的结合

示例1 ：

```
int  arr [5] = {1,2,3,4,5} ;
int * p1 = &arr ;
int * p2 = arr ;


printf("*p1:%d\n" , *(p1+1)) ;
printf("*p2:%d\n" , *(p2+1)) ;
```

![image-20240430105918725](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430105918725.png)

实例2：

```
int  arr [5] = {1,2,3,4,5} ;

int * p2 = &arr[2] ;

printf("*p2-1:%d\n" , *(p2-1)) ;
printf("*p2:%d\n" , *p2) ;
printf("*p2+1:%d\n" , *(p2+1)) ;
```

以上代码是通过指针p2 来访问数组中的元素。

一开始定义p2并初始化让指针p2 指向数组中第3个元素的地址。

当我们使用p2 进行指针加减运算的时候 ，由于指针是整型的，可以访问到数组中的下一个元素以及上一个元素。

实例3：

数组指针：  专门用来指向一个数组的**指针**。

```
int * p ;
int (* p) [5] ; //定义一个 名为p 的指针， 
        //并且确定他指向的类型为int  [5] ,一个拥有5个元素的整型数组
        
int  arr [5] = {1,2,3,4,5} ;

int (*p) [5] = arr ;

printf("arr:%p\n" , &arr );

printf("%p---%d\n" ,p , (*p)[2] ); // 3   * p ==> arr 
printf("%p---%d\n" , p+1 , (*(p+1))[2] ); // 已经越界访问
```

注意：

以上代码中 p指向的是 一个整型数组并有5个元素。 因此在对p 进行加减运算时， 是加减一个数组 。

实例4 ：

指针数组： **专门用来存放指针的数组，称为指针数组**。

```
int a = 100 ;
int b = 250 ;
int c = 550 ;
int d = 256 ;
int e = 998 ;

int  * p [5] = {&a, &b , &c , &d , &e} ; // 定义一个名字为 p的数组， 并且确定该数组中用来存放int * 整型地址


for (size_t i = 0; i < 5; i++)
{
    printf("*p[%d]:%d \n" , i , *(p[i])  ); // p[0]  --》 &a
}

```

## 数组进阶

**数组名的含义：**

数组名在不同的场合下的含义有两种：

表示整个数组的首地址：

- 在数组定义的时候
- 在使用sizeof 运算符中 数组名表示整个数组的首地址（求得整个数组的大小）
- 在取地址符 中 &arr  , arr 表示整个数组

表示整个数组首元素的首地址：

- 其它情况

```
int arr[10] ;  // arr 表示整个数组的首地址
int len = sizeof arr ; // arr  表示整个数组的首地址  ， sizeof 运算符后的括号可以省略
int (* p) [10] = &arr;  //arr 表示整个数组的首地址

int *p1 = arr ; //  arr 表示数组的首元素的首地址
```

**数组下标：**

数组的下标实际上只是编译器提供一种简写，实际上如下：

```
int a [100] ;
a[10] = 250 ;  ====>  *(a+10) = 250 ;
```

**字符串常量：**

字符串常量是一个被存放在常量区的字符串，实际上也可称为一个匿名数组。

匿名数组，同样满足数组名的含义。

```
char  * msg2 = "Hello Even" ;// "Hello Even" 字符串常量首元素的首地址
char  * msg1 = "Hello Even"+1 ;


printf("%s\n", "Hello Even" ) ;// "Hello Even" 字符串常量首元素的首地址
printf("%p\n", &"Hello Even" ) ; // "Hello Even" 字符串常量的整个数组的地址

printf("%c\n", "Hello Even"[6] ) ; // "Hello Even" 字符串常量首元素的首地址 [6]
            //  [6]  相当于+6个单位（char） 得到 ‘E’
```

![image-20240430111256856](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430111256856.png)

**零长数组：（预习结构体）**

概念： 数组的长度为0 ， char arr [0] ;

用途：一般会放在结构体的末尾， 作为可变长度的入口。（**数组是唯一一个允许越界访问的载体**）

```C
struct node
{
    int a;
    char b ;
    float c ;
    ..
    ...
    int len ;
    char arr[0] ;
}

struct node *p = malloc(sizeof(struct node) + 20 );  // + 20 就是在原有的基础上增加20字节
p->len = 20 ; // 设置额外增长的长度为 20 
strncpy(p->arr , 20 , "Hello FZ2105");
p->arr
```

![image-20240430111352731](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430111352731.png)

**变长数组：**

概念： 定义是， 使用一个变量作为数组的长度（元素的个数）。

重点： **变长数组并不是说在任意时候他的长度可以随意变化， 实际上只是在定义之前数组的长度是未知的有一个变量来决定， 但是定义语句过后变长数组的长度由定义那一刻变量的大小来决定。**

```
int a = 200 ; // a 作为一个普通的变量 ，  200 则可以作为arr 的长度
a = 99 ; // 99 可以作为 arr 的长度

int arr[a]; // a 当前是 99  ， 因此数组arr 的长度已经确定为 99 
    //从此以后该数组的长度已经确定为99 不会再变换

a = 10 ;  // a = 10 并不会影响数组的长度
```

注意：

1. 因为数组的长度未确定， 因此它不允许初始化。
2. 在使用的时候可以通过该变长数组来有限的节省内存空间。

多维数组：

概念：	数组内部的成员也是数组

`                int  a [2][3] ;              `

定义与初始化：

```
int arr[2][3] = { {1,2,3} , { 4,5,6} };
int arr1[2][3] = { 1,2,3,4,5,6};
```

如何引用：

```
arr[0] [0] = 100 ; // 数组：（通过下标来访问）
*(*(arr+0)+0) = 100 ; // 通过指针偏移来访问
```

## 内存管理

**C语言进程的内存布局：**

程序：就是我们写好的代码并编译完成的那个二进制文件，它被存放与磁盘中，它是死的。

进程：把磁盘中的二进制文件"拷贝"到内存中取执行它，让运行起来，它是活的。

所有的程序被执行起来之后，系统会为他分配各种资源内存，用来存放该进程中用到的各种变量、常量、代码等等。这些不容的内容将会被存放到内存中不同的位置 （区域），不同的内存区域他的特性是右差别。

每一个进程所拥有的内存都是一个虚拟的内存，所谓的虚拟内存是用物理内存中映射（投影）而来的，对于每一个进程而言所有的虚拟内存布局都是一样的。**让每个进程都以为自己独自拥有了完整的内存空间**。

物理内存（Physical Memory）

虚拟内存（Virtual Memory）

![image-20240430161027735](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430161027735.png)

虚拟内存的布局（区域）：

栈 （stack）

堆（heap）

数据段

代码段

![image-20240430161101007](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430161101007.png)

![image-20240430161114319](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430161114319.png)

栈空间：

![image-20240430161146094](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430161146094.png)

栈空间的特点：

- 空间非常有限，尤其在嵌入式的环境下，因此我们应该尽可能少去使用栈空间内存，特别是要存放比较大的数据。

```
ulimit -a 
stack size              (kbytes, -s) 8192   当前64位系统 默认只有8M栈内存
```

- 每当一个函数被调用的时候， 栈空间会向下增长一段，用来存放该函数的局部变量
- 当一个函数退出的时候 ， 栈空间会向上回缩一段，该空间的所有权将归还系统
- 栈空间的分配与释放，用户是无法干预的， 全部由系统来完成。

**静态变量：**

在C语言中有两种静态变量

**全局变量： 定义在函数体之外的变量**

**静态的局部变量： 定义在函数体内部而且被 static 修饰的变量**

```
int c ;   // 在函数体之外，属于全局变量 --> 静态变量

int  func(int argc , char * argv[] )  // argc argv 属于main函数的局部变量
{
    int a ;   // 局部变量
    static int b ;  // 静态局部变量
    //  静态的局部变量 初始化语句只会被被执行一次
        
}
```

为什么会有静态变量？

- 当我们需要把一个变量引用到不同的函数内部甚至不在同一个.c 文件中，可以全局变量来实现。
- 当我们需要一个局部变量用来记录某个值， 并希望这个值不会被重新初始化的情况下可以使用静态的局部变量。

**数据段与代码段：**

数据段有哪些内容：

- .bss 未初始化的静态数据 ， 会被自动初始化为0 
- .data 已初始化的静态数据
- .rodata 存放常量数据 "Hello Even"  , 不允许修改的（只读）

代码段中有那些内容：

- 用户的代码 （比如我们自己写函数func.....main）
- 系统初始化代码，由编译器为我们添加的

![image-20240430161448648](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430161448648.png)

![image-20240430161453166](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430161453166.png)

数据段的特点：

- 没有初始化则自动初始化为0 
- 初始化语句只会被执行一次（在程序被加载的过程中已经初始化结束）
- 静态数据的内存从程序运行之初就存在，直到程序退出才会被释放（与进程共生死）

**堆内存：**

堆内存，又称为动态内存、自由内存、简称堆。唯一一个由开发者随意分配与释放的内存空间。具体的申请大小，使用的时常都是由我们自己来决定。

堆内存空间的基本特性：

- 相对与栈空间来说 ，堆空间大很多（堆的大小受限于物理内存），系统不会对对空间进行限制。
- 相对与栈空间来说， 堆内存是从下往上增长的。
- 堆空间的内存称为匿名内存， 不像栈空间那样有个名字，只能通过指针来访问
- 堆空间内存的申请与释放都是由用户自己完成，用户申请之后需要手动去释放，直到程序退出。

如何申请堆空间内存：

malloc  （只是申请内存而已，并不会/清空）

```
malloc (向系统申请内存)
    头文件：
        #include <stdlib.h>
    函数原型：
        void *malloc(size_t size);
    参数分析：
        size -->  需要申请的内存 （字节为单位）
    返回值：
        成功 返回一个指向成功申请到内存的指针（入口地址）
       失败  返回 NULL  
```

calloc  （会把内存进行清空）

```
calloc  (向系统申请内存)
    头文件：
        #include <stdlib.h>
    函数原型：
        void *calloc(size_t nmemb, size_t size);
    参数分析：
        nmemb -- > N 块内存（连续的）
        size  -- > 每一块内存的大小尺寸
    返回值：
        成功 返回一个指向成功申请到内存的指针（入口地址）
       失败  返回 NULL 
```

```
realloc (重新申请空间)
    头文件：
        #include <stdlib.h>
    函数原型：
        void *realloc(void *ptr, size_t size);
    参数分析：
        ptr  --> 需要 扩容/缩小 的内存的入口地址
        size --> 目前需要的大小
    返回值：
        成功 返回修改后的地址
        失败 NULL 
```

清空：

bzero

memset 

如何释放：

free 

```
free(释放堆内存)
    头文件：
        #include <stdlib.h>
    函数原型：
        void free(void *ptr);
    参数分析：
        ptr  -->  需要释放的内存的入口地址
    返回值；
        无
```

示例1 malloc：

```C
 int * p = (int *)malloc( 10 * sizeof(int) );  // 申请一个可以存放10个整型的 堆空间 

    for (int i = 0; i < 10 ; i++)
    {
        *(p+i) = i;
    }

    for (int i = 0; i < 10 ; i++)
    {
        printf("*(p+%d):%d\n" ,i,  *(p+i));
    }

    //   &p 打印的是栈空间地址     p中所存放的地址为堆空间地址
    printf("&p:%p--->%p\n" , &p , p );
    

    //不再使用该堆空间时需要释放
    free(p);
```

示例2 calloc:

```
 //           申请10块连续的内存  ，每一块为 整型大小
    int * p = calloc( 10 , sizeof(int));

    for (size_t i = 0; i < 10; i++)
    {
        *(p+i) = i+ 998 ;
    }
    
    for (int i = 0; i < 10; i++)
    {
       printf("*(p+%d):%d\n" , i , *(p+i));
    }

    //不再使用该堆空间时需要释放
    free(p);
```

示例 3 realloc

```
//           申请10块连续的内存  ，每一块为 整型大小
    int * p = calloc( 10 , sizeof(int));

    for (size_t i = 0; i < 10; i++)
    {
        *(p+i) = i+ 998 ;
    }
    
    for (int i = 0; i < 10; i++)
    {
       printf("*(p+%d):%d\n" , i , *(p+i));
    }


    printf("重新分配前p:%p\n" , p );

    // 如果重新申请内存需要另找宝地 ， 那么 原本的地址会被释放掉
    int * p1 = realloc( p , 128);
    p = NULL ;// 让p不要称为野指针， 需要让它指向NULL 
     
    printf("重新分配后p1:%p\n" , p1 );
    
    //realloc 会帮我们把原有的数进行搬运 
    for (int i = 0; i < 10; i++)
    {
       printf("*(p1+%d):%d\n" , i , *(p1+i));
    }


    //不再使用该堆空间时需要释放
    free(p1);
```

总结：

- 使用malloc 申请内存时 ， 内存中的值时随机值 ， 可以使用bzero清空
- calloc   申请内存时 ， 内存中的值会被初始化为 0 
- free  只能释放堆空间的内存，不能释放其它区域的内存

释放内存的含义：

- 释放内存仅仅意为着，当前内存的所有权交回给系统
- 释放内存并不会清空内存的内容
- 也不会改变指针的指向，需要手动把指针指向NULL ，不然就成野指针了

static  修饰的作用：

修饰局部变量：  使得局部变量的存放位置从栈空间改为数据段

修饰全局变量： 可以缩小全局变量的可见范围，由原本的拷文件可见变为本文可见，可以使得重名概率降低

修饰函数：   使得函数为本文将可见....

## 指针进阶

**char 型指针：**

从本质上来看，字符指针其实就是一个指针而已， 只不过该指针用来指向一个字符串/字符串数组。

`                char *  msg = "Hello Even" ;              `

**多级指针：**

- 如果一个指针p1 它所指向的是一个普通变量的地址，那么p1就是一个一级指针
- 如果一个指针p2 它所指向的是一个指针变量的地址，那么p2就是一个二级指针
- 如果一个指针p3 它所指向的是一个指向二级指针变量的地址，那么p3就是一个三级指针

```
int  a = 100 ;
int * p1 = &a ; // 那么p1就是一个一级指针
int ** p2 = &p1 ; // 那么p2就是一个二级指针
int *** p3 = &p2 ; // 那么p3就是一个三级指针
```

![image-20240430162543147](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430162543147.png)

**指针的万能拆解方法：**

对于任何的指针都可以分为两部分：

第一部分： 说明他是一个指针 （*p）

第二部分： 说用它所指向的内容的类型 （*p）以外的东西

```
char  * p1 ;  // 第一部分： * p1  ， 第二部分 char 说明p1 指向的类型为char 
char **p2 ; // 第一部分： * p2  ，第二部分 char * 说明p2 指向的类型为char *
int **p3 ; // 第一部分： * p3  ，第二部分 int * 说明p3 指向的类型为int *  
char (*p4) [3] ;  // 第一部分： * p4 , 第二部分 char  [3] , 说明p4 指向一个拥有3个元素的char 数组
char （*p5） (int , float) ; // 第一部分： * p5, 第二部分char  (int , float) ， 说明 
                // 说明该指针指向一个 拥有char类型返回， 并需要 一个int  和 float 参数的函数
void *(*p6) (void *);   //第一部分： * p6, 第二部分 void *   (void *)
            // 说明p6 指向一个 拥有 void * 返回并需要一个void * 参数的函数 函数指针）
```

总结：

- 以上指针 p1 p2 p3 p4 p5 p6 本质上都是指针，因此它们的大小都是 8字节（64位系统）
- 以上指针 p1 p2 p3 p4 p5 p6 本质上都是指针， 唯一的不容是它们所指向的内容的类型不同

**void 型指针：**

概念： 表示该指针的类型暂时是不确定

要点：

-  **void 类型的指针，是没有办法直接索引目标的。必须先进行强制类型转换。**
-  **void 类型指针，无法直接进行加减运算。**

void关键字的作用：

- 修饰指针，表示该指针指向了一个未知类型的数据。
- 修饰函数的参数列表， 则表示该函数不需要参数。
- 修饰函数的返回值，则表示该函数没有返回值。

```
void * p =  malloc(4) ; // 使用malloc 来申请 4个字节的内存， 并让p来指向该内存的入口地址

*(int *)p = 250 ; // 先使用(int*) 来强调p是一个整型地址 ，然后再解引用
printf("*p:%d\n", *(int*)p);// 输出时也应该使用对应的类型来进行输出

*(float*)p = 3.14 ;
printf("*p:%f\n", *(float*)p);
```

注意：

以上写法 void * p ， 在实际开发中不应该出现。以上代码只是为了说明语法问题。

**const 指针：**

- const修饰指针有两种效果：

- - 常指针  修饰的是**指针本身**， 表示该指针变量无法修改

`                char * const p ;              `

```
char arr [] = "Hello" ;
char msg [] = "Even" ; 
char * const p = arr ;

// p = msg ; // p 被const 所修改， 
        //说明P是一个常量 ，他的内容（所指向的地址）无法修改
*(p + 1 ) = 'E' ; // p所指向的内容是可以通过p 来修改 （只要保持P所指向的地址不变即可）
printf("%s\n" , p );
```

- - 常目标指针 修饰的是**指针所指向的目标**，表示无法通过该指针来改变目标的数据

```
char  const * p ;
const char  * p ;
```

```
char arr [] = "Hello" ;
char msg [] = "Even" ; 

const char * p1 = arr ; 
p1 = msg ;  // p1 的指向是可以被修改的
// *(p1+1) = 'V' ; // 常目标指针， 不允许通过该指针来它所指向的内容

*(msg+1) = 'V' ; // 虽然p1不能修改所指向的内容， 但是内容本身是可以被修改的

printf("%s\n" , p1 );
```

总结：

- 常指针并不常见。
- 常目标指针，在实际开发过程中比较常见，用来限制指针的权限为 **只读**

![image-20240430163107215](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430163107215.png)

## memory-test

```C
// TEST1
// 把p修改为二级指针， 用来接收 指针str的地址
void GetMemory1(char **p) // p ==== NULL 
{
    *p = (char *)malloc(100); // 向系统申请100个字节的堆空间， 让p 指向该区域
}

void Test1(void) 
{
    char *str = NULL;
    GetMemory1(&str);  /// str ==== NULL 
    // 经过GetMemory1 的操作后 str的指向依然没有变换还是指向NULL 
    strcpy(str, "hello world");  // 提示： 拷贝字符串， 把"hello world" 拷贝到str 所指向的内存空间中
    // 拷贝函数出现段错误 
    
    printf("%s\n"  , str);
}
```

```
// TEST2
char *GetMemory2(void)
{ 
    // 数组 p 所存放的位置为 栈空间， 当函数 GetMemory2 退出返回时， 该区域会被系统回收
    // 不应该返回该内存中的地址
    // 可以使用 static 来修饰该数组， 使其的内存区域改为数据段
    char p[] = "hello world";
    return p;
}
void Test2(void)
{
    char *str = NULL;
    str = GetMemory2(); 
    printf("TEST-2:%s\n",str);
}
```

```
// TEST3
char *GetMemory3(void)
{ 
    // 直接返回 常量区的内存地址 ， 注意该区域只读
     return "hello world";
}
void Test3(void)
{
    char *str = NULL;
    str = GetMemory3(); 
    printf("TEST-3:%s\n",str);
}
```

```
// TEST4   就是第一个的改版
void GetMemory4(char **p, int num)
{
    *p = (char *)malloc(num);
}
void Test4(void)
{
    char *str = NULL;
    GetMemory4(&str, 100);
    strcpy(str, "hello"); 
    printf("TEST-04:%s\n",str); 
    free(str);
}
```

```
// TEST5
void Test5(void)
{
    char *str = (char *) malloc(100);
    strcpy(str, "hello");
    free(str);  // 把堆空间进行释放， 但是str依然指向堆空间的位置
    if(str != NULL)
    {
       strcpy(str, "world");  // 虽然可以拷贝， 但是属于非法访问
       printf("TEST-5:%s\n",str); 
    }
}
```

```
// TEST6
void Test6()
{
    char *str=(char *)malloc(100);
    strcpy(str, "hello");
    str+=6; // 
    
    if(str!=NULL)
    {
        strcpy(str, "world");
        printf("TEST-6:%s\n" ,str); // 输出 wrold 
        printf("TEST-6:%s\n" ,str-=6); // 输出 Hello 

    }

    free(str); // 释放的时候必须使用 最初申请得到的那个首地址（入口地址）
}
```

## 数组与指针理解题

![image-20240430171817966](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430171817966.png)

![image-20240430171823253](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430171823253.png)

![image-20240430171827849](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430171827849.png)

![image-20240430171832006](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430171832006.png)

## 函数

函数入门：

在C语言的编程中，其实用到很多的函数，而每一个函数就可以理解为一个独立的模块， 因此C语言也称为模块化编程。

我们封装函数应该尽可能左到：低耦合，高内聚

![image-20240430171908175](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430171908175.png)

对于函数的使用者来说，应该尽可能简单地去使用该函数接口，使用者只管往函数中输入需要的数据， 通过该函数获得一个结果即可。

**函数的定义：**

函数头： 函数对外公开的接口信息。 比如：void *calloc(size_t nmemb, size_t size);

- 函数的返回值 ， 该函数运行结束后会返回什么东西给你 ， 比如： void *
- 函数名， 命名规则跟变量一致。应该尽量顾名思义。比如： calloc
- 参数列表，告诉用户该函数需要输入的数据以及类型，有可能有多个也可能没有 ， 比如(size_t nmemb, size_t size)

语法：

```
返回值类型   函数名 ( 参数1 , 参数2 ,参数3 , ... , 参数N )
{
    // 函数体
    
    return 返回值 ;
}
```

示例：

```
#include <stdio.h>

// 函数声明
int add ( int , int ); // 函数声明中可以把形参的名字省略

int main(int argc, char const *argv[])
{
    int x = 100 ;
    int y = 250 ;
    int tmp = 0 ;

    // 调用add函数， 把 x 和 y 的值 传递过去，
    //  x , y 是实参， 作为形参 a , b 初始值  
    //   a = x  , b = y ;
    // 使用 tmp 来接受 add函数的返回值 
    tmp = add(x,y);

    printf("x + y = %d \n" , tmp );

    return 0;
}

// 设计一个函数 ，接收 两个整型参数， 并返回 它们的和
int    add ( int a , int b )  //  a , b 属于函数add 的局部变量
{
    int tmp = a + b ;
    return tmp ;
}
```

总结：

- 当函数的返回值类型为 void 的时候， 表示该函数不会有返回的值
- 当参数列表中为void的时候， 表示该函数不需要参数
- 当返回值为具体的类型的时候 ， 函数的结尾就应该返回一个对应类型的数据
- return 只能够携带一个数据进行返回 
- 当返回值类型为 void 的时候，可以不写return,如果写的话一般就直接写 return ;

**形参与实参：**

概念： 	

函数调用的时候传递的值，称为实参 max(123.034 , 'C' , "87") ; 

函数定义当中出现的参数列表，称为形参 max(float  a , char b , char * c)

实参与形参的关系：

- 实参与形参应该是一一对应的。(顺序+类型)
- 形参的值是由实参进行初始化。
- 形参与实参是处于两个完全不相关的栈空间中。彼此是独立的

**函数调用的过程：**

函数调用的时候，进程会进行上下文切换，当指向完被调用的函数后,将会切换会被调用的语句，继续往下执行。

**局部变量与栈内存：**

局部变量：	被函数体的一对大括号所包含的变量，称为局部变量（在函数体内部定义）

局部变量的特点：

- 属于函数内部的变量， 所存储的位置是该函数所拥有的栈空间
- 局部变量不会被其它函数所访问，因此不同的函数内部可以拥有完全一样的两个变量名字， 但是从内存来看它们是完全独立的。
- 当函数退出的时候， 局部变量所占用的内存，将会被系统回收，因此局部变量也称为临时变量。
- 形参当中的变量，虽然没有在大括号的范围内， 但是也是属于该函数的局部变量。

栈内存的特点：

- 当有一个函数被调用的时候，栈内存将会增长一段， 用来存放该函数的局部变量。
- 当函数退出时，他所占用的栈内存将会被释放回收。
- 系统分配栈空间遵循从上往下增长的原则。
- 栈空间的内存相对来说比较少， 不建议用来存放大量的数据。

![image-20240430172220638](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240430172220638.png)

## 特殊函数

**静态函数**

背景： 普通的函数都是跨文件可见的，也就是比如a.c里面有个函数swap(), 在b.c中也可以调用该函数。

静态函数：只能够在当前定义的文件中使用，称为静态函数

语法：

```
static   int  func (int , int b )
{
    // 函数体   
   
} 
```

注意：

- 静态函数用来缩小可见范围，减少与其它文件中同名函数冲突的问题
- 静态函数一般会定义在头文件中， 然后被需要使用该函数的源文件包含即可。

**递归函数：**

递归函数的概念： 如果一个函数的内部，包含了对自己的调用则称为递归函数。

递归的问题：

1. 阶乘
2. 幂运算
3. 字符反转

要点：

- 只有可以被递归的问题，才可以使用递归函数来实现。
- 递归函数必须有一个可以直接退出的条件，否则会进入‘无限’递归，最后导致栈溢出。
- 递归函数包含了两个过程： 逐渐递进 ， 逐步回归。

总结：

递归的时候函数的栈空间，会随之从上往下不断增长，栈空间会越来越少， 直到耗尽或者开始返回。

在一层一层递进的时候，问题的规模会随之缩小，当达到某一个条件的时候，则开始一层一层回归。

**函数指针：**

指向一个函数的指针，称为函数指针；

定义语法：

`                int  (*p)  (int , float ) ;              `

例子：

```
int Printf( int a , float f )
{


    printf("a:%d , f:%f\n" , a , f );

    return 0 ;
}

int main(int argc, char const *argv[])
{
    // 定义一个函数指针， 名字为 p 。它指向的函数 有一个整型返回值
    // 需要 一个整型参数 以及 浮点参数
    int  (*p) (int , float ) ;
    p = Printf ;  //  函数名其实也是这个函数的入口地址

    Printf(10 , 3.14);

    p(56 ,9.8888);

    return 0;
}
```

**指针函数：**

一个返回指针的函数，就称为指针函数。

```
int * func(int a , int b) 
{
    int kk ;
    /*
    ..
    ...
    */
    
    return &kk ;
}
```

**回调函数：**

概念：**函数实现方不方便调用该函数，而由接口提供方来调用该函数**，就称为回调函数。

例子：

```
#include <stdio.h>
#include <signal.h>



void func(int num )
{
    printf("当前收到  3 号信号 ， 军师让我蹲下 !!\n");
}


int test( int num  ,  void (*p)(int)  )
{

    for (size_t i = 0; i < num ; i++)
    {
        printf("num:%d\n" , num-- );
        if (num == 50 )
        {
            p(1);
        }
        
        
    }
    
    return 0 ;
}

int main(int argc, char const *argv[])
{
    void (*p)(int); // 定义一个函数指针
    p = func ; // 让指针p 指向函数  func 


    test( 100 , p  );
    

    return 0;
}
```

```
#include <stdio.h>
#include <signal.h>



void func(int num )
{
    printf("当前收到  3 号信号 ， 军师让我蹲下 !!\n");
}


int main(int argc, char const *argv[])
{
    void (*p)(int); // 定义一个函数指针
    p = func ; // 让指针p 指向函数  func 

    // 设置进程捕获信号 ，如果信号值 为 3的时候 ， 会自行调用 p 所指向的函数 （代码/指令）
    signal( 3 , p );

    while(1);     
    

    return 0;
}

```

总结：

- signal 函数是一个用于捕获信号的函数， 当他捕获到指定信号的时候则会执行用户所提供的函数。
- 由于signal函数是内核提供的函数，修改内核的代码不现实， 因此它提供的接口是一个函数指针，只要某个条件满足则会自动执行我们所给的函数。
- 使得不同软件模块的开发者的工作进度可以独立出来，不受时空的限制，需要的时候通过约定好的接口（或者标准）相互契合在一起

**内联函数：**

不适用内联函数的情况下，有可能某一个函数被多次重复调用则会浪费一定的时间在调用的过程中（现场保护+恢复）

![image-20240502125621974](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502125621974.png)

如果使用内联函数就相当与把需要调用的函数的内容（指令）拷贝到需要调用的位置，可以节省函数调用的过程中浪费的时间

![image-20240502125630922](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502125630922.png)

语法：

与普通函数区别不大， 只是在前面增加了函数的修饰 inline 

```
inline int max_value(int x, int y);
```

注意：

内联函数在提高运行效率的过程中，消耗了更多的内存空间。

**变参函数：**

指参数的个数以及类型是可以根据实际y应用有所变化的。

分析打印函数如何实现变参：

`                printf("%d%c%lf", 100, ‘x’, 3.14);              `

如上代码中， 各个参数入栈的顺序是从右往左进行的。

![image-20240502125730557](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502125730557.png)

## 字符串处理

**strstr**

```
strstr ( 在一字符串中查找指定的字符串 )
    头文件:
        #include <string.h>
    定义函数:
        char *strstr(const char *haystack, const char * needle);
    参数分析：
        haystack  -->  需要查找的源字符串 （ "Hello Even" ） 
        needle --> 需要查找的字符串 ("Even") 查找到的内容
    返回值：
        成功 返回第一次出现的地址
        失败  返回0 NULL 
```

**strlen** 

```
strlen ( 返回字符串长度 )
    头文件:
        #include <string.h>
    定义函数:
        size_t strlen (const char *s);
    参数分析：
        s --> 需要计算长度的字符串
    返回值：
        成功 返回字符串的字符数， 不包括结束字符"\0"
```

**strtok**

```
strtok ( 分割字符串 )
    头文件:
        #include <string.h>
    定义函数:
        char * strtok(char *s, const char *delim);
    参数分析：
        s -->  需要分割的字符串 （需要可读写的内存地址）
        delim -->  分隔符（可以有多个分隔符）
    返回值：
        返回下一个分割后的字符串指针, 
        如果已无从分割则返回 NULL.
```

注意：

strtok 第一次使用需要传递指针p， 如果想要从当前位置继续进行分割则指针p 必须写NULL 

**strchr**

```
strchr ( 查找字符串中第一个出现的指定字符 )
strrchr   // R
    头文件：
        #include <string.h>
    定义函数：
        char * strchr (const char *s, int c);  // 从左往右找
        char * strrchr(const char *s, int c); // 从右往左找
    参数分析：
        s --> 需要遍历寻找的字符串 （只读地址即可）
        c --> 需要查找的字符 （虽然是个整型，但是实质是是一个无符号的字符类型）
    返回值：
        指定的字符则返回该字符所在地址, 
        否则返回 0.
```

**strcpy**

```
strcpy ( 拷贝字符串)
strncpy  【 推荐使用 】
 
    头文件:
        #include <string.h>
    定义函数:
        char *strcpy(char *dest, const char *src);   // 没有控制拷贝长度，有可能会溢出
        char * strncpy(char *dest, const char *src, size_t n); // 需要填写拷贝长度， 可以减少溢出
    参数分析：
        dest --> 拷贝字符串的目标地址 （可读写的内存）
        src --> 需要拷贝的字符串 （只读即可）
        n   -->  控制需要拷贝的长度
    返回值：
        成功 参数 dest 的字符串起始地址
```

**strcmp**

```
strcmp ( 比较字符串 )
    头文件：
        #include <string.h>
    定义函数：
        int strcmp(const char *s1, const char *s2);
        int strncmp(const char *s1, const char *s2, size_t n);
    参数分析：
        s1  --> 需要比较的字符串1  
        s2  --> 需要比较的字符串2
        n  --> 需要比较的前 N 个字符
    返回值：
        成功 则返回0 表示两个字符串完全相同
        失败 则返回 第一给不同字符的差值
```

**strcat**

```
strcat ( 连接两字符串)
    头文件:
        #include <string.h>
    定义函数:
        char *strcat(char *dest, const char *src);
        char * strncat(char *dest, const char *src, size_t n);
    参数分析：
        dest --> 目标地址， 拷贝到该字符串后面
        src  --> 源地址， 需要拷贝的内容
        n   --> 需要拷贝的字符数
    返回值：
        返回参数 dest 的字符串起始地址
```

**sprintf**

```
sprintf ( 格式化字符串复制 )
    头文件：
        #include <stdio.h>
    定义函数：
        int sprintf(char *str, const char * format, ...);
    参数分析：
        str --> 复制后的字符串（目标地址， 必须可读写）
        format --> 格式化控制参数（参考打印函数）
        ...  --> 可变参数
    返回值：
        成功则返回参数 str 字符串长度, 
        失败则返回-1, 错误原因存于 errno 中.
```

**bzero**

```
bzero ( 将一段内存内容全清为零 )
    头文件:
        #include <string.h>
    定义函数:
        void bzero(void *s, int n);
    参数分析：
        s --> 需要清空的内存的入口地址
        n --> 需要清空的字节数
    返回值：
        无
```

**memset**

```
memset ( 将一段内存空间填入某值 )
    头文件：
        #include <string.h>
    定义函数：
        void * memset(void *s, int c, size_t n);
    参数分析：
        s --> 需要设置的内存的入口地址 （可读写）
        c --> 需要填入的字符的ASCII值
        n --> 需要填入的字节数
    返回值：
        返回指向 s 的指针. 
```

注意：

该函数是按字节进行写入指定值， 因此注意应该按字节来访问。

这个函数不是很适合用来清空内存， 推荐使用bzero 

**memcpy**

```
memcpy ( 拷贝内存内容)
    头文件:
        #include <string.h>
    定义函数:
        void * memcpy (void * dest, const void *src, size_t n);
        void *memccpy(void *dest, const void *src, int c, size_t n);
    参数分析：
        dest --> 目标地址 (可读写的内存地址)
        src --> 源数据地址
        c --> 
        n --> 需要拷贝的字节数
    返回值：
        返回指向 dest 的指针
```

示例：

```
char * s1 = "Hello GZ2123" ;
    char * s2 = calloc(128 , 1 ) ; 
    memset(s2 , 'A', 128 );


    // strlen 计算的长度并不包括结束符， 因此应该+1让函数把结束符一起拷贝     
    memcpy(s2 , s1 , strlen(s1)+1);

    printf("%s\n" , s2) ;

```

注意:

与strcpy 不同的地方在于，strcpy在遇到结束符时停止拷贝， 而memcpy 则是会完整拷贝内存中的前N字节，不会因为遇到结束符而停止。

memccpy 在复制的过程中会顺便检查是否出现了 字符  c ， 如果出现， 则停止拷贝（拷贝C之后），后面的内容就没有继续拷贝。

《拷贝到字符C为止， 最多拷贝n个字节》

**memcmp**

```
memcmp ( 比较内存内容 )
    头文件：
        #include <string.h>
    定义函数：
        int memcmp (const void *s1, const void *s2, size_t n);
    参数分析：
        s1 --> 字符串1 
        s2 --> 字符串2
        n -->  需要比较的前N字节
    返回值：
        成功 返回0 表示两个内容一致
        失败 返回之间的差值
```

**errno**  

概念： 属于一个全局变量 ，不需要我们自己定义。但是需要包含一个头文件

`                #include <errno.h>              `

```
strerror ( 返回错误原因的描述字符串)
    头文件:
        #include <string.h>
    定义函数:
        char * strerror(int errnum);
    参数分析：
        errnum --> 错误号码
    返回值：
        返回描述错误原因的字符串指针
```

处理返回值

```
perror ( 打印出错误原因信息字符串 )
    头文件:
        #include <stdio.h>
    定义函数:
        void perror(const char *s);
    参数：
        s --> 用户自定义的错误提示
    返回值：
        无
```

```
for (size_t i = 0; i < 134; i++)
{
    printf("errno:%d:msg:%s\n" , i , strerror(i));  // 遍历输出所有的错误号码对应的信息
}
    
errno = 3 ; // 手动修改错误号码的值
perror("左勾拳失败"); // 根据错误号码之直接输出信息
```

## 常见错误码

```
errno:0:msg:Success
errno:1:msg:Operation not permitted  
errno:2:msg:No such file or directory
errno:3:msg:No such process
errno:4:msg:Interrupted system call  
errno:5:msg:Input/output error       
errno:6:msg:No such device or address
errno:7:msg:Argument list too long   
errno:8:msg:Exec format error        
errno:9:msg:Bad file descriptor
errno:10:msg:No child processes
errno:11:msg:Resource temporarily unavailable
errno:12:msg:Cannot allocate memory
errno:13:msg:Permission denied
errno:14:msg:Bad address
errno:15:msg:Block device required
errno:16:msg:Device or resource busy
errno:17:msg:File exists
errno:18:msg:Invalid cross-device link
errno:19:msg:No such device
errno:20:msg:Not a directory
errno:21:msg:Is a directory
errno:22:msg:Invalid argument
errno:23:msg:Too many open files in system
errno:24:msg:Too many open files
errno:25:msg:Inappropriate ioctl for device
errno:26:msg:Text file busy
errno:27:msg:File too large
errno:28:msg:No space left on device
errno:29:msg:Illegal seek
errno:30:msg:Read-only file system
errno:31:msg:Too many links
errno:32:msg:Broken pipe
errno:33:msg:Numerical argument out of domain
errno:34:msg:Numerical result out of range
errno:35:msg:Resource deadlock avoided
errno:36:msg:File name too long
errno:37:msg:No locks available
errno:38:msg:Function not implemented
errno:39:msg:Directory not empty
errno:40:msg:Too many levels of symbolic links
errno:41:msg:Unknown error 41
errno:42:msg:No message of desired type
errno:43:msg:Identifier removed
errno:44:msg:Channel number out of range
errno:45:msg:Level 2 not synchronized
errno:46:msg:Level 3 halted
errno:47:msg:Level 3 reset
errno:48:msg:Link number out of range
errno:49:msg:Protocol driver not attached
errno:50:msg:No CSI structure available
errno:51:msg:Level 2 halted
errno:52:msg:Invalid exchange
errno:53:msg:Invalid request descriptor
errno:54:msg:Exchange full
errno:55:msg:No anode
errno:56:msg:Invalid request code
errno:57:msg:Invalid slot
errno:58:msg:Unknown error 58
errno:59:msg:Bad font file format
errno:60:msg:Device not a stream
errno:61:msg:No data available
errno:62:msg:Timer expired
errno:63:msg:Out of streams resources
errno:64:msg:Machine is not on the network
errno:65:msg:Package not installed
errno:66:msg:Object is remote
errno:67:msg:Link has been severed
errno:68:msg:Advertise error
errno:69:msg:Srmount error
errno:70:msg:Communication error on send
errno:71:msg:Protocol error
errno:72:msg:Multihop attempted
errno:73:msg:RFS specific error
errno:74:msg:Bad message
errno:75:msg:Value too large for defined data type
errno:76:msg:Name not unique on network
errno:77:msg:File descriptor in bad state
errno:78:msg:Remote address changed
errno:79:msg:Can not access a needed shared library
errno:80:msg:Accessing a corrupted shared library
errno:81:msg:.lib section in a.out corrupted
errno:82:msg:Attempting to link in too many shared libraries
errno:83:msg:Cannot exec a shared library directly
errno:84:msg:Invalid or incomplete multibyte or wide character
errno:85:msg:Interrupted system call should be restarted
errno:86:msg:Streams pipe error
errno:87:msg:Too many users
errno:88:msg:Socket operation on non-socket
errno:89:msg:Destination address required
errno:90:msg:Message too long
errno:91:msg:Protocol wrong type for socket
errno:92:msg:Protocol not available
errno:93:msg:Protocol not supported
errno:94:msg:Socket type not supported
errno:95:msg:Operation not supported
errno:96:msg:Protocol family not supported
errno:97:msg:Address family not supported by protocol
errno:98:msg:Address already in use
errno:99:msg:Cannot assign requested address
errno:100:msg:Network is down
errno:101:msg:Network is unreachable
errno:102:msg:Network dropped connection on reset
errno:103:msg:Software caused connection abort
errno:104:msg:Connection reset by peer
errno:105:msg:No buffer space available
errno:106:msg:Transport endpoint is already connected
errno:107:msg:Transport endpoint is not connected
errno:108:msg:Cannot send after transport endpoint shutdown
errno:109:msg:Too many references: cannot splice
errno:110:msg:Connection timed out
errno:111:msg:Connection refused
errno:112:msg:Host is down
errno:113:msg:No route to host
errno:114:msg:Operation already in progress
errno:115:msg:Operation now in progress
errno:116:msg:Stale file handle
errno:117:msg:Structure needs cleaning
errno:118:msg:Not a XENIX named type file
errno:119:msg:No XENIX semaphores available
errno:120:msg:Is a named type file
errno:121:msg:Remote I/O error
errno:122:msg:Disk quota exceeded
errno:123:msg:No medium found
errno:124:msg:Wrong medium type
errno:125:msg:Operation canceled
errno:126:msg:Required key not available
errno:127:msg:Key has expired
errno:128:msg:Key has been revoked
errno:129:msg:Key was rejected by service
errno:130:msg:Owner died
errno:131:msg:State not recoverable
errno:132:msg:Operation not possible due to RF-kill
errno:133:msg:Memory page has hardware error

errno:134:msg:Unknown error 134
```

## 作用域

**概念：**

C语言中所有的标识符（变量/名字）都有可见范围。为了搞清楚这些标识符的可见范围我们来研究一下，而可见分为也被称为作用域。

在软件开发的过程中应该尽可能缩小标识符的可见范围，可以尽可能的降低同名冲突的问题。

**函数声明的作用域：**

概念： 一般写在头文件内部， 或者源文件的头部。用来告诉编译器函数的模型。

```
main.c

// 函数声明
bool swap( int *  , int *  );
int max( int a , int b , int c );
```

作用域：

只是当前文件可见。虽然写在函数体外但是并不是全局的。

**函数头中的作用域：**

```
int max( int a , int b , int c ) // 函数头
{
    // 函数体
}
```

作用域：

max 默认是全局可见的

例外情况 被static 修饰则本文件可见

变量 a, b, c 是属于该函数的局部变量， 因此作用域在函数体内部

**局部作用域：**

概念： 在代码块内不定义的变量 ，可见范围从定义语句开始直到该代码块的右括号右边结束 }

示例：

```
{
    int b = 250 ;

    {
        int c = 399 ;// c 作用域开始 
       // b =250
        int b = 249;
        
    }// c 作用域的结束
    // b =250    
    printf("c:%d\n" , c) ; // 已经离开了c的作用域因此不能使用
}

例如实际中：
    for (size_t i = 0; i < argc ; i++)
    {
        printf("argv[%ld]:%s\n" , i , argv[i]);

    }

    printf("%d" , i ); // i未定义， 已经离开的I的可见范围
```

注意：

- 代码块指的是一对  {   } 所括起来的区域
- 代码块可互相嵌套，外层的标识符，可以被内层识别， 反之则不行
- 在内码块内部定义的标识符 ， 在外面其它的代码块中是不可见，因此称为局部作用域

**全局作用域：**

概念： 在代码块的外部定义，他的可见范围是可以跨文件可见的。

```
int global ;  // 变量 global 就是跨文件可见的全局变量

int main(int argc, char const *argv[])
{
    int a = 1 ;
    int b = 250 ;
}
```

注意：

在函数体外部定义

不可以被static修饰， 修饰之后就变成本文件可见（可见范围被缩小）

**作用域的临时掩盖：**

如果有多个不同的作用域互相嵌套，小的作用域的作用范围会临时掩盖大的作用域（标识符名字相同）。临时失去大作用域的值。

```
int a = 1 ;

{
    printf("1a:%d\n" , a);// 输出 为 1  ， 使用的是外面大的作用域

    int a = 250 ; // 从这里开始 a 的值被临时覆盖为 250 外面的1临时失效
    printf("2a:%d\n" , a);// 输出 为 250  ， 使用的是内部的小的作用域
}

printf("3a:%d\n" , a); // 离开小的作用域后 ，a 恢复为  1 
```

**static 关键字：**

在C语言中非常重要的一个角色， 它在不同的场合表现的意义不一样。

1. 把可见范围进行缩小为本文将可见：

- 修饰全局变量
- 修饰普通的函数
- 把变量的存储区修改为静态数据（数据段）：

- 修饰局部变量, 使得局部变量的存储区从栈改为数据段

## 存储期

**概念：**

C语言中， 每一个变量都有一个生命周期，所谓的生命周期指的是某一个变量的内存从申请到释放的过程。申请一个内存相当于某一个变量的诞生，释放掉该内存则是相当于消亡。

变量的生命周期有一下三种形式：

- 自动存储期
- 静态存储期
- 自定义存储期

![image-20240502130924819](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502130924819.png)

**自动存储期：**

在栈空间中分配的变量（内存） ， 统统由系统统一管理，用户不需要担心，因此就称为自动存储期。

有一下几个概念是等价的：

1. 自动化变量： 从存储期的角度来描述变量的存储特性
2. 临时变量： 从存储期的角度来描述变量的存储特性
3. 局部变量： 从作用域的角度来表述变量的空间特定

```
int main(int argc , char const * argv[])  // argc argv  自动存储期    /  局部变量 
{
    int a ;     // 自动存储期    /  局部变量 
    static int b ;  // 静态存储期  局部变量 
    func(a , b);
}

void func(int x , int y)  // x, y 自动存储期    /  局部变量 
{
    
}

```

**静态存储期：**

在数据段中分配的变量（内存） ， 统统都称为静态存储期，静态存储期的内存， 在程序运行之初就已经分配好 ， 不会随着程序的运行发生申请和释放的问题 ，直到整个程序退出才会释。 换句话说他的生命周期与进程一致。

静态存储期：

- 全局变量，static只是影响他的作用域，并不影响他的存储期
- static修饰的局部变量，对于局部变量而言static只是改变了变量的存储期，而没有改变他的作用域。

```
int a = 100 ;    
static int b = 250 ;   //  a  b 都属于静态存储期， 只不过b的作用域为本文件

int main()
{
    int k ;
    
    int a = 350 ;
    static int k = 450 ; // 静态存储期
}
```

注意：

.bss段 存放的是未初始化的静态变量（静态存储期） 初始值为 0 

.data 段 已经初始化的静态变量 ， 初始化语句只会被执行一次

静态数据从进程运行之初已经存在， 直到进程退出为止

**自定义存储期：**

在堆内存中分配的变量（内存） ， 都属于自定义存储期，他的申请与释放完全由用户自己把握。

 如何申请：

malloc      calloc    realloc  

如何释放：

free 

如何清空：

bzero

memset

注意：

malloc  只负责申请空间， 并不会清空内存，因此一般使用bzero 清空

calloc 负责申请内存，并会默认清空为 0 .

free  只负责释放，也不会清空 更不会让指针指向空， 因此free之后最好让指针指向NULL 

## 结构体

**概念：**

C语言提供了很多的基础数据类型，但是实际的生活/开发中，单纯一个基础数据类型，Int  float double 不足以描述某一个事务。比如描述一本数：名字、作者、定价、版本....，因此需要一个综合的类型用来描述它。

我们作为开发者可以使用C语言预定提供的一些基础数据类型来自信组合成为一个新的数据类型（结构体）。在使用自己定义的数据类型之前需要**先声明该类型**的模样:

结构体的声明：

```
struct   结构体标签
{
      成员1 ;
      成员2 ;
      成员3 ;  
    .........
};
```

注意：

- struct ： 关键字 ， 用来告诉编译器 我要声明的东西是一个自定义的类型*（结构体）
- 结构体标签：用来区分不同的结构体类型
- 成员：指结构体内部由哪些基础数据类型所构成， 可以是任何的数据类型

**如何定义与初始化：**

```
// 定义  与 初始化   实际为结构体分配内存空间  栈
    struct TieZhu  c = { "Guide of Programming in the Linux Envirnment" ,
                        3.59 , "林世霖" } ;
                        
// 指定成员初始化
struct TieZhu  c = { 
        .Price = 3.59 ,
        .Name = "林世霖",
        .Book = "Guide of Programming in the Linux Envirnment" ,
        .num = 1234654 
        } ;
```

注意：

- 普通成员初始化： 写起来方便一点， 但是用起来麻烦一点，不利于代码的更新于迭代。
- 指定成员初始化：写起来麻烦一点， 但是用起来比较轻松， 有利于后期代码的更新迭代， 不会照成成员与成员之间初始化错位的问题。

![image-20240502132427560](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502132427560.png)

**成员引用：**

结构体相当于一个数据的集合， 里面由多个不同类型的数据组合而成，每一个成员都可以通过成员引用符来单独引用

语法：

```
结构体变量名.成员   // 普通的结构体变量
结构体指针变量->成员  // 结构体指针的访问方法
```

```
// 修改结构体变量中某一个成员的值
c.Price = 5 ;

// 如何引用
    printf("Book:%s \nPrice:%f  \nName:%s\n" , 
            c.Book,  c.Price , c.Name);
```

对结构体的堆内存进行赋值需要注意

![image-20240502132509743](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502132509743.png)

![image-20240502132602603](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502132602603.png)

由上图可知如果Book指向的是另外一个堆空间，那么在释放结构体的内存时，需要先释放Book 所指向的内存区。

总结：

```
// 结构体声明   -->   不占用内存空间
struct TieZhu
{
    int num ;
    char * Book ;
    float Price ;
    char Name [32] ;
};

void main()
{
      // 结构体变量   定义与初始化
      struct TieZhu  a = {123 , "Book" , 3.154 , "Even"} ;
      
      // 结构体指针
      struct TieZhu * p = calloc(1, sizeof(struct TieZhu));
      
      // 结构体数组
      int            arr [10] ;
      struct TieZhu  arr [10] ;
                   
      //成员引用
      a.num = 245 ;
      p->num = 250 ;
      arr[0].num = 399 ; 
}
```

**结构体声明的变异：**

```
// 结构体声明   -->   不占用内存空间
struct TieZhu
{
    int num ;
    char * Book ;
    float Price ;
    char Name [32] ;
};
```

变异 1 ：

在声明结构体类型时， 顺便定义了变量

```
struct TieZhu
{
    int num ;
    char * Book ;
    float Price ;
    char Name [32] ;
} Even , *Jacy ;   // 在声明结构体类型时， 顺便定义了两个变量


Even.num = 1024 ;
Jayc = &Even ;  // 让指针Jacy 指向Even的地址
Jacy->Book = "Hello" ; 
```

变异2：

省略结构体的标签名，但是注意一般在省略标签的情况下需要在声明语句后面顺便定义变量/指针， 否则后面无法在定义这种类型的结构体变量。

这种写法比较少出现， 如果要出现一般是作为某个结构体内部的成员使用。

```
struct 
{
    int num ;
    char * Book ;
    float Price ;
    char Name [32] ;
} Even , *Jacy ;   // 在声明结构体类型时， 顺便定义了两个变量


Even.num = 1024 ;
Jayc = &Even ;  // 让指针Jacy 指向Even的地址
Jacy->Book = "Hello" ; 
```

例子：

```
struct node
{
    int i ;
    char c ;
    float f ;
    struct{      // 结构体内部的成员
        float ff ;
        double d ;
    } info ;
};

int main(int argc, char const *argv[])
{
    struct node data = {
        .c = 'A',
        .i = 1024 ,
        .f = 3.489 ,
        .info.d = 665.1234,
        .info.ff = 3.444
    };

    struct node * p = &data ;


    printf("d:%lf , ff:%lf \n" , data.info.d , data.info.ff  );

    printf("d:%lf , ff:%lf \n" , p->info.d , p->info.ff  );


    return 0;
}
```

变异 3 ：【推荐使用】

使用 typedef 来给结构体的类型取别名

`                typedef   long unsigned int   size_t ;              `

Tz 相当于 struct TieZhu  可以直接定义普通结构体变量

P_Tz 相当于 struct TieZhu *  可以直接定义结构体指针变量

```
typedef struct TieZhu
{
    int num ;
    char * Book ;
    float Price ;
    char Name [32] ;
}Tz , * P_Tz ;
```

例子：

```
// 结构体声明   -->   不占用内存空间
typedef  struct TieZhu
{
    char * Book ;
    float Price ;
    char Name [32] ;
}Tz , *P_Tz ;



int main(int argc, char const *argv[])
{

    Tz b = {
        .Book = "Hello" ,
        .Name = "Even",
        .Price = 3.14 
    }; 

    P_Tz p = &b ;

    printf("Name : %s \n" , b.Name );
    printf("Name : %s \n" , p->Name );



   
    return 0;
}
```

```
结构体数组：
   struct TieZhu arr[5] ;  // 拥有5个结构体的元素的数组
   
结构体数组指针：
   struct TieZhu（*p）[5] ;  // 指向的是一个 拥有5个元素的结构体数组
   
结构体指针数组：
   struct TieZhu  * arr[5];   // 存放的是5个结构体类型的指针
```

## 结构体尺寸

**CPU 字长**

字长就是指CPU（处理器）在执行一条指令时，最大一个运算能力，这个运算能力由两部份决定一个就是处理器本身的运算能力， 另一个就系统的字长，比如常见的32位/64位系统，如果使用32位系统那么在处理数据的时候每一次最对多可以处理32位的数据（4字节） 。

![image-20240502133020613](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502133020613.png)

**地址对齐**

每一款不同的处理器，存取内存数据都会有不同的策略，如果是 32 位的 CPU，一般来讲他在存取内存数据的时候，每次至少存取 4 个字节（即 32 位），也就是按 4 字节对齐来存取的。换个角度讲：CPU 有这个能力，他能一次存取 4 个字节。

接下来我们可以想到，为了更高效地读取数据，编译器会尽可能地将变量塞进一个 4字节单元里面，因为这样最省时间。如果变量比较大，4 个字节放不下，则编译器会尽可能地将变量塞进两个 4 字节单元里面，反正一句话：两个坑能装得下的就绝不用三个坑。这就是为什么变量的地址要对齐的最根本原因。

![image-20240502133056141](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502133056141.png)

![image-20240502133101364](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502133101364.png)

所谓地址对齐主要思想：

尽可能提高CPU的运行效率（仅能能的少取读取/写入内存）

一个数据如能使用一个单元来存放感觉对不使用两个， 两个能放绝对不用三个

**普通变量的M值**

概念：	 一个数据它的大小是固定的（比如整型），如果这个数据他所存放的地址能够被某一个数所整除（4）那么这个数就成为当前数据的M值。

可以根据具体的系统字长以及数据的大小可以计算得出M值。

例子：

```
int i ;  // i 占用 4 字节， 如果i 存放在能被4整除的地址下则是地址对齐， 因此他的M值为4 
char c ;// c占用 1 字节， 如果c 存放在能被1整除的地址下则是地址对齐， 因此他的M值为1 
short s ;// s 占用 2 字节， 如果s 存放在能被2整除的地址下则是地址对齐， 因此他的M值为2 
double d ; // d 占用 8 字节， 如果d 存放在能被4整除的地址下则是地址对齐， 因此他的M值为4 
float f ;// f 占用 4 字节， 如果f 存放在能被4整除的地址下则是地址对齐， 因此他的M值为4 

i:0x7fffc900a298
s:0x7fffc900a296
c:0x7fffc900a295
d:0x7fffc900a2a0
f:0x7fffc900a29c
```

注意：

如果一个变量的大小超过4 （8/16/32） M值则按4计算即可

**手残干预M值：**

`                char c __attribute__((aligned(16))) ;              `

注意：

__attribute__ 机制是GNU特定语法，属于C语言标准的拓展。

__attribute__ 前后都有个两个下划线_

__attribute__ 右边由两对小括号  ((        ))

__attribute__ 还支持其它的设置......

一个变量他的M值只能提升不允许降低 ， 只能是2的N次幂

**结构体的M值**

- 结构体中有多个成员，取决于成员中M值最大的成员。
- 结构体的地址，必须能被结构体的M值整除
- 结构体的尺寸，等于成员中宽度最宽成员的倍数

例子：

```
typedef struct node
{
    int i ;     // 4  
    char c  ;   // 1
    short s ;   // 2
    double d ;  // 8
    long double ld ;  // 16    由于16是最宽的，因此结构体的大小不许能被16整除
    float f ;  // 4 
}Node;
```

以上结构体在64位系统中：

大小 为  48  --> 能被 long double整除

地址值能被M值4整除

![image-20240502133247510](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502133247510.png)

**可移植性**

对于可移植的结构体来说一定要解决好该结构体在不同的操作系统（位数）如何统一 该结构体的大小。

方法有两个：

方法1 ：

直接使用attribute 进行压实， 每一个成员之间没有留任何的空隙。

```
typedef struct node
{
    int i ;
    char c  ;
    short s ;
    double d ;
    long double ld ;
    char kk ;
    float f ;
}__attribute__(( packed ));
```

方法2 ：

对每一个成员进行压实

```
struct node
{
    int i __attribute__((aligned(4))) ;
    char c  __attribute__((aligned(1)));
    short s __attribute__((aligned(2)));
    double d __attribute__((aligned(4)));
    long double ld __attribute__((aligned(4))) ;
    char kk __attribute__((aligned(1))) ;
    float f  __attribute__((aligned(4)));
};
```

注意：

结构体的大小取决于多个因素

- 地址对齐，M值的问题， 默认情况下结构体的大小为成员中最大的倍数
- 结构体内部的每一个成员的大小都与系统的位数有关
- 如果需要实现可移植性，结构体的每一个成员需要使用可移植类型+attribute机制对结构体进行压实

## 联合体与枚举

**联合体的概念**

联合体从表面上看与结构体非常类似，但是他们的本质完全不同。结构体每一个成员都有一个独立的内存空间， 但是联合体的每一个成员公用同一个内存空间因此联合体也被称为共同体。

语法：

```
union 联合体标签
{
      成员1 ;
      成员2 ;
      成员3 ;
    
};
```

联合体标签 : 用来区分不同类型的联合体

成员：  联合体内存的各个成员

```
// 声明联合体
union node
{
    int i ;
    char c ;
    short s ;
    double d ;
};


int main(int argc, char const *argv[])
{
    // 联合体变量定义
    union node data;

    printf("size:%ld\n" , sizeof(data));
    printf("i:%p\n" , &data.i );
    printf("c:%p\n" , &data.c );
    printf("s:%p\n" , &data.s );
    printf("d:%p\n" , &data.d );

    return 0;
}
```

注意：

联合体的尺寸取决于，联合体中成员宽度最宽的。

联合体中所有成员的内存地址（首地址）是同一个

在同一时间内，有效的成员只有一个

当我们给联合体某一个成员赋值的时候其它成员则失效（数据无效）

**联合体的使用**

联合体一般来说比较少使用， 如果要用很可能会出现在结构体内部，用来描述一种互斥的数据。

示例：

```
#include <stdio.h>
#include <string.h>

// 声明结构体
typedef struct demo
{
    char Nmae[32];
    char Type ;  // S 学生  T  老师  F  打饭阿姨  Q  清洁工
    union 
    {
        float num ; // 成绩
        int i ; // 手抖值
        char c ; // 清洁能力
    }stat;
}Node ;
int main(int argc, char const *argv[])
{
    Node data [3] ;
    // 把"Even" 拷贝到 结构体数据则第0 位， 希望拷贝32 字节
    strncpy(data[0].Nmae , "Even" , 32 );
    data[0].Type = 'Q' ;
    data[0].stat.c = 'A';

    // 学生
    strncpy((data+1)->Nmae , "Jacy" , 32 );
    (data+1)->Type = 'S' ;
    (data+1)->stat.num = 13.86 ;

    // 阿姨
    strncpy((data+2)->Nmae , "CuiHua" , 32 );
    (data+2)->Type = 'F' ;
    (data+2)->stat.i = 13 ;

    for (size_t i = 0; i < 3 ; i++)
    {
        switch((data+i)->Type)
        {
            case 'Q':
                printf("当前输出为清洁工：\n 名字：%s\t人猿类型:%c\t清洁能力：%c\n",
                    (data+i)->Nmae ,(data+i)->Type , (data+i)->stat.c );
                break ;
            case 'S':
                printf("当前输出为学生：\n 名字：%s\t人猿类型:%c\t学习能力：%f\n",
                    (data+i)->Nmae ,(data+i)->Type , (data+i)->stat.num );
                break ;
            case 'F':
                printf("当前输出为打饭阿姨：\n 名字：%s\t人猿类型:%c\t抖肉能力：%d\n",
                    (data+i)->Nmae ,(data+i)->Type , (data+i)->stat.i );
                break ;
        }
    }
    
    return 0;
}
```

**字节序**

![image-20240502133632288](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502133632288.png)

**枚举**

概念： 枚举本质上一种范围受到限制的整型，比我们可以使用 0 - 3 表示4种状态（比如某个硬件的状态:打开、运行、暂停、关闭）

枚举常量列表：

语法：

```
// 声明枚举常量列表
enum  枚举标签 {  常量1 , 常量2 ,常量3 ,常量4 ,} ;

enum  MIC {  open , run , stop  , close } ;
```

使用：

```
#include <stdio.h>

// 声明枚举常量列表
enum  MIC {  open , run , stop  , close } ;

int main(int argc, char const *argv[])
{
    enum  MIC stat = run ;

    switch(stat)
    {
        case open:
            printf("麦克风状态为打开：%d\n" , open);
            break;
        case run:
            printf("麦克风状态为运行中：%d\n" , run);
            break;
        case stop:
            printf("麦克风状态为暂停：%d\n" , stop);
            break;
        case close:
            printf("麦克风状态为关闭：%d\n" , close);
            break;
    }

    return 0;
}

```

枚举常量的值可以手动修改：

```
// 声明枚举常量列表
enum  MIC {  open , run = 5 , stop  , close } ;
```

总结：

默认情况下枚举常量实际它的值为整型值， 并首个元素默认为0 

可以在声明枚 举常量列表的时候对给他进行赋值， 如果没有赋值则等于前一个常量值+1 

在C语言中 枚举等价于整型，支持所有整型的操作

`                printf("%d\n" , run+stop);              `

枚举的作用提供了一个确定范围， 使用一个有意义的单词来表示一个整型数字提高代码的可读性

## 编译器与宏定义

```
比如一下宏， 如果需要使用则需要包含它所在的头文件
/usr/include/linux/input-event-codes.h
....
#define ABS_X                   0x00
#define ABS_Y                   0x01
#define ABS_Z                   0x02
#define ABS_RX                  0x03
#define ABS_RY                  0x04
#define ABS_RZ                  0x05
...
```

编译器：

概念： 编译器是一个用来帮助我们把原码.c翻译成计算机能够之直接识别的二进制编码。使用不同的编译器可以翻译出来不同机器的二进制编码。

gcc 编译器：

```
gcc hello.c -o hello

gcc         -->  C语言编译器
hello.c     -->  需要编译的原码
-o          -->  指定输出文件名
hello       -->  可执行文件的名字
```

![image-20240502133853799](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502133853799.png)

1 预处理

```
gcc hello.c -o hello.i -E
加上一个编译选项 -E 就可以使得 GCC 在进行完第一阶段的预处理之后停下来，生成
一个默认后缀名为.i 的文本文件
```

预处理是指在编译代码之前先进行预先的处理工作，这些工作包含哪些内容：

- 头文件被包含进来（复制）： #include
- 宏定义会被替换：#define 
- 取消宏定义： #undef
- 条件编译： #if    #ifdef   #ifndef    #else  #elif     #endif
- 修改行号以及文件名： #line    998   "Hello.c"
- 清除注释

预处理大部分的工作是在处理以 # 开头的一些语句，从严格意义来讲这些语句并不属于C语言的范畴， 它们在编译的第一个阶段被所谓的 预处理器 来处理。

2 编译 

`                gcc hello.i -o hello.s -S              `

加上一个编译选项 -S 就可以使得 gcc 在进行完第一和第二阶段之后停下来，生成一个默认后缀名为.s 的文本文件。打开此文件看一看，你会发现这是一个符合 x86 汇编语言的源程序文件。

经过预处理之后生成的.i 文件依然是一个文本文件，不能被处理器直接解释，我们需要进一步的翻译。接下来的编译阶段是四个阶段中最为复杂的阶段，它包括词法和语法的分析，最终生成对应硬件平台的汇编语言（不同的处理器有不同的汇编格式）。

汇编文件取决于所采用的编译器，如果用的是 GCC，那么将会生成 x86 格式的汇编文件，如果用的是针对 ARM 平台的交叉编译器，那么将会生成 ARM 格式的汇编文件。

3 汇编

```
gcc hello.s -o hello.o -c
-c 则是让编译器在对汇编语言文件进行编译后停下来，
     这里会生成一个待链接的可执行文件
```

则会生成一个扩展名为.o 的文件，这个文件是一个 ELF 格式的可重定位(relocatable)文件，所谓的可重定位，指的是该文件虽然已经包含可以让处理器直接运行的指令流，但是程序中的所有的全局符号尚未定位，所谓的全局符号，就是指函数和全局变量，函数和全局变量默认情况下是可以被外部文件引用的，由于定义和调用可以出现在不同的文件当中，因此他们在编译的过程中需要确定其入口地址，比如 a.c 文件里面定义了一个函数 func( )，b.c 文件里面调用了该函数，那么在完成第三阶段汇编之后，b.o 文件里面的函数 func( )的地址将是 0，显然这是不能运行的，必须要找到 a.c 文件里面函数 func( )的确切的入口地址，然后将 b.c 中的“全局符号”func重新定位为这个地址，程序才能正确运行。因此，接下来需要进行第四个阶段：链接。

可以尝试使用命令readelf  来查看这个可重定位文件

`                $ readelf demo.o -a              `

4 链接

```
 gcc hello.o -o hello -lc -lgcc
 gcc        .....
 hello.o    ....
 -o         ......
 hello      .....
 -lc         --> -l 链接     c  标准C库
 -lgcc      --> -l 链接   gcc 链接GCC 的库
```

有两个很重要的工作没完成，首先是重定位，其次是合并相同权限的段

一个可执行镜像文件可以由多个可重定位文件链接而成，比如 a.o，b.o，c.o 这三个可重定位文件链接生成一个叫做 x 的可执行文件，这些文件不管是可重定位的，还是可执行的，它们都是 ELF 格式的，ELF 格式是是符合一定规范的文件格式，里面包含很多段(section)，比如我们上面所述的 hello.c 编译生成的 hello.o 有如下的格式

![image-20240502134050537](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502134050537.png)

**宏的概念：**

宏（macro）其实就是一个特定的字符串，用来直接替换比如：

`                #define  PI    3.14              `

上面定义了一个宏 名为 PI ，在下面代码的引用过程中 PI 将会被直接替换为实际的值

```
int main(int argc, char const *argv[])
{
    printf("%f\n" , PI ); 
    printf("%f\n" , 3.14 );    
    return 0;
}
```

宏的作用：

- 使得程序的可读取有所提高，使用一个又有意义的单词来表示一个无意义数字（某个值）
- 方便对代码进行迭代更新， 如果代码中有多处使用到该值， 则只需要修改一处即可（定义）
- 提高程序的执行效率，可以使用宏来实现一个比较简单的操作。用来替代函数的调用

**无参宏**

意味着我们在使用该宏的时候不需要携带额外的参数

```
// 定义一个宏用来表示 人数
#define     PEOPLE      10
```

系统中有预定义一些宏：

```
比如一下宏， 如果需要使用则需要包含它所在的头文件
/usr/include/linux/input-event-codes.h
....
#define ABS_X                   0x00
#define ABS_Y                   0x01
#define ABS_Z                   0x02
#define ABS_RX                  0x03
#define ABS_RY                  0x04
#define ABS_RZ                  0x05
...
```

**带参宏：**

意味着我们在使用这些宏的时候，需要额外传递参数

```
#define   MAX(a,b)  a>b? a:b 


int main(int argc, char const *argv[])
{
   
   printf("%d\n" , MAX(198,288) );
   //printf("%d\n" , 198>288? 198:288 );  --> 预处理后

    return 0;
}
```

以上MAX 的宏在使用的时候 ，把198 以及 288 分别作为 a  ,和b 的值， 然后进行替换。

注意： 

宏只是直接文本替换，没有任何的判断以及语法检查的操作甚至运算

宏在编译的第一个阶段， 被处理完成，运行的过程中不占用时间（宏已经不存在）

宏在预处理的时候直接展开。

**带参宏的副作用**

由于宏只是一个简单的文本替换，中间不涉及任何的计算以及语法检查（类型），因此在使用复杂宏的时候需要小心注意

注意：

宏只能写在同一行中（逻辑行），如果迫不得已需要使用多行来写一个宏则可以使用转义字符\把换行符转义掉

![image-20240502134243528](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502134243528.png)

## 条件编译

**条件编译**

根据某一个条件来决定某一代码块是否需要编译。

形式1：

通过无值的宏来判断 ， 则只能判断是否有定义

```
#ifdef    // 判断某一个宏是否有定义

        // 代码块

#endif     // 判断语句的结束

#ifdef  DE_BUG  // 如果定义了DE_BUG 宏则一下代码块会被编译，反之则不会被编译
    printf("new:%s--%d--%s--%d\n" , 
    new->Name ,new->age ,new->skill , new->udel );
#endif
```

形式2 ：

通过有值的宏来进行判断， 则可以通过值来判断（非零则真）

```
#define MACRO  0  // 非零则真
#define MACRO  "Hello" // 错误的， 不允许出现字符串
#define MACRO  'A'  // 允许

#if MACRO  // 只要判断MACRO为非零值则表示条件为真
    printf("__%s__%s__%d__\n", __FUNCTION__ , __FILE__ , __LINE__ );
#endif
```

注意：

在使用有值宏进行条件编译的时候， 宏的值只允许出现整型/字符

多路分支可以根据自己的需求继续延续下去

使用条件编译必须有结束的语句  #endif 与开头进行对应

**条件编译的实际应用场景**

除了打开代码进行修改宏的值或者重新定义或删除宏的定义，还可以通过编译命令来定义宏

```
$ gcc ifdef.c  -DDE_BUG
-D     --> 定义宏  define
DE_BUG  --> 需要定义宏的名字为 DE_BUG
```

## 头文件

**头文件的作用**

一般来说我们C语言程序需要用到的很多的.c 文件，当某一些公共的资源需要在各个源文件中使用的时候，就可以把它写在头文件中，被其它的.c文件包含，可以避免编写同样的代码。

头文件内部放：

1) 普通函数声明
2) 宏定义
3) 结构体、共用体模板定义 （声明）
4) 枚举常量列表
5) static 函数和 inline 函数定义
6) 其他头文件

![image-20240502134448588](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502134448588.png)

**头文件格式：**

```
#ifndef     __DEMO_H   // 判断是否有定义某个宏 ，用来防止头文件被多次包含出现的重定义问题
#define     __DEMO_H   //如果没有定义，说明前面没有包含过该头文件

//其它头文件
....
...

// 结构体声明
..
....

// 函数声明
....
....

// 静态函数定义
.....
.....

// 枚举





#endif  // ifndef 的结束
```

由于项目中各个文件比较多，建议使用不同的文件夹来存放不同类型的文件：

bin  :  二进制的可执行文件

inc  :  用户自己写的头文件

src  ： 源文件  

![image-20240502134522834](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240502134522834.png)

如何编译：

```
$ gcc src/*.c -o bin/Tiezhu  -I./inc

gcc          编译器
src/*.c      需要编译的源文件路径 + 文件名
-o           指定声明文件的名字  后边必须接 目标文件的路径+名字
bin/Tiezhu   目标文件的路径 + 名字
-I./inc       -I 指定头文件路径  后面必须接头文件所在的路径
```

