---
layout: post
title: Linux驱动09字符设备
author: jevon xiong
tags:
- blog
- Linux
- Linux驱动
date: 2024-03-28 16:00 +0800
toc: true
---
# 汇编

## 一、概述

汇编更接近机器语言，能够**直接对硬件进行操作（例如堆栈的初始化）**，生成的程序与其他的语言相比具有**更高的运行速度**，占用**更小的内存**，因此在一些对于时效性要求很高的程序、许多大型程序的核心模块以及工业控制方面大量应用。但是汇编也有很明显的缺点，**移植性很差**，不同芯片的汇编指令格式各不一样。

感受一下C语言与汇编语言之间的关系

![image-20240329161142603](https://github.com/Jevon-Xiong.github.io/raw/master/_picture/image-20240329161142603.png)

## 二、ARM的指令集

约定：

寄存器就当做是芯片提供给我们的全局32位变量`r0~r15`，但是能够给我们使用的话`r0~r12`，r13用于存储堆栈指针，r14用于存储子程序的返回地址，r15用于记录当前程序的执行位置。

1. 数据处理指令

-   数据传输指令 =
-   算术逻辑运算指令
-   算术 + - ×
-   逻辑 & | ^ ~
-   比较 > < ==

2.   数据处理指令的寻址方式

-   立即数寻址 `mov r0,#0x10`
-   寄存器寻址`mov r0, r1`
-   寄存器偏移寻址`mov r1,r2,lsl #2`

3. 加载（Load）和存储（Store）指令

-   单寄存器操作指令
-   寄存器间接寻址
-   基址变址寻址



-   多寄存器操作指令
-   出栈（恢复现场）和压栈（保护现场）
-   寄存器列表



-   跳转指令
-   调用子程序 bl
-   .跳转到某个位置 b
-   函数返回 bx lr

其他指令，就参考ARM指令速查手册.pdf与ARM的指令集.ppt。

## 三、汇编编写文件格式

1. 汇编文件必须以大写”.S”作为文件的后缀名，汇编文件格式如下：

```assembly
--------------------------------------
.text
// 代码部分

.end
-------------------------------------
```

2.   如果当前汇编文件作为第一个执行的文件，格式必须如下：

```assembly
--------------------------------------
.text
.global _start
_start:
// 代码部分

.end
-------------------------------------
```

3.   编写一个普通函数

```assembly
--------------------------------------
// 标号
delay:
	push{用到的寄存器} //压栈保存寄存器
// 代码部分
	pop {用到的寄存器} //出栈恢复寄存器
	bx lr		// 函数返回
-------------------------------------
```

4. 编写一个死循环

```assembly
--------------------------------------
// 标号
loop:
	//代码部分
	
	b loop //跳转到loop
	
-------------------------------------
```

#示例代码1

使用汇编语言编写单个LED灯闪烁代码。

```assembly
//定义寄存器
#define GPIOEOUT		 0xC001E000
#define GPIOEOUTENB		0xC001E004
#define GPIOEOUTEN0		0xC001E020
#define GPIOEOUTEN1		0xC001E024

.text //代码段的开始
.global _start //全局声明函数入口_start
_start: //全局程序函数入口_start
	//配置GPIOE13为输出模式
	ldr r0,=GPIOEALTFN0 //将0xC001E020地址值给到r0寄存器 r0=0xC001E020
	ldr r1,[r0] //将r0指向地址的内容读取到r1
	
	ldr r2,=3<<26 //r2 = 3<<26
	mvn r3,r2 //将r2取反，取反的结果~(3<<26)给到r3
	and r1,r1,r3 //r1 = r1 & r3
	
	str r1,[r0] //将r1的数值存储到r0指向的地址 *r0 =r1
	
	//允许GPIOE13输出电平
	ldr r0,=GPIOEOUTENB //将0xC001E004地址值给到r0寄存器 r0=0xC001E020
	ldr r1,[r0] //将r0指向地址的内容读取到r1 r1=*r0
	
	ldr r2,=1<<13 //r2 = 1<<13
	orr r1,r1,r2 //r1 = r1 | r2
	str r1,[r0] //将r1的数值存储到r0指向的地址 *r0 =r1
	
loop:
	//添加代码
	
	//点亮
	ldr r0,=GPIOEOUT //将0xC001E000地址值给到r0寄存器 r0=0xC001E000
	ldr r1,[r0] //将r0指向地址的内容读取到r1 r1=*r0
	
	ldr r2,=1<<13 //r2 = 1<<13
	mvn r3,r2 //将r2取反，取反的结果~(1<<13)给到r3
	and r1,r1,r3 //r1 = r1 & r3
	str r1,[r0] //将r1的数值存储到r0指向的地址 *r0 =r1
	
	//延时一会
	bl delay
	//熄灭
	ldr r0,=GPIOEOUT //将0xC001E000地址值给到r0寄存器 r0=0xC001E000
	ldr r1,[r0] //将r0指向地址的内容读取到r1 r1=*r0
	
	ldr r2,=1<<13 //r2 = 1<<13
	orr r1,r1,r2 //r1 = r1 | r2
	
	str r1,[r0] //将r1的数值存储到r0指向的地址 *r0 =r1
	
	//延时一会
	bl delay //调用delay子函数
	
	b loop //跳转到loop标签
	
//定义delay子函数
delay:
	//压栈
	push {r0,lr} //保存r0，lr寄存器到堆栈
	ldr r0,=0x20000000
delay_loop:
	sub r0,r0,#1 //r0=r0-1
	cmp r0,#0 //检查r0是否跟0相等
	
	bne delay_loop //若r0!=0，则跳转到delay_loop//若r0==0，则执行
	//出栈
	pop {r0,lr} //从堆栈恢复r0,lr寄存器的值
	bx lr //函数返回
	
.end //代码段的结束
```

