---
layout: post
title: 网络编程（套接字编程）
author: jevon xiong
tags:
- blog
- 嵌入式
- Liunx
- 网络编程
date: 2024-03-18 19:37 +0800
toc: true
---
# 网络编程（套接字编程）

## 基础

TCP/IP协议
特点：
不局限于某一台主机中的各个进程，只要网络可以到达，就可以实现跨平台的进程通信。
协议：
想要实现在两个或多个平台中稳定通信，就需要遵守（达成）同一个协议。

**TCP 协议**：
TCP协议包含两个方面

- tcp传输协议：用来检测网络传输中差错的传输控制协议
- ip 网际协议：专门负责对不同网络进行互联的互联网协议IP
    （通俗的来说TCP是专门负责传输过程中的出错问题，一旦出现传输的问题TCP协议则会介入处理，并把出错的数据包重新传输直到数据安全到达为止。而IP协议则是在网络中负责不同的网络之间的通信，给网络中的每一台主机分配一个不同的IP地址）

OSI 开放系统互连模型
OSI模型相关的协议已经非常少使用，但是模型本身非常通用
OSI模式是一个理想化的模型，至今尚未由完整的实现
OSI模型共分为7层：

物理层
负责如何把数据包通过网卡然后在网线中传输。包括所有硬件的
管理比如网卡/针脚/电压/集线器/中继器等等

1. 用户层
    1.1 应用层--提供给应用程序的接口，用以设置与另外一个程序之间的通信方式（例如：HTTP/HTTPS/FTP/SSH/SMTP/TELNET等...）
    1.2 表示层--根据系统把数据进行转换
    1.3 会话层--负责数据传输时的设置以及维护网络中两台计算机之间的通信连接
2. 内核层
    2.1 传输层--把需要传输的数据以及一些基本信息（传输表头TH--传输协议TCP等）一起打包形成数据包
    2.2 网络层--把上一层的数据包再加一个网络信息（网络表头NH--互联网协议IP等）形成分组。
3. 驱动层
    3.1 数据链路层--负责网络寻址、错误侦测与改正。当表头（DLH包含物理地址和错误侦测及修正方法）和表尾（DLT提示到达末尾的字符串）被添加到数据包中时就形成帧。
    3.2 物理层--负责如何把数据包通过网卡然后在网线中传输。包括所有硬件的管理比如网卡/针脚/电压/集线器/中继器等等

OSI参考模型并不是一个标准，而是一个在制定标准时所使用的概念性框架。

TCP / IP 模型 (协议簇)
TCP/IP协议事实上是一个工业标准。
TCP/IP协议指的是能够在多个不同的网络间实现信息传输的协议簇。
该协议并不是只由 TCP 和 IP协议组成，而是由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇。只是TCP IP 协议比较有代表性所以被称为TCP/IP协议。
TCP/IP只有4层（应用层、传输层、网络层、网络接口和物理层）

![image-20240313104536164](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240313104536164.png)



自下而上了解TCP/IP协议：

- 网络接口和物理层
    物理层的主要设备就是中继器和集线器（交换机/路由）
    封装成帧（在数据的前后分别加上*开始《纠错以及修正》*和结束的标记后便构成了一*帧*）
    每一个数据链路层都规定了所能传输的一针数据中数据的长度上限称为*最大传输单元（MTU）*
    透明传输（指的是不管数据的二进制是如何组合都应该能够正常传输而不会被误以为是某些控制的命令，确保数据安全到达）
    差错检测（在传输的二进制编码中加入适当的冗余度使得接收者可以发现在传输中是否出现了差错）
    TCP /IP 协议的数据包组成：
    头部数据+最大传送单元+尾部数据

![image-20240313104718796](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240313104718796.png)

Socket --- 插座

- 是一个编程接口
- 是一个特殊的文件描述符
- 不仅仅局限于TCP/IP协议
- **面向连接 TCP（视频通话）**
- **无连接 UDP （发微信消息）**
- 很多的应用 都依赖于socket的接口例如FTP\TELNET等

为什么需要socket
      普通IO操作的过程：
          打开文件 >> 读/写操作 >> 关闭文件
Socket文件的操作：
    在同一个机器上的两个程序可以简单的通过某一个相同的文件进行数据的交流和传输

**什么是Socket**

-   独立于具体协议的网络编程接口
-   在OSI模型中主要位于会话层和传输层之间
-   Socket的类型
    -   流式套接字 （SOCK_STREAM） TCP
        提供一个面向连接、可靠的数据传输服务，**数据无差错、无重复、地发送并按顺序抵达**。内设流量控制，避免数据流淹没前面的数据。数据被查看时字节流，无长度限制。
    -   数据报套接字（SOCK_DGRAM） UDP
        提供无连接服务，数据包以独立数据包形式被发送，**不提供无差错保证，数据有可能丢失或重复到达，顺序发送可能会乱序接收**
    -   原始套接字（SOCK_RAW）
        可以直接访问较低层次的协议例如 IP\ICMP。

socket的位置

![image-20240313105019856](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240313105019856.png)

**IP地址**

- IP地址是网络中**主机(电脑)**的标识
- 在网络中主机想要与其他机器通信就必须拥有一个自己的IP地址
- IP地址为32位（IPV4）或者128位（IPV6）
- 每一个数据包都必须携带**目的地址IP**和**源IP地址**，路由器依靠此信息为数据包选择最优路由（路线）

**表现形式：**

​	点分形式：如192.168.100.2 在传输过程中都会被转换为一个32位无符号的整数

**端口号：**（用于区分计算机中某一个具体的程序）

- 用于区分一台主机中接收到的数据包应该转交到哪一个进程进行处理
- TCP端口号与UDP端口号是相互独立的
- 端口号一般由IANA（Internet assigned numbers authority）统一管理
- 总所周知端口：1-1023（1-25之间为众所周知端口，256-1023为unix系统占用）
    - 总所周知端口就是早已固定好的端口

- 注册端口：1024-49151分配给进程或应用。这些端口号还没被服务器资源占用时，可以由用户的APP动态注册获得。
- 动态端口号：49152-65535，被称为动态端口号是指一般不固定分配某种服务二十动态分配的。

**字节序**：

不同的CPU 主机中，内存存储多个字节的序列分为两种，这个称为主机字节序

- 小端序（Little-Endian）
    - 低序（低有效位）存储在低地址（起始地址），Intel\AMD 等采用的方式

- 大端序(Big-Endian)
    - 高序（高有效位）存储在低地址 ARM采用的存储方式

为了避免在不同的处理器中收到的数据出现字节序带来的问题，因此网络中传输的数据必须按照**网络字节序来处理，也就是大端序**。发送者在发送数据前必须先转换为网络字节序，而接收者需要在收到网络中的数据时再转换为自己合适的**主机字节序**。

字节序转换API :

uint32_t htonl(uint32_t hostlong); // 主机字节序到网络字节序 无符号长整型

uint16_t htons(uint16_t hostshort);// 主机字节序到网络字节序 无符号短整型

uint32_t ntohl(uint32_t netlong); // 网络字节序转为主机字节序 无符号长整型

uint16_t ntohs(uint16_t netshort); // 网络字节序转为主机字节序 无符号短整型

IP地址转换：

// 把cp指向的字符串转换为32位的网络字节序的二进制值存于inp中
		// cp 点分十进制的网络地址的字符串 （IP地址）

int inet_aton(const char *cp, struct in_addr *inp);



// 把cp指向的字符串转换为32位的网络字节序的二进制值并返回

in_addr_t inet_addr(const char *cp);

in_addr_t inet_network(const char *cp);



// 把in中的32位网络字节序的二进制地址转换为点分十进制的字符串

char *inet_ntoa(struct in_addr in);

## TCP

**TCP（Transmission Control Protocol）**协议指的是传输控制协议，是一个面向连接的传输协议，他是一个能提供高可靠性的通信协议，所谓高可靠性指的是数据无丢失、数据无误、数据无失序、数据无重到达。（打电话）

适用场景：

- 适用于对传输质量要求较高，以及传输大量数据的通信。
- 在需要传输可靠数据的场合通常会选择使用TCP通信协议。
- 比如QQ/微信/支付宝等通信软件的账户登录和支付相关功能是通常采用可靠的TCP通信协议来实现。

### API

![image-20240313112145801](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240313112145801.png)



## UDP

UDP（User Datagram Protocol）指的是用户数据报协议，是一种不可靠无连接的协议，在数据发送前，不需要提前建立连接，所以可以更高效地传输数据。（发邮件）

适用场景：

- 发送小尺寸地数据（例如对DNS服务器进行地址查询或路游器更新路由表）
- 在收到数据，给出应答比较困难地网络中适用UDP（比如无线网络）
- 适用于广播/组播式通信。
- QQ/微信等即时通信软件地点对点文件通讯以及音视频通话时。
- 流媒体、VoIOP、IPTV等网络多媒体服务中（直播间）

### API接口

```C
int socket(int domain, int type, int protocol);
参数：
	domain：域。
	AF_INET/PF_INET： 网际协议
	AF_UNIX/PF_UNIX：本地协议，可写成 AF_LOCAL/PF_LOCAL
type：类型。
 	SOCK_STREAM：流式套接字 TCP协议
 	SOCK_DGRAM：数据报套接字 UDP协议
	protocol：协议。
	一般为 0
返回值：
	成功：待连接套接字
	失败：-1
```

绑定地址：

```C
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
参数：
    sockfd：待连接套接字
   addr：包含本地地址（IP+PORT）的通用地址结构体的指针
   addrlen：地址结构体大小
返回值：
    成功:0
    失败：-1
```

地址结构体：

```C
struct sockaddr // 通用IP信息结构体
 {
	sa_family_t sa_family;
	char sa_data[14];
 }
struct sockaddr_in // IPV4地址结构体
{
	u_short sin_family;// 地址族
	u_short sin_port;// 端口
	struct in_addr sin_addr;// IPV4 地址
	char sin_zero[8];
};
struct in_addr // IP地址结构体
{
	in_addr_t s_addr;// 无符号 32 位网络地址
};
```

发送数据到UDP：

```C
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
参数：
	sockfd：UDP 套接字
 	 buf：即将发送的数据
 	 len：数据的长度
 	 flags：发送标志，与函数 send 的 flags 完全一致
 	 dest_addr：对端网络地址
 	 addr_len：地址长度
 返回值：
 	 成功：已发送字节数
 	 失败：-1    
```

从UDP中接收数据：

```C
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
参数：
	sockfd：UDP 套接字
	buf：储存数据缓冲区
	len：缓冲区大小
	flags：接收标志，与函数 send 的 flags 完全一致
	src_addr：对端网络地址
	addrlen：地址长度
返回值：
	成功：已接收字节数
```

![image-20240313112029123](https://github.com/Jevon-Xiong/Jevon-Xiong.github.io/raw/master/_picture/image-20240313112029123.png)

## socket的四种IO模型

socket 中有四种IO模型

- 阻塞型IO
    - 最常用/最简单/效率低
    - 函数本身不具备阻塞属性，而是由于文件描述符本身导致函数阻塞。
    - 在默认情况下Linux建立的socket套接都是阻塞的

- 非阻塞
    - 可以设置进程不阻塞在IO操作上，需要轮询
    - 占用CPU资源较大

- 多路复用IO
    - 同时对多个IO进行操作
    - 可以设置在规定的时间内检测数据是否到达

- 信号驱动型IO
    - 属于一步通信方式
    - 当socket中有数据到达时，通过发送信号告知用户

### 阻塞型IO

- 读阻塞

    当套接字接收缓冲区中没有数据可以读取时调用 如 read/recv/recvfrom就会导致阻塞

    当有数据到达时，内核便会去唤醒进程，通过read等函数来访问数据

    如果进程阻塞过程中意外，那么进程将永远阻塞下去。

- 写阻塞
    发生写阻塞的机会比较少，一般出现在写缓冲区无法写入即将写入的数据时

    无法写入数据时便会进入阻塞等待

    一旦发送的缓冲区拥有足够的空间，则内核会唤醒对应的进程进行写入操作

    而UDP协议中并不存在发送缓冲区满的情况，UDP套接字执行写操作时永远不会发生阻塞。

### 非阻塞IO

如果有一个IO操作不能马上完成则系统则会让我们的进程进入睡眠状态等待

当我们将一个套接字设置为非阻塞模式时，则系统不会让我们的进程进入睡眠等待而是直接返回错误

当一个程序使用非阻塞模式的套接字，他需要使用循环来不断检查文件描述如是否有数据可读

应用程序不停循环判断将会消耗非常大的CPU资源，**一般不推荐使用**

**非阻塞实现方法：**

当我们一开始建立一个套接字描述符时，系统内核会**默认设置为阻塞型IO**，我们可以使用函数来设置套接字为非阻塞状态。

```C
int socket_fd = socket(...........); // 创建一个套接字描述符
int state = fcntl(socket_fd , F_GETFL , 0) ; // 获得当前描述符的旗标
state |= O_NONBLOCK ; // 在原基础上增加非阻塞属性
fcntl(scoket_fd , F_SETFL , state ); // 把配置的好的旗标重新设置回描述符中
```

### 多路复用

当应用程序同时处理多路数据的输入或输出时，若采用非阻塞模式，将达不到预期的效果

如果采用非阻塞模式，对多个输入进行轮询可以实现，但CPU的消耗非常大

如果使用多进程/多线程，将产生进程与线程同步互斥的问题使得程序变得非常复杂

使用多路复用则是最佳的选择，他的基本思想是：

1. 先把所有需要监听等待的文件描述符添加到一个集合中，

2. 在规定的时间内等待集合中所有描述符数据的变化，如果超时则跳出或进入下一次等待

3. 如果在规定时间内文件描述符的数据有发生变化则把其他没有数据变化的描述符剔除到集合之外等待进行下一次的等待状态。

### 信号驱动

信号驱动其实就是涉及到我们前面所学的Systrm_V的信号，通过监听文件描述符的状态（是否有产生信号）， 当文件描述符有数据到达时就会产生一个IO信号（SIGIO），来通知用户进行IO操作。
		特点：

- 信号驱动一般用于**UDP协议**中，很少用于TCP协议中， 因为TCP协议中会有多次IO状态的改变，所以会有非常多的SIGIO信号产生，非常难捕捉到哪一个时数据到达产生的。
- 由于数据变化时，产生SIGIO信号，所以必须体现设置好信号捕获，并设置其对应的响应函数。
- 必须给文件描述符设置信号触发模式

操作步骤：

1. 建立套接字
2. 绑定端口和地址信息
3. 设置捕获信号并设置响应函数
4. 设定套接字拥有者，用于捕获信号的到来
5. 给套接字添加信号触发模式

```c
// 设置套接字的拥有者
fcntl(sock_fd ,F_SETOWN, getpid());
// 添加信号触发
int state;
state = fcntl(sock_fd,F_GETFL);
state |= O_ASYNC;
fcntl(sock_fd,F_SETFL,state);

while(1)// 循环挂起不让程序退出
{
    printf("__%d__\n" , __LINE__);
    pause();
}
```

## 网络超时接受

一般情况下网络接收数据都采用阻塞属性，就等于一直等待对方数据到达。有的场合中我们可能不需要一直等待，因为可能会没有结果，这是可以使用超时接收，在规定的时间内如果没有数据到达，则超时退出。

主要方法有三种：

- 使用多路复用的slect 函数设置超时时间

- 设置闹钟，当设置时间到达时将会产生一个SIGALRM信号，表示超时

- 设置套接字的属性为超时属性

**多路复用：**

```C
// 配置超时时间
struct timeval time_val ;
time_val.tv_sec = 5 ;
time_val.tv_usec = 0 ;
// 设置多路复用集合
fd_set set ;
FD_ZERO(&set); // 清空 集合
FD_SET(connect_fd , &set); // 添加 套记字到集合中
FD_SET(STDIN_FILENO , &set); // 添加标准输入到集合中

// 找到描述符最大值
max_fd = connect_fd > STDIN_FILENO ? connect_fd : STDIN_FILENO ;
// 等待描述符状态变化并设置超时 5秒
int ret_val = select(max_fd+1, &set , NULL ,NULL, &time_val);
if( tet_val == -1 )
{
	printf("接收数据超时！！\n");
	return -1 ;
}
```

**设置闹钟**

闹钟这种方式类似于信号驱动，信号驱动当收到信号时，证明有数据发送过来。闹钟使用alarm函数来提前设定一个时间，当时间到达时，回自动产生一个信号 14) SIGALRM。

思路：

1. 使用signal函数设置好捕获闹钟信号，并设置好响应处理函数。
2. 使用alarm()函数设置一个闹钟时间
3. 当闹钟时间结束时产生一个 SIGALRM 信号
4. 当捕获到闹钟信号则运行对应的响应函数
5. 重新设置闹钟

**设置套接字超时属性**

在Linux下，建立套接字都是阻塞属性.我们设置一个超时属性给套接字，这样读取套接字数据时，在规定的时间会阻塞，但是在规定的时间之外，读取失败。

思路：

1. 获得一个连接套接字
2. 使用函数设置超时属性setsockopt（）
3. 正常玩耍，当接收函数返回-1时就是超时的时候了

## 广播与组播

### 广播

前面我们所写的所有代码都只能实现点对点的通信，除非使用多线程或多进程的手段来实现一对多的通信效果。如何不使用进程线程的手段来实现给局域网中所有的主机发送一对多的广播效果呢？可以使用Linux中的广播机制。

特点：

- 不需要循环给每一个主机发送数据，而是在同一个局域网中所有的主机都能收到广播信息
- 只需要向广播地址发送数据即可，整个局域网中的主机都能收到该信息
- 只有UDP协议才支持这个骚操作

只需要把数据发送到 广播地址 （192.168.100.255） 中即可实现向局域网中所有的主机发送，在局域网中所有的主机主要愿意都可以从 广播地址 （192.168.100.255）中收到消息。而255.255.255.255是所有网段局域网的广播地址

思路：
	由于Linux 下创建的套接字默认是没有打开广播功能的，所以需要手动开启。

1. 创建UDP套接字
2. 设置广播属性
3. 往广播地址中发送数据即可

### 组播

组播是处于单播与广播之间的折中选择，在一个局域网内，把某些主机加入到多播组中，并设置一个地址给多播组，这样我们就只需要把数据往该多播组的地址上发送即可，加入该组的所有主机都会收到数据。

特点：

- 广播方式发给所有的主机是，如果有太多的数据占用网络带宽，将很容易造成网络风暴影响通信
- 在组播前必须为多播组设置一个IP地址，该IP地址必须是**D类网络地址**。
- 只有UDP协议支持组播功能。

**IP地址分类**

网络字节 主机字节 范围

A类地址： 1字节 3字节 1.0.0.1 --- 126.255.255.255

B类地址： 2字节 2字节 128.0.0.1 --- 191.255.255.255

C类地址： 3字节 1字节 192.0.0.1 --- 223.255.255.255

D类地址，不区别网络字节与主机字节 224.0.0.1 --- 239.255.255.255



思路：

1. 创建UDP套接字
2. 配置组播结构体 -- 》 设置组播的IP地址（加入哪个小组） 设置值得主机的IP地址
3. 加入组播
4. 等待消息

